[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../藏书阁/Lecture 26 Thread Level Parallelism.mp4
Video File: ../../../藏书阁/Lecture 26 Thread Level Parallelism.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.500000
Scroll Position: 561
Active Line: 1541
Video Position: 117585

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,44,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:01.12,English,,0,0,0,,Hello everyone
Dialogue: 0,0:00:00.00,0:00:01.12,Chinese,,0,0,0,,大家好
Dialogue: 0,0:00:03.78,0:00:08.28,English,,0,0,0,,Interesting,how far fewer seats are filled than at the beginning of the course
Dialogue: 0,0:00:03.78,0:00:08.28,Chinese,,0,0,0,,有趣的是，来的同学比课程刚开始时少很多
Dialogue: 0,0:00:09.70,0:00:14.56,English,,0,0,0,,So that of course we're in the final stretch of this course
Dialogue: 0,0:00:09.70,0:00:14.56,Chinese,,0,0,0,,显然，我们已经到了课程的最后阶段
Dialogue: 0,0:00:15.14,0:00:16.72,English,,0,0,0,,You're working on the last lab
Dialogue: 0,0:00:15.14,0:00:16.72,Chinese,,0,0,0,,你正在做的是最后一个 Lab
Dialogue: 0,0:00:17.44,0:00:23.58,English,,0,0,0,,And the material that we're covering both this lecture and next lecture are not on the exam
Dialogue: 0,0:00:17.44,0:00:23.58,Chinese,,0,0,0,,本次课和下一次课中所涉及的内容都不在考试中
Dialogue: 0,0:00:23.58,0:00:25.02,English,,0,0,0,,And you don't need them for your lab
Dialogue: 0,0:00:23.58,0:00:25.02,Chinese,,0,0,0,,而且你正在做的 Lab 也不需要这些内容
Dialogue: 0,0:00:25.02,0:00:28.38,English,,0,0,0,,So at some level you could just to know and skip it all
Dialogue: 0,0:00:25.02,0:00:28.38,Chinese,,0,0,0,,所以在某种程度上你可以只是了解一下这些内容，然后跳过
Dialogue: 0,0:00:28.38,0:00:31.40,English,,0,0,0,,And if your only purpose in taking this course is to pass it
Dialogue: 0,0:00:28.38,0:00:31.40,Chinese,,0,0,0,,不过如果你参加这门课程的目的仅仅是通过考试的话
Dialogue: 0,0:00:33.14,0:00:37.52,English,,0,0,0,,Or to get some grade in it and that's it well go ahead to now
Dialogue: 0,0:00:33.14,0:00:37.52,Chinese,,0,0,0,,或者仅仅为了刷学分，那你现在可以离开了
Dialogue: 0,0:00:38.16,0:00:44.90,English,,0,0,0,,But on the other hand the material we're talking about is very relevant to where computers are today
Dialogue: 0,0:00:38.16,0:00:44.90,Chinese,,0,0,0,,但另一方面，我们今天要讨论的内容，与现阶段的计算机
Dialogue: 0,0:00:44.90,0:00:46.38,English,,0,0,0,,And where they're going in the future
Dialogue: 0,0:00:44.90,0:00:46.38,Chinese,,0,0,0,,以及未来计算机的发展型态，都息息相关
Dialogue: 0,0:00:46.88,0:00:49.28,English,,0,0,0,,And so if you think about the longer term
Dialogue: 0,0:00:46.88,0:00:49.28,Chinese,,0,0,0,,所以，如果从长远角度考虑
Dialogue: 0,0:00:49.28,0:00:54.02,English,,0,0,0,,And whatever your investment is in the computer industry and computer technology is
Dialogue: 0,0:00:49.28,0:00:54.02,Chinese,,0,0,0,,无论你想投身到计算机工业界或学术界
Dialogue: 0,0:00:54.54,0:00:56.86,English,,0,0,0,,Then I think you'll find these very worthwhile
Dialogue: 0,0:00:54.54,0:00:56.86,Chinese,,0,0,0,,我认为你会发现这些内容都非常有意义
Dialogue: 0,0:00:57.48,0:01:01.36,English,,0,0,0,,But so think of this more as the icing on the cake
Dialogue: 0,0:00:57.48,0:01:01.36,Chinese,,0,0,0,,所以可以认为这些内容更多是锦上添花
Dialogue: 0,0:01:01.40,0:01:05.28,English,,0,0,0,,You've learned the hard stuff you've done the grinding part
Dialogue: 0,0:01:01.40,0:01:05.28,Chinese,,0,0,0,,你已经学会了最难的东西，你已经完成了最艰难的部分
Dialogue: 0,0:01:05.70,0:01:12.44,English,,0,0,0,,And now you get to think beyond the sort of narrow confines of the course material and think bigger
Dialogue: 0,0:01:05.70,0:01:12.44,Chinese,,0,0,0,,现在，你可以不局限于课本的内容，进行更广阔的思考
Dialogue: 0,0:01:12.50,0:01:18.00,English,,0,0,0,,But that's really the way you should be viewing this lecture and the last lecture which will be on Thursday
Dialogue: 0,0:01:12.50,0:01:18.00,Chinese,,0,0,0,,这才应该是你学习本次课和最后一次课的方式
Dialogue: 0,0:01:18.68,0:01:21.30,English,,0,0,0,,So today what we're going to talk about is parallelism
Dialogue: 0,0:01:18.68,0:01:21.30,Chinese,,0,0,0,,所以今天我们要讨论的是并行
Dialogue: 0,0:01:22.98,0:01:24.20,English,,0,0,0,,And the issue is that...
Dialogue: 0,0:01:22.98,0:01:24.20,Chinese,,0,0,0,,问题是 ......
Dialogue: 0,0:01:25.98,0:01:26.86,English,,0,0,0,,That
Dialogue: 0,0:01:25.98,0:01:26.86,Chinese,,0,0,0,,是
Dialogue: 0,0:01:28.12,0:01:28.54,English,,0,0,0,,Wow
Dialogue: 0,0:01:28.12,0:01:28.54,Chinese,,0,0,0,,哇
Dialogue: 0,0:01:33.18,0:01:37.26,English,,0,0,0,,That PowerPoint is a product made by a certain company in Seattle that
Dialogue: 0,0:01:33.18,0:01:37.26,Chinese,,0,0,0,, PowerPoint 是由西雅图的某家公司（微软）的产品
Dialogue: 0,0:01:38.08,0:01:40.08,English,,0,0,0,,It's not always reliable but
Dialogue: 0,0:01:38.08,0:01:40.08,Chinese,,0,0,0,,显然, 它不是随时都很稳定..（下面进入正题）
Dialogue: 0,0:01:41.04,0:01:49.30,English,,0,0,0,,The issue is as you know nowadays when you buy a computer you don't get just one CPU on the processor chip
Dialogue: 0,0:01:41.04,0:01:49.30,Chinese,,0,0,0,,如今当你购买一台电脑，处理器芯片上通常不会只有一个 CPU （这里指代 CPU 核）
Dialogue: 0,0:01:49.38,0:01:52.42,English,,0,0,0,,You have at least two on a typical laptop
Dialogue: 0,0:01:49.38,0:01:52.42,Chinese,,0,0,0,,一般的笔记本电脑至少有两个 CPU 核
Dialogue: 0,0:01:53.10,0:02:00.50,English,,0,0,0,,Even my phone has two cores in it and as well as four graphic processing units
Dialogue: 0,0:01:53.10,0:02:00.50,Chinese,,0,0,0,,即使我的手机都有两个 CPU 核以及四个图形处理单元
Dialogue: 0,0:02:01.34,0:02:07.80,English,,0,0,0,,And a typical the next generation of iPad will be a six core processor
Dialogue: 0,0:02:01.34,0:02:07.80,Chinese,,0,0,0,,而下一代 iPad 将拥有六核处理器（2017年已发布，A10X处理器）
Dialogue: 0,0:02:07.92,0:02:15.90,English,,0,0,0,,So these have become not just the sort of specialized domain of high machines
Dialogue: 0,0:02:07.92,0:02:15.90,Chinese,,0,0,0,,所以这些（多核处理器）不仅仅限于高计算用途的计算机
Dialogue: 0,0:02:16.00,0:02:18.60,English,,0,0,0,,But actually there all the time
Dialogue: 0,0:02:16.00,0:02:18.60,Chinese,,0,0,0,,也会在日常出现
Dialogue: 0,0:02:19.06,0:02:25.80,English,,0,0,0,,And actually we'll talk some next time why is it that instead of having one fast computer
Dialogue: 0,0:02:19.06,0:02:25.80,Chinese,,0,0,0,,实际上我们下次会谈到为什么不是采用一个极快的单核计算机
Dialogue: 0,0:02:25.80,0:02:31.20,English,,0,0,0,,You get two medium size medium performance processors on a chip or more
Dialogue: 0,0:02:25.80,0:02:31.20,Chinese,,0,0,0,,而是使用两个或多个中等性能的多核处理器在芯片上
Dialogue: 0,0:02:31.68,0:02:35.60,English,,0,0,0,,And that that's actually a really interesting technology issue that I'll talk about next time
Dialogue: 0,0:02:31.68,0:02:35.60,Chinese,,0,0,0,,这实际上是一个非常有趣的技术课题，我将在下次讨论
Dialogue: 0,0:02:36.18,0:02:39.96,English,,0,0,0,,But it's the way it is,so you can think of it when you write a program
Dialogue: 0,0:02:36.18,0:02:39.96,Chinese,,0,0,0,,但它就是这样工作的，你可以想象，当你写一个程序
Dialogue: 0,0:02:41.92,0:02:44.10,English,,0,0,0,,Ah and it runs as a single thread
Dialogue: 0,0:02:41.92,0:02:44.10,Chinese,,0,0,0,,并且在单线程环境运行
Dialogue: 0,0:02:44.50,0:02:50.40,English,,0,0,0,,Then you're basically not making use of the computing resources that you have available to you
Dialogue: 0,0:02:44.50,0:02:50.40,Chinese,,0,0,0,,此时这个程序就没有充分利用上本可使用的计算资源
Dialogue: 0,0:02:51.10,0:02:56.98,English,,0,0,0,,So the natural thing is well could we make our programs run faster by doing multiple threads
Dialogue: 0,0:02:51.10,0:02:56.98,Chinese,,0,0,0,,因此，我们理所当然可以通过使用多线程，让程序跑的更快
Dialogue: 0,0:02:57.60,0:02:58.64,English,,0,0,0,,So you've already learned
Dialogue: 0,0:02:57.60,0:02:58.64,Chinese,,0,0,0,,所以你已经学会
Dialogue: 0,0:02:59.16,0:03:04.52,English,,0,0,0,,Or you're in the process of applying a multi-threaded programming
Dialogue: 0,0:02:59.16,0:03:04.52,Chinese,,0,0,0,,或者说你正在学怎么使用多线程编程技术
Dialogue: 0,0:03:05.00,0:03:06.10,English,,0,0,0,,As a way to
Dialogue: 0,0:03:05.00,0:03:06.10,Chinese,,0,0,0,,作为一种
Dialogue: 0,0:03:09.58,0:03:13.88,English,,0,0,0,,Deal with concurrency of external events
Dialogue: 0,0:03:09.58,0:03:13.88,Chinese,,0,0,0,,处理外部事件并发的方式
Dialogue: 0,0:03:14.08,0:03:17.82,English,,0,0,0,,There's multiple clients who want to make use of a server
Dialogue: 0,0:03:14.08,0:03:17.82,Chinese,,0,0,0,,假如有多个客户程序想要共用一台服务器（通信）
Dialogue: 0,0:03:18.24,0:03:22.32,English,,0,0,0,,And instead of serving one and then another and then another if you can handle them all
Dialogue: 0,0:03:18.24,0:03:22.32,Chinese,,0,0,0,,你可以同时处理他们的请求，而不是挨个处理
Dialogue: 0,0:03:23.00,0:03:25.80,English,,0,0,0,,It's sort of an external use of concurrency
Dialogue: 0,0:03:23.00,0:03:25.80,Chinese,,0,0,0,,这是某种外部访问模式下的并发性
Dialogue: 0,0:03:26.60,0:03:29.56,English,,0,0,0,,But what we'll talk about today is more internal use
Dialogue: 0,0:03:26.60,0:03:29.56,Chinese,,0,0,0,,但我们今天要讨论的更多是内部并发的模式
Dialogue: 0,0:03:29.82,0:03:37.40,English,,0,0,0,,Can make use of multiple threads running on multiple cores to make a program run a single program run faster
Dialogue: 0,0:03:29.82,0:03:37.40,Chinese,,0,0,0,,内部模式是我们利用可以在多核上运行的多个线程，使单个程序运行得更快
Dialogue: 0,0:03:38.16,0:03:41.14,English,,0,0,0,,And the message behind that is yes but
Dialogue: 0,0:03:38.16,0:03:41.14,Chinese,,0,0,0,,不过背后的含义是我们可以做到，但是（这并不容易）
Dialogue: 0,0:03:41.86,0:03:50.02,English,,0,0,0,,And what mean is it is truly possible and people spend a lot of time making programs run faster by using multiple threads
Dialogue: 0,0:03:41.86,0:03:50.02,Chinese,,0,0,0,,人们确实可以通过花大量时间使程序在多线程环境运行，从而变快
Dialogue: 0,0:03:50.50,0:03:53.76,English,,0,0,0,,But it's harder than you'd think it should be and
Dialogue: 0,0:03:50.50,0:03:53.76,Chinese,,0,0,0,,但它比你想象的要难得多
Dialogue: 0,0:03:53.98,0:03:57.92,English,,0,0,0,,It's fraught with as you probably already experienced programming bugs
Dialogue: 0,0:03:53.98,0:03:57.92,Chinese,,0,0,0,,多线程极易出现 bug，你大概在编程中已体会到
Dialogue: 0,0:03:58.40,0:04:04.04,English,,0,0,0,,But also it's just really darn hard to get the kind of performance out of a multi-core processor
Dialogue: 0,0:03:58.40,0:04:04.04,Chinese,,0,0,0,,但是还有一点就是，从多核处理器中获得你觉得可以得到的性能提升
Dialogue: 0,0:04:04.06,0:04:06.34,English,,0,0,0,,That you should would think it'd be available
Dialogue: 0,0:04:04.06,0:04:06.34,Chinese,,0,0,0,,真的很难
Dialogue: 0,0:04:06.86,0:04:08.12,English,,0,0,0,,So we'll talk about some of that
Dialogue: 0,0:04:06.86,0:04:08.12,Chinese,,0,0,0,,所以我们将讨论一些这样的问题
Dialogue: 0,0:04:09.48,0:04:12.72,English,,0,0,0,,And then we'll finish it up a little bit understanding of
Dialogue: 0,0:04:09.48,0:04:12.72,Chinese,,0,0,0,,然后我们会去理解
Dialogue: 0,0:04:13.28,0:04:20.46,English,,0,0,0,,How when you writing concurrent programs you want to think about the state of memory
Dialogue: 0,0:04:13.28,0:04:20.46,Chinese,,0,0,0,,当你编写并发程序时应该如何去考虑内存状态
Dialogue: 0,0:04:20.92,0:04:27.78,English,,0,0,0,,And how that's a challenge for multi-core processors or in fact any concurrent system
Dialogue: 0,0:04:20.92,0:04:27.78,Chinese,,0,0,0,,并且为什么说这对于多核处理器甚至任何并发系统来说都是一个挑战
Dialogue: 0,0:04:30.58,0:04:37.90,English,,0,0,0,,So there's actually two sources of concurrency on a modern processor multiple cores
Dialogue: 0,0:04:30.58,0:04:37.90,Chinese,,0,0,0,,所以在现代多核处理器上，其实有两个并发的来源
Dialogue: 0,0:04:37.96,0:04:43.08,English,,0,0,0,,Which is you have actually a multiple cpus on a single chip
Dialogue: 0,0:04:37.96,0:04:43.08,Chinese,,0,0,0,,你在一块芯片上实际上有多个 cpu 核
Dialogue: 0,0:04:43.54,0:04:45.48,English,,0,0,0,,But there's also something called hyper-threading
Dialogue: 0,0:04:43.54,0:04:45.48,Chinese,,0,0,0,,但也有一种称为超线程的东西
Dialogue: 0,0:04:46.18,0:04:48.54,English,,0,0,0,,Which is in my experience is less useful
Dialogue: 0,0:04:46.18,0:04:48.54,Chinese,,0,0,0,,根据我的经验，它没有多核有用
Dialogue: 0,0:04:48.98,0:04:50.02,English,,0,0,0,,But let me go through this
Dialogue: 0,0:04:48.98,0:04:50.02,Chinese,,0,0,0,,不过，让我们来过一下这张图
Dialogue: 0,0:04:50.50,0:04:56.36,English,,0,0,0,,So this is what a typical modern processor looks like processor chip
Dialogue: 0,0:04:50.50,0:04:56.36,Chinese,,0,0,0,,这就是典型的现代处理器芯片看起来的样子
Dialogue: 0,0:04:57.04,0:04:58.96,English,,0,0,0,,Is that there's actually on a single chip
Dialogue: 0,0:04:57.04,0:04:58.96,Chinese,,0,0,0,,那的确真的在一块芯片上
Dialogue: 0,0:04:59.66,0:05:03.28,English,,0,0,0,,There's multiple independent CPUs
Dialogue: 0,0:04:59.66,0:05:03.28,Chinese,,0,0,0,,有多个独立的 CPU 核 （这里我们猜测老师指代的是CPU cores，因为现代架构中很少有多CPU设计）
Dialogue: 0,0:05:04.72,0:05:09.32,English,,0,0,0,,And each of them has some part of the cache hierarchy
Dialogue: 0,0:05:04.72,0:05:09.32,Chinese,,0,0,0,,并且它们每一个都具有缓存结构的一部分
Dialogue: 0,0:05:10.44,0:05:15.28,English,,0,0,0,,Which is private to that particular core
Dialogue: 0,0:05:10.44,0:05:15.28,Chinese,,0,0,0,,这部分缓存是对每个 CPU 是私有的
Dialogue: 0,0:05:15.94,0:05:20.04,English,,0,0,0,,And then there is another part of the cache hierarchy that's shared across cores
Dialogue: 0,0:05:15.94,0:05:20.04,Chinese,,0,0,0,,然后这里另外一部分是在缓存层次中可共享的部分
Dialogue: 0,0:05:20.60,0:05:23.66,English,,0,0,0,,And then they all have a common interface to main memory
Dialogue: 0,0:05:20.60,0:05:23.66,Chinese,,0,0,0,,然后他们通过一个通用接口与内存连接
Dialogue: 0,0:05:25.28,0:05:28.34,English,,0,0,0,,So if these cores are running and this is what happens a lot is
Dialogue: 0,0:05:25.28,0:05:28.34,Chinese,,0,0,0,,因此，如果这些核一起运行，那么就会发生很多事情
Dialogue: 0,0:05:28.42,0:05:32.28,English,,0,0,0,,They're running programs that are completely independent have nothing to do with each
Dialogue: 0,0:05:28.42,0:05:32.28,Chinese,,0,0,0,,他们完全独立运行各自的程序，不用相互关照
Dialogue: 0,0:05:32.78,0:05:36.90,English,,0,0,0,,Other then they more or less just exist and run and they're happy as can be
Dialogue: 0,0:05:32.78,0:05:36.90,Chinese,,0,0,0,,除此之外，他们各自存在和运行着
Dialogue: 0,0:05:36.90,0:05:40.06,English,,0,0,0,,They are caching parts of their own state
Dialogue: 0,0:05:36.90,0:05:40.06,Chinese,,0,0,0,,他们缓存着各自的状态
Dialogue: 0,0:05:40.70,0:05:49.42,English,,0,0,0,,And you know sometimes this cache will get polluted by the junk from other programs in terms of performance
Dialogue: 0,0:05:40.70,0:05:49.42,Chinese,,0,0,0,,而且，有时候缓存会被其他程序污染，影响性能
Dialogue: 0,0:05:49.66,0:05:51.74,English,,0,0,0,,But it will matter with functionality
Dialogue: 0,0:05:49.66,0:05:51.74,Chinese,,0,0,0,,但是有时对功能也有影响
Dialogue: 0,0:05:52.46,0:05:56.52,English,,0,0,0,,The trick when you're trying to do multi-core programming as a parallel computing thing
Dialogue: 0,0:05:52.46,0:05:56.52,Chinese,,0,0,0,,当你编写多线程程序来进行并行计算时，诀窍是
Dialogue: 0,0:05:56.62,0:06:05.30,English,,0,0,0,,Somehow getting all these cores working on parts of different parts of a single problem in a way that
Dialogue: 0,0:05:56.62,0:06:05.30,Chinese,,0,0,0,,通过某种方式，让每个核处理单个问题的不同部分
Dialogue: 0,0:06:06.52,0:06:09.12,English,,0,0,0,,Makes it so that you get the performance out of it
Dialogue: 0,0:06:06.52,0:06:09.12,Chinese,,0,0,0,,从而获得所需性能
Dialogue: 0,0:06:09.16,0:06:13.72,English,,0,0,0,,They don't spend all their time basically arguing with each other about who has access to what
Dialogue: 0,0:06:09.16,0:06:13.72,Chinese,,0,0,0,,他们不会将时间花在决定谁可以访问什么
Dialogue: 0,0:06:14.70,0:06:18.70,English,,0,0,0,,And also they're not stepping over each other and messing up each other's state
Dialogue: 0,0:06:14.70,0:06:18.70,Chinese,,0,0,0,,而且他们也没有干涉对方，弄乱对方的状态
Dialogue: 0,0:06:22.22,0:06:28.78,English,,0,0,0,,So hyper threading is a little bit more into the deep works of how a processor operates
Dialogue: 0,0:06:22.22,0:06:28.78,Chinese,,0,0,0,,超线程更多涉及到一些底层原理，如处理器如何运行
Dialogue: 0,0:06:29.46,0:06:35.06,English,,0,0,0,,You'll recall from the lecture on a performance or what's chapter 5 of the book
Dialogue: 0,0:06:29.46,0:06:35.06,Chinese,,0,0,0,,你可以回忆下之前讲性能的课或者查看书的第五章
Dialogue: 0,0:06:35.76,0:06:43.86,English,,0,0,0,,That a modern microprocessor looks absolutely nothing like the model that you get by looking at assembly code instructions
Dialogue: 0,0:06:35.76,0:06:43.86,Chinese,,0,0,0,,现代微处理器工作时看起来绝对不像汇编代码教程那样
Dialogue: 0,0:06:44.00,0:06:47.20,English,,0,0,0,,The model of assembly code is you execute one instruction
Dialogue: 0,0:06:44.00,0:06:47.20,Chinese,,0,0,0,,汇编代码的模型是执行一条指令
Dialogue: 0,0:06:47.78,0:06:50.65,English,,0,0,0,,Then you execute the next one then you execute the next one
Dialogue: 0,0:06:47.78,0:06:50.65,Chinese,,0,0,0,,然后执行下一个，然后执行下一个
Dialogue: 0,0:06:51.02,0:06:52.86,English,,0,0,0,,Modern processors don't do that at all
Dialogue: 0,0:06:51.02,0:06:52.86,Chinese,,0,0,0,,现代处理器根本不这样做
Dialogue: 0,0:06:53.34,0:06:59.00,English,,0,0,0,,They haven't done it for...well they haven't done it that way for 30 years
Dialogue: 0,0:06:53.34,0:06:59.00,Chinese,,0,0,0,,他们没有这样做 ...... 他们 30 年来没有这样做过
Dialogue: 0,0:06:59.60,0:07:04.06,English,,0,0,0,,And since 1995 so since 20 years
Dialogue: 0,0:06:59.60,0:07:04.06,Chinese,,0,0,0,,自 1995 年以来，自 20 年以来
Dialogue: 0,0:07:04.60,0:07:06.60,English,,0,0,0,,They do it in this totally different way
Dialogue: 0,0:07:04.60,0:07:06.60,Chinese,,0,0,0,,他们以完全不同的方式来设计处理器结构
Dialogue: 0,0:07:07.04,0:07:12.28,English,,0,0,0,,Which is sometimes referred to as out of order processing and so just real quickly
Dialogue: 0,0:07:07.04,0:07:12.28,Chinese,,0,0,0,,这有时被称为无序处理，但是这样真的很快
Dialogue: 0,0:07:13.14,0:07:16.36,English,,0,0,0,,The the basic idea is on the processor chip
Dialogue: 0,0:07:13.14,0:07:16.36,Chinese,,0,0,0,,基本思路是在处理器芯片上
Dialogue: 0,0:07:16.36,0:07:20.78,English,,0,0,0,,There's multiple functional units that are capable of doing different types of operation
Dialogue: 0,0:07:16.36,0:07:20.78,Chinese,,0,0,0,,有多个功能单元能够执行不同类型的操作
Dialogue: 0,0:07:21.24,0:07:26.76,English,,0,0,0,,There's ones for integer arithmetic these ones for floating-point arithmetic and so forth
Dialogue: 0,0:07:21.24,0:07:26.76,Chinese,,0,0,0,,有一些用于整数运算，有些用于浮点运算等等
Dialogue: 0,0:07:27.14,0:07:32.76,English,,0,0,0,,And then there's separate blocks that interface to the memory actually to the cache memories
Dialogue: 0,0:07:27.14,0:07:32.76,Chinese,,0,0,0,,然后这些单独的块，它们实际上与高速缓存存储器连接
Dialogue: 0,0:07:33.38,0:07:38.96,English,,0,0,0,,And they're both loading meaning reading from the memory and storing writing out to memory
Dialogue: 0,0:07:33.38,0:07:38.96,Chinese,,0,0,0,,而且它们可以从内存中读取数据并将写入到内存中
Dialogue: 0,0:07:39.76,0:07:43.14,English,,0,0,0,,But these units are sort of operating independently
Dialogue: 0,0:07:39.76,0:07:43.14,Chinese,,0,0,0,,但这些功能单位有点在像独立运作
Dialogue: 0,0:07:43.60,0:07:50.88,English,,0,0,0,,And what happens is there's a block of logic which is actually enormous with huge block of logic in an x86 processor
Dialogue: 0,0:07:43.60,0:07:50.88,Chinese,,0,0,0,,接下来会发生的是，这些功能单位里存在逻辑块（在 x86 处理器中存在很多巨大的逻辑块）
Dialogue: 0,0:07:51.44,0:07:54.40,English,,0,0,0,,That reads the instructions out of the instruction stream
Dialogue: 0,0:07:51.44,0:07:54.40,Chinese,,0,0,0,,它从指令流中读取指令
Dialogue: 0,0:07:54.86,0:08:01.16,English,,0,0,0,,Rips them apart into little pieces， keeps track of data dependencies and control dependencies
Dialogue: 0,0:07:54.86,0:08:01.16,Chinese,,0,0,0,,将它们分成小块，并可以跟踪数据依赖和控制依赖
Dialogue: 0,0:08:01.66,0:08:07.92,English,,0,0,0,,And then schedules all the various operations in your program on these different functional units
Dialogue: 0,0:08:01.66,0:08:07.92,Chinese,,0,0,0,,然后在这些不同的功能单元上，规划分配程序不同的操作指令
Dialogue: 0,0:08:08.02,0:08:14.70,English,,0,0,0,,So we talked some about that of in the context of how can you write up program that sort of maximize
Dialogue: 0,0:08:08.02,0:08:14.70,Chinese,,0,0,0,,所以，我们之前探讨过类似的逻辑，背景是如何写出优化的程序
Dialogue: 0,0:08:15.78,0:08:21.64,English,,0,0,0,,How much is going on down here by writing your code in a particular ways
Dialogue: 0,0:08:15.78,0:08:21.64,Chinese,,0,0,0,,如何以特定的方式写出你的代码，使得开销最小
Dialogue: 0,0:08:22.62,0:08:26.22,English,,0,0,0,,So all this is an introduction to say
Dialogue: 0,0:08:22.62,0:08:26.22,Chinese,,0,0,0,,所以这一切都是一个起点，意味着
Dialogue: 0,0:08:26.60,0:08:29.26,English,,0,0,0,,This is how you have to understand what hyper threading is
Dialogue: 0,0:08:26.60,0:08:29.26,Chinese,,0,0,0,,你必须了解超线程是怎样的
Dialogue: 0,0:08:30.82,0:08:35.46,English,,0,0,0,,So in a single execution mode there's basically one instruction decoder
Dialogue: 0,0:08:30.82,0:08:35.46,Chinese,,0,0,0,,因此，在每个执行单元中，基本上都有一个指令解码器
Dialogue: 0,0:08:36.54,0:08:40.76,English,,0,0,0,,And it has its own set of state here its own program counter
Dialogue: 0,0:08:36.54,0:08:40.76,Chinese,,0,0,0,,它有自己的状态集合，有自己的程序计数器
Dialogue: 0,0:08:41.18,0:08:46.76,English,,0,0,0,,Its own queue of operations that it's already decoded and haven't completed yet
Dialogue: 0,0:08:41.18,0:08:46.76,Chinese,,0,0,0,,有自己已经解码但未执行的操作指令队列
Dialogue: 0,0:08:47.34,0:08:53.84,English,,0,0,0,,It has its own set of registers they're actually not registers like you'd expect， they're highly virtualized registers
Dialogue: 0,0:08:47.34,0:08:53.84,Chinese,,0,0,0,,它有自己的一组寄存器，它们实际上不是你想的那种寄存器，而是一种高度虚拟化的寄存器
Dialogue: 0,0:08:54.52,0:09:01.84,English,,0,0,0,,But all this state is there to help to service the execution of one thread of execution
Dialogue: 0,0:08:54.52,0:09:01.84,Chinese,,0,0,0,,但是所有这些状态都是为了帮助执行程序的某一个线程
Dialogue: 0,0:09:02.82,0:09:05.26,English,,0,0,0,,With hyper threading basically what you do is
Dialogue: 0,0:09:02.82,0:09:05.26,Chinese,,0,0,0,,超线程的基本思想是
Dialogue: 0,0:09:05.82,0:09:12.78,English,,0,0,0,,The idea that is to say 90% of all programs don't really make use of all these functional units
Dialogue: 0,0:09:05.82,0:09:12.78,Chinese,,0,0,0,, 90% 的程序都没有完全利用所有这些功能单元
Dialogue: 0,0:09:12.94,0:09:19.16,English,,0,0,0,,Especially if you're blocking on a load because there's a miss in a cache
Dialogue: 0,0:09:12.94,0:09:19.16,Chinese,,0,0,0,,特别是因为缓存缺失而导致的阻塞时
Dialogue: 0,0:09:19.86,0:09:24.00,English,,0,0,0,,Then all these arithmetic units are sitting there without anything useful work to do
Dialogue: 0,0:09:19.86,0:09:24.00,Chinese,,0,0,0,,所有这些算术单元都处于空闲状态
Dialogue: 0,0:09:25.52,0:09:28.20,English,,0,0,0,,Oh and so why don't we just double up
Dialogue: 0,0:09:25.52,0:09:28.20,Chinese,,0,0,0,,所以我们为什么不加倍
Dialogue: 0,0:09:29.06,0:09:32.46,English,,0,0,0,,Or quadruple upper K times up
Dialogue: 0,0:09:29.06,0:09:32.46,Chinese,,0,0,0,,或者翻 K 倍
Dialogue: 0,0:09:33.04,0:09:39.54,English,,0,0,0,,The state associated with the decoding and control parts of the program
Dialogue: 0,0:09:33.04,0:09:39.54,Chinese,,0,0,0,,与程序的解码和控制部分相关联的状态（指寄存器，操作指令队列，程序计数器等）
Dialogue: 0,0:09:40.12,0:09:42.34,English,,0,0,0,,So that you can have multiple threads running
Dialogue: 0,0:09:40.12,0:09:42.34,Chinese,,0,0,0,,这样你就可以让多个线程运转起来
Dialogue: 0,0:09:43.68,0:09:46.56,English,,0,0,0,,And sharing these functional units among each other
Dialogue: 0,0:09:43.68,0:09:46.56,Chinese,,0,0,0,,同时彼此之间共享这些功能单元
Dialogue: 0,0:09:46.64,0:09:52.32,English,,0,0,0,,So they're operating really independently their states are not intertwined
Dialogue: 0,0:09:46.64,0:09:52.32,Chinese,,0,0,0,,因此，他们是真正意义上在独立运行着，他们的状态区域不是交织在一起的
Dialogue: 0,0:09:52.90,0:09:59.24,English,,0,0,0,,But they're sort of making more use of the available hardware for performing functions
Dialogue: 0,0:09:52.90,0:09:59.24,Chinese,,0,0,0,,但他们某种程度上能更多的使用可用硬件来执行函数，提高性能
Dialogue: 0,0:09:59.56,0:10:02.32,English,,0,0,0,,And so that's called hyper threading that's an Intel term
Dialogue: 0,0:09:59.56,0:10:02.32,Chinese,,0,0,0,,因此，这称为「超线程」，是英特尔术语
Dialogue: 0,0:10:02.90,0:10:06.78,English,,0,0,0,,You also sometimes hear call SMT simultaneous multi-threading
Dialogue: 0,0:10:02.90,0:10:06.78,Chinese,,0,0,0,,有时也被称为 SMT 同步多线程
Dialogue: 0,0:10:07.58,0:10:09.10,English,,0,0,0,,And in my experience...
Dialogue: 0,0:10:07.58,0:10:09.10,Chinese,,0,0,0,,根据我的经验...
Dialogue: 0,0:10:10.08,0:10:13.72,English,,0,0,0,,And we'll see here the numbers it doesn't really make that big a difference
Dialogue: 0,0:10:10.08,0:10:13.72,Chinese,,0,0,0,,接下来我们将看到数据它并没有发挥很大的作用
Dialogue: 0,0:10:14.00,0:10:19.72,English,,0,0,0,,But it turns out to be in the sort of large picture things
Dialogue: 0,0:10:14.00,0:10:19.72,Chinese,,0,0,0,,但事实证明，这是一种宏观意识
Dialogue: 0,0:10:20.16,0:10:24.60,English,,0,0,0,,A relatively inexpensive feature for them to throw on to processors and so they do it
Dialogue: 0,0:10:20.16,0:10:24.60,Chinese,,0,0,0,,当可以往处理器中加入的一个相对成本较低的特性时，他们就会这样做
Dialogue: 0,0:10:25.28,0:10:32.30,English,,0,0,0,,And so nowadays at least with an x86 processor usually have 2-way hyper-threading in them
Dialogue: 0,0:10:25.28,0:10:32.30,Chinese,,0,0,0,,因此，现在至少对于 x86 处理器来说，它通常带有双向的超线程设计
Dialogue: 0,0:10:34.02,0:10:40.64,English,,0,0,0,,So given that if you look at our shark machines which are a little bit old there's sort of 2010 era machine
Dialogue: 0,0:10:34.02,0:10:40.64,Chinese,,0,0,0,,因此，考虑到这些，如果你看到鲨鱼机器的配置，它有一些老，是 2010 年代的机器
Dialogue: 0,0:10:41.10,0:10:43.92,English,,0,0,0,,But they were high-end machines in their day
Dialogue: 0,0:10:41.10,0:10:43.92,Chinese,,0,0,0,,但他们当时是高端机器
Dialogue: 0,0:10:43.92,0:10:47.20,English,,0,0,0,,And so they still actually are more powerful than
Dialogue: 0,0:10:43.92,0:10:47.20,Chinese,,0,0,0,,所以它们实际上仍比
Dialogue: 0,0:10:47.72,0:10:53.56,English,,0,0,0,,What you'd buy as say a desktop and way more powerful than as a laptop that you'd get today
Dialogue: 0,0:10:47.72,0:10:53.56,Chinese,,0,0,0,,如今你买的台式机或者笔记本性能更强大
Dialogue: 0,0:10:53.56,0:10:55.54,English,,0,0,0,,So they're actually pretty decent machines
Dialogue: 0,0:10:53.56,0:10:55.54,Chinese,,0,0,0,,所以他们实际上是相当不错的机器
Dialogue: 0,0:10:55.92,0:11:02.00,English,,0,0,0,,And actually we'll talk next time about why computers aren't a lot faster than they were five years ago
Dialogue: 0,0:10:55.92,0:11:02.00,Chinese,,0,0,0,,我们下次会谈到为什么实际上现在的计算机没有比五年前快得多
Dialogue: 0,0:11:02.00,0:11:04.10,English,,0,0,0,,That's actually an interesting technology thing
Dialogue: 0,0:11:02.00,0:11:04.10,Chinese,,0,0,0,,这实际上是一项有趣的技术
Dialogue: 0,0:11:05.18,0:11:12.22,English,,0,0,0,,So they are server class machines so they have multiple cores
Dialogue: 0,0:11:05.18,0:11:12.22,Chinese,,0,0,0,,鲨鱼机是服务器类机器，所以拥有多个 CPU 核
Dialogue: 0,0:11:12.80,0:11:23.54,English,,0,0,0,,And they have eight of them which is a lot you can buy ten core machines x86 machines on a single chip
Dialogue: 0,0:11:12.80,0:11:23.54,Chinese,,0,0,0,,他们有八个 CPU 核，这已经很多了，现在你可以购买在一个芯片上有十个核的 x86 机器
Dialogue: 0,0:11:23.60,0:11:25.14,English,,0,0,0,,But I don't think you can get more yet
Dialogue: 0,0:11:23.60,0:11:25.14,Chinese,,0,0,0,,但我觉得你应该买不到比 10 更多的了
Dialogue: 0,0:11:25.36,0:11:29.16,English,,0,0,0,,So these were fairly advanced machine of their day
Dialogue: 0,0:11:25.36,0:11:29.16,Chinese,,0,0,0,,所以这些都是当时相当先进的机器
Dialogue: 0,0:11:29.16,0:11:31.50,English,,0,0,0,,And they also have two-way hyper threading
Dialogue: 0,0:11:29.16,0:11:31.50,Chinese,,0,0,0,,而且他们也有双向超线程
Dialogue: 0,0:11:32.64,0:11:33.52,English,,0,0,0,,So in theory
Dialogue: 0,0:11:32.64,0:11:33.52,Chinese,,0,0,0,,所以在理论上
Dialogue: 0,0:11:36.96,0:11:40.34,English,,0,0,0,,You should be able to get sixteen independent threads running
Dialogue: 0,0:11:36.96,0:11:40.34,Chinese,,0,0,0,,你应该能够运行 16 个独立的线程
Dialogue: 0,0:11:40.62,0:11:44.72,English,,0,0,0,,Sort of 16 way parallelism potentially out of a program
Dialogue: 0,0:11:40.62,0:11:44.72,Chinese,,0,0,0,,或者说在一个程序上运行 16 个并行线程
Dialogue: 0,0:11:44.74,0:11:50.36,English,,0,0,0,,If you can keep everything working and keep bad things from happening
Dialogue: 0,0:11:44.74,0:11:50.36,Chinese,,0,0,0,,如果你可以让它们正常运行起来，不让 bug 出现
Dialogue: 0,0:11:55.18,0:12:01.94,English,,0,0,0,,So let's give a really trivial application one that should be very simple to make run in parallel
Dialogue: 0,0:11:55.18,0:12:01.94,Chinese,,0,0,0,,接下来我们来看一个能够并行运行的简单程序
Dialogue: 0,0:12:02.42,0:12:07.74,English,,0,0,0,,That says imaginary we want to sum up the numbers between 0 and n-1
Dialogue: 0,0:12:02.42,0:12:07.74,Chinese,,0,0,0,,假设我们要求 0 到 n-1 的数字和
Dialogue: 0,0:12:07.74,0:12:12.38,English,,0,0,0,,Which is by the way a really stupid thing to do because there's a very simple closed-form formula for it
Dialogue: 0,0:12:07.74,0:12:12.38,Chinese,,0,0,0,,这是一个非常愚蠢的事情，因为它有一个非常简单的公式可以计算答案
Dialogue: 0,0:12:13.28,0:12:15.58,English,,0,0,0,,Which is good in the sense it will let us check our work
Dialogue: 0,0:12:13.28,0:12:15.58,Chinese,,0,0,0,,这个公式可以用来帮我们检查正确性
Dialogue: 0,0:12:15.76,0:12:18.36,English,,0,0,0,,But it's a completely stupid application
Dialogue: 0,0:12:15.76,0:12:18.36,Chinese,,0,0,0,,虽然这是一个非常愚蠢的程序
Dialogue: 0,0:12:19.00,0:12:21.02,English,,0,0,0,,But it just shows you this idea
Dialogue: 0,0:12:19.00,0:12:21.02,Chinese,,0,0,0,,但是这里只是为了解释并行性的思想
Dialogue: 0,0:12:21.74,0:12:24.44,English,,0,0,0,,And so what we're just going to do is block off
Dialogue: 0,0:12:21.74,0:12:24.44,Chinese,,0,0,0,,所以我们现在要做的就是分块
Dialogue: 0,0:12:24.98,0:12:31.68,English,,0,0,0,,If we have n way parallelism we're just going to split a range of numbers n ways
Dialogue: 0,0:12:24.98,0:12:31.68,Chinese,,0,0,0,,如果我们有 n 个并行线程，我们需要将这组数分割成 n 份
Dialogue: 0,0:12:32.58,0:12:37.60,English,,0,0,0,,And just have a single threads sum up one nth of the numbers
Dialogue: 0,0:12:32.58,0:12:37.60,Chinese,,0,0,0,,只需要一个线程对 1 / n 的数求和
Dialogue: 0,0:12:38.20,0:12:43.50,English,,0,0,0,,And then they'll collectively sum together the result in some way or another
Dialogue: 0,0:12:38.20,0:12:43.50,Chinese,,0,0,0,,然后他们将以某种方式将结果加起来
Dialogue: 0,0:12:43.82,0:12:46.42,English,,0,0,0,,So this is about as easy a parallel program as you could imagine
Dialogue: 0,0:12:43.82,0:12:46.42,Chinese,,0,0,0,,所以这就是一个你可以想象的很简单的并行程序
Dialogue: 0,0:12:47.84,0:12:53.54,English,,0,0,0,,So let's do a 1 version which is said well gee understand how to use threads
Dialogue: 0,0:12:47.84,0:12:53.54,Chinese,,0,0,0,,我们可以写出该程序的版本 1  如果我们理解如何去使用线程
Dialogue: 0,0:12:54.20,0:12:58.90,English,,0,0,0,,Pthreads and  know about these things called semaphores or mutual exclusion
Dialogue: 0,0:12:54.20,0:12:58.90,Chinese,,0,0,0,,Pthreds ，然后了解信号量，互斥等概念
Dialogue: 0,0:12:59.42,0:13:04.58,English,,0,0,0,,So what I'll do is just all I'll have one place in memory
Dialogue: 0,0:12:59.42,0:13:04.58,Chinese,,0,0,0,,首先我们要做的是在内存中分配一个空间
Dialogue: 0,0:13:04.58,0:13:08.14,English,,0,0,0,,Where I'm collecting the sum over all n values
Dialogue: 0,0:13:04.58,0:13:08.14,Chinese,,0,0,0,,在那里储存这 N 个元素的和
Dialogue: 0,0:13:08.88,0:13:11.86,English,,0,0,0,,And for a thread to be able to add to that
Dialogue: 0,0:13:08.88,0:13:11.86,Chinese,,0,0,0,,对于每个线程来说，都可以增加这个值
Dialogue: 0,0:13:12.10,0:13:19.28,English,,0,0,0,,If it will lock it it will get a mutual exclusive access to it increment it and then unlock it
Dialogue: 0,0:13:12.10,0:13:19.28,Chinese,,0,0,0,,如果线程对此空间进行加锁，这个线程将获得互斥的访问权限去加它，并在合适的时候将其解锁
Dialogue: 0,0:13:19.40,0:13:24.66,English,,0,0,0,,And we'll just let all the threads go helter-skelter locking and unlocking this
Dialogue: 0,0:13:19.40,0:13:24.66,Chinese,,0,0,0,,我们会让安排所有的线程对于在此空间上的求和操作紧密得进行加锁和解锁
Dialogue: 0,0:13:25.72,0:13:27.52,English,,0,0,0,,So the code for that's pretty easy to write it
Dialogue: 0,0:13:25.72,0:13:27.52,Chinese,,0,0,0,,实现上述所说的代码很容易
Dialogue: 0,0:13:27.86,0:13:36.46,English,,0,0,0,,It's a here's the code of course all threaded code looks a lot messier than you think it should but
Dialogue: 0,0:13:27.86,0:13:36.46,Chinese,,0,0,0,,当然这里所有的线程代码看起来都比你想象的要麻烦得多
Dialogue: 0,0:13:37.12,0:13:39.32,English,,0,0,0,,In the end it's a fairly straightforward code
Dialogue: 0,0:13:37.12,0:13:39.32,Chinese,,0,0,0,,但它看上去仍是相当简单的代码
Dialogue: 0,0:13:40.16,0:13:41.32,English,,0,0,0,,So in particular
Dialogue: 0,0:13:40.16,0:13:41.32,Chinese,,0,0,0,,具体来说
Dialogue: 0,0:13:42.96,0:13:44.46,English,,0,0,0,,This is the thread routine is
Dialogue: 0,0:13:42.96,0:13:44.46,Chinese,,0,0,0,,这是线程例程
Dialogue: 0,0:13:46.12,0:13:55.02,English,,0,0,0,,Passing through this weird vargp structure that you do with threads
Dialogue: 0,0:13:46.12,0:13:55.02,Chinese,,0,0,0,,通过这个名字起的很奇怪的 vargp 结构体
Dialogue: 0,0:13:55.26,0:13:58.20,English,,0,0,0,,The way you pass arguments to a thread routine
Dialogue: 0,0:13:55.26,0:13:58.20,Chinese,,0,0,0,,把结构体当作参数传递给线程例程
Dialogue: 0,0:13:58.60,0:14:02.84,English,,0,0,0,,But basically it's figuring out where is the start and end range of the numbers
Dialogue: 0,0:13:58.60,0:14:02.84,Chinese,,0,0,0,,基本上这个函数的功能是：首先获取数字的开始和结束区域
Dialogue: 0,0:14:03.56,0:14:09.52,English,,0,0,0,,Then adding for all i between the start before the end
Dialogue: 0,0:14:03.56,0:14:09.52,Chinese,,0,0,0,,然后加在这个区间内所有的 i （到gsum）
Dialogue: 0,0:14:10.10,0:14:14.88,English,,0,0,0,,I'll lock that acquire a semaphore lock
Dialogue: 0,0:14:10.10,0:14:14.88,Chinese,,0,0,0,,在其中，我将获取一个叫 "信号量" 的锁
Dialogue: 0,0:14:15.64,0:14:19.08,English,,0,0,0,,I'll increment this global sum and then I'll release the lock
Dialogue: 0,0:14:15.64,0:14:19.08,Chinese,,0,0,0,,增加这个全局总和之后，释放这个锁
Dialogue: 0,0:14:20.66,0:14:23.56,English,,0,0,0,,Okay so pretty much the style of code that you've been working with
Dialogue: 0,0:14:20.66,0:14:23.56,Chinese,,0,0,0,,这是我们很熟悉的代码风格
Dialogue: 0,0:14:25.10,0:14:27.92,English,,0,0,0,,And what you find is actually this is really a bad idea
Dialogue: 0,0:14:25.10,0:14:27.92,Chinese,,0,0,0,,你会发现这其实是个坏主意
Dialogue: 0,0:14:28.92,0:14:30.40,English,,0,0,0,,So running as a single thread
Dialogue: 0,0:14:28.92,0:14:30.40,Chinese,,0,0,0,,如果是单线程运行
Dialogue: 0,0:14:31.22,0:14:33.04,English,,0,0,0,,It takes 51 seconds to do that
Dialogue: 0,0:14:31.22,0:14:33.04,Chinese,,0,0,0,,这个求和函数需要 51 秒来完成
Dialogue: 0,0:14:33.04,0:14:37.04,English,,0,0,0,,It would be by the way if you didn't lock and unlock because it's only one thread
Dialogue: 0,0:14:33.04,0:14:37.04,Chinese,,0,0,0,,顺便说一句，如果你没有使用加锁和解锁，因为它只是一个线程（无需锁操作）
Dialogue: 0,0:14:37.04,0:14:40.60,English,,0,0,0,,You'd blow this away it would take just a couple seconds so
Dialogue: 0,0:14:37.04,0:14:40.60,Chinese,,0,0,0,,你会惊讶地发现这仅需要几秒钟
Dialogue: 0,0:14:41.30,0:14:44.02,English,,0,0,0,,And then you see as you add more threads it actually gets worse
Dialogue: 0,0:14:41.30,0:14:44.02,Chinese,,0,0,0,,当添加了更多的线程时，你会发现时间会变得更慢
Dialogue: 0,0:14:44.80,0:14:47.60,English,,0,0,0,,And especially if you jump from one to two
Dialogue: 0,0:14:44.80,0:14:47.60,Chinese,,0,0,0,,特别是当从一个线程变成两个时
Dialogue: 0,0:14:48.12,0:14:51.32,English,,0,0,0,,You increase by a factor nine how much time  it takes
Dialogue: 0,0:14:48.12,0:14:51.32,Chinese,,0,0,0,,这会增加到大约 9 倍的时间
Dialogue: 0,0:14:52.78,0:14:58.04,English,,0,0,0,,And it always starts to get better as you get up into eight threads and then it gets worse again
Dialogue: 0,0:14:52.78,0:14:58.04,Chinese,,0,0,0,,当你增加到第八个线程时，耗时会少一点，但继续增加下去，耗时还是会越来越多
Dialogue: 0,0:14:59.04,0:15:06.28,English,,0,0,0,,So the reason is that locking unlocking is a very time-consuming task
Dialogue: 0,0:14:59.04,0:15:06.28,Chinese,,0,0,0,,这背后的原因是加锁、解锁是一项非常耗时的任务
Dialogue: 0,0:15:06.30,0:15:07.88,English,,0,0,0,,And basically you can think of...
Dialogue: 0,0:15:06.30,0:15:07.88,Chinese,,0,0,0,,简单地你可以这样设想 ......
Dialogue: 0,0:15:09.90,0:15:15.40,English,,0,0,0,,If you have that map of the multi-core processors with all their private caches in one shared cache
Dialogue: 0,0:15:09.90,0:15:15.40,Chinese,,0,0,0,,如果你有一个多核处理器，所有核的私有缓存都是一块共有的缓存区
Dialogue: 0,0:15:16.10,0:15:25.90,English,,0,0,0,,These threads are basically fighting with each other for control for that one memory address that they're incrementing
Dialogue: 0,0:15:16.10,0:15:25.90,Chinese,,0,0,0,,这些线程基本上都是为了争夺那个正在递增的内存地址的控制权而相互竞争
Dialogue: 0,0:15:26.48,0:15:31.14,English,,0,0,0,,And it has to grab the control away from one core to your the core
Dialogue: 0,0:15:26.48,0:15:31.14,Chinese,,0,0,0,,某个核一定要把控制权从一个核心抢到自己这里
Dialogue: 0,0:15:31.62,0:15:35.44,English,,0,0,0,,That's accessing it do the lock unlock
Dialogue: 0,0:15:31.62,0:15:35.44,Chinese,,0,0,0,,通过加锁与解锁的机制来访问
Dialogue: 0,0:15:35.98,0:15:39.60,English,,0,0,0,,And then it gets grabbed back for it so it's a miserable performance for cache
Dialogue: 0,0:15:35.98,0:15:39.60,Chinese,,0,0,0,,然后它又被抢回去，这对于缓存来说会造成很糟糕的性能损失
Dialogue: 0,0:15:40.24,0:15:42.80,English,,0,0,0,,Huge overhead for the semaphore activities
Dialogue: 0,0:15:40.24,0:15:42.80,Chinese,,0,0,0,,信号量这一类活动有巨大的性能开销
Dialogue: 0,0:15:43.36,0:15:45.42,English,,0,0,0,,And just really a bad thing all around
Dialogue: 0,0:15:43.36,0:15:45.42,Chinese,,0,0,0,,这是一件非常糟糕的事
Dialogue: 0,0:15:45.44,0:15:51.31,English,,0,0,0,,And so lesson one is semaphores or mutexes are very expensive
Dialogue: 0,0:15:45.44,0:15:51.31,Chinese,,0,0,0,,所以这节课第一个我们必须了解的东西就是信号量或者互斥量是非常昂贵的
Dialogue: 0,0:15:52.06,0:15:54.90,English,,0,0,0,,And if you're trying to do low level parallelism
Dialogue: 0,0:15:52.06,0:15:54.90,Chinese,,0,0,0,,如果你正在尝试做一些低级的并发处理
Dialogue: 0,0:15:54.90,0:15:58.90,English,,0,0,0,,You don't want fine-grained locking at that level otherwise
Dialogue: 0,0:15:54.90,0:15:58.90,Chinese,,0,0,0,,你是不希望做一些粒度很低的加锁和解锁操作的
Dialogue: 0,0:15:59.02,0:16:00.32,English,,0,0,0,,You're just completely sunk
Dialogue: 0,0:15:59.02,0:16:00.32,Chinese,,0,0,0,,不然你的程序很慢
Dialogue: 0,0:16:00.50,0:16:02.92,English,,0,0,0,,And so that's not the way to do it
Dialogue: 0,0:16:00.50,0:16:02.92,Chinese,,0,0,0,,这不是并发的正确使用方式
Dialogue: 0,0:16:03.34,0:16:08.78,English,,0,0,0,,I won't go into it but there's quite a bit of literature about what they call lock free synchronization
Dialogue: 0,0:16:03.34,0:16:08.78,Chinese,,0,0,0,,我不会详细展开，但有很多关于「无锁同步」的文献
Dialogue: 0,0:16:09.24,0:16:12.20,English,,0,0,0,,Which is a way to avoid semaphores but get the effect
Dialogue: 0,0:16:09.24,0:16:12.20,Chinese,,0,0,0,,这是一种避免使用信号量但可以获得类似锁的效果
Dialogue: 0,0:16:12.78,0:16:15.00,English,,0,0,0,,And they wouldn't work in this context either those
Dialogue: 0,0:16:12.78,0:16:15.00,Chinese,,0,0,0,,那种方法也不会在我们这种情况下使用
Dialogue: 0,0:16:15.54,0:16:17.36,English,,0,0,0,,Just if you've ever heard that term
Dialogue: 0,0:16:15.54,0:16:17.36,Chinese,,0,0,0,,如果你们听说过那个词
Dialogue: 0,0:16:17.74,0:16:19.54,English,,0,0,0,,Those are generally designed for
Dialogue: 0,0:16:17.74,0:16:19.54,Chinese,,0,0,0,,这些通常是为
Dialogue: 0,0:16:20.30,0:16:25.80,English,,0,0,0,,Examples where you expect relatively little contention between the threads
Dialogue: 0,0:16:20.30,0:16:25.80,Chinese,,0,0,0,,那些线程间存在很少争抢行为的例子设计
Dialogue: 0,0:16:25.80,0:16:30.30,English,,0,0,0,,And so you try and be optimistic and then roll back if something bad happens
Dialogue: 0,0:16:25.80,0:16:30.30,Chinese,,0,0,0,,所以你假设不会产生冲突，然后如果发生了不好的事情就回滚到起点
Dialogue: 0,0:16:31.90,0:16:33.52,English,,0,0,0,,This is a case where nope
Dialogue: 0,0:16:31.90,0:16:33.52,Chinese,,0,0,0,,我们这个案例是
Dialogue: 0,0:16:33.78,0:16:38.24,English,,0,0,0,,All those threads are going to be pounding that one memory location and they're really fighting for it
Dialogue: 0,0:16:33.78,0:16:38.24,Chinese,,0,0,0,,所有这些线程都将使用到相同的一个内存位置，他们真的都在争夺它
Dialogue: 0,0:16:38.30,0:16:41.10,English,,0,0,0,,And so there is no good solution to that problem
Dialogue: 0,0:16:38.30,0:16:41.10,Chinese,,0,0,0,,所以这个问题没有很好的解决方案
Dialogue: 0,0:16:43.70,0:16:47.48,English,,0,0,0,,The other thing I'll point out is this jump here shows you that
Dialogue: 0,0:16:43.70,0:16:47.48,Chinese,,0,0,0,,我要指出的另一件事就是：从 8 线程变成 16 线程告诉了我们
Dialogue: 0,0:16:48.20,0:16:50.76,English,,0,0,0,,Hyper threading isn't really helping us here
Dialogue: 0,0:16:48.20,0:16:50.76,Chinese,,0,0,0,,超线程并不能真正帮助我们
Dialogue: 0,0:16:52.42,0:16:55.88,English,,0,0,0,,Going from the fact that we slowed down from 8 to 16
Dialogue: 0,0:16:52.42,0:16:55.88,Chinese,,0,0,0,, 8 线程变成 16 线程，速度更慢
Dialogue: 0,0:16:55.88,0:16:59.16,English,,0,0,0,,Means we can't really make use of 16 threads in this application
Dialogue: 0,0:16:55.88,0:16:59.16,Chinese,,0,0,0,,意味着我们无法在此应用程序中真正利用好 16 个线程
Dialogue: 0,0:16:59.68,0:17:01.60,English,,0,0,0,,8 threads are better than 4
Dialogue: 0,0:16:59.68,0:17:01.60,Chinese,,0,0,0,, 8 个线程比 4 个性能好
Dialogue: 0,0:17:02.06,0:17:06.74,English,,0,0,0,,But obviously all that's kind of a waste of time because this is just really a bad idea all around
Dialogue: 0,0:17:02.06,0:17:06.74,Chinese,,0,0,0,,但显然所有这些都浪费时间，因为线程代码这样设计本身就是个很糟糕的主意
Dialogue: 0,0:17:08.38,0:17:08.72,English,,0,0,0,,So
Dialogue: 0,0:17:08.38,0:17:08.72,Chinese,,0,0,0,,所以
Dialogue: 0,0:17:09.56,0:17:11.14,English,,0,0,0,,Let's do something different
Dialogue: 0,0:17:09.56,0:17:11.14,Chinese,,0,0,0,,让我们来尝试另一种方法
Dialogue: 0,0:17:11.18,0:17:17.06,English,,0,0,0,,Let's have each of them accumulate their own sum for their own sub range
Dialogue: 0,0:17:11.18,0:17:17.06,Chinese,,0,0,0,,让每个线程在它们的子范围内累加自己的和
Dialogue: 0,0:17:18.60,0:17:22.16,English,,0,0,0,,And we'll give up so we'll have an array of accumulators
Dialogue: 0,0:17:18.60,0:17:22.16,Chinese,,0,0,0,,所以我们将一个累加器数组
Dialogue: 0,0:17:23.12,0:17:29.72,English,,0,0,0,,Where the each thread is incrementing only a one element of this array
Dialogue: 0,0:17:23.12,0:17:29.72,Chinese,,0,0,0,,每个线程只增加此数组的一个元素
Dialogue: 0,0:17:30.56,0:17:33.38,English,,0,0,0,,So they're not fighting with each other directly for it
Dialogue: 0,0:17:30.56,0:17:33.38,Chinese,,0,0,0,,所以他们不是直接在相互争斗数组的使用权
Dialogue: 0,0:17:33.58,0:17:38.96,English,,0,0,0,,But they are fighting for if you think about it for the same cache line
Dialogue: 0,0:17:33.58,0:17:38.96,Chinese,,0,0,0,,但是它们仍然在争夺这个缓存
Dialogue: 0,0:17:39.84,0:17:43.92,English,,0,0,0,,Because an array is typically stored and so it's not totally nice
Dialogue: 0,0:17:39.84,0:17:43.92,Chinese,,0,0,0,,因为数组通常是（一块）存储的，所有它不是很好
Dialogue: 0,0:17:45.70,0:17:48.68,English,,0,0,0,,Ah but this it gives you a pointer to this idea
Dialogue: 0,0:17:45.70,0:17:48.68,Chinese,,0,0,0,,但这个例子提供了我们一个思路
Dialogue: 0,0:17:48.80,0:17:52.14,English,,0,0,0,,If we could sort of move into a private state
Dialogue: 0,0:17:48.80,0:17:52.14,Chinese,,0,0,0,,如果我们可以进入某种私有状态
Dialogue: 0,0:17:52.88,0:17:55.86,English,,0,0,0,,The stuff that we're making the most direct access to
Dialogue: 0,0:17:52.88,0:17:55.86,Chinese,,0,0,0,,我们能够直接访问的东西
Dialogue: 0,0:17:56.68,0:17:58.40,English,,0,0,0,,Then we'll get better performance
Dialogue: 0,0:17:56.68,0:17:58.40,Chinese,,0,0,0,,我们会获得更好的性能
Dialogue: 0,0:17:59.68,0:18:01.44,English,,0,0,0,,So this is the thread routine
Dialogue: 0,0:17:59.68,0:18:01.44,Chinese,,0,0,0,,所以这是我们的线程例程
Dialogue: 0,0:18:01.96,0:18:05.12,English,,0,0,0,,And that the point is that there's some global array called psum
Dialogue: 0,0:18:01.96,0:18:05.12,Chinese,,0,0,0,,该程序的关键是有叫做 psum 的全局数组
Dialogue: 0,0:18:05.12,0:18:10.80,English,,0,0,0,,But it's only incrementing the part of it that sort of assigned to this particular thread
Dialogue: 0,0:18:05.12,0:18:10.80,Chinese,,0,0,0,,它只增加分配给某一特定线程的数组元素
Dialogue: 0,0:18:12.92,0:18:15.44,English,,0,0,0,,And here you do see a performance improvement right
Dialogue: 0,0:18:12.92,0:18:15.44,Chinese,,0,0,0,,在这里，你确实看到了性能提升
Dialogue: 0,0:18:15.56,0:18:19.78,English,,0,0,0,,So one thread takes 5 seconds remember before it was 58
Dialogue: 0,0:18:15.56,0:18:19.78,Chinese,,0,0,0,,现在一个线程需要 5 秒而不是之前的 58 秒
Dialogue: 0,0:18:19.92,0:18:25.16,English,,0,0,0,,So that shows you just the advantage of the cost of semaphores
Dialogue: 0,0:18:19.92,0:18:25.16,Chinese,,0,0,0,,这样就向你展示了信号量成本到底有多大
Dialogue: 0,0:18:25.66,0:18:27.14,English,,0,0,0,,Right there is a factor of 10
Dialogue: 0,0:18:25.66,0:18:27.14,Chinese,,0,0,0,,对，有 10 倍
Dialogue: 0,0:18:27.74,0:18:33.12,English,,0,0,0,,And you see you are actually getting an improvement all across the line including up to 16 threads
Dialogue: 0,0:18:27.74,0:18:33.12,Chinese,,0,0,0,,观察整个线条，你会发现这条线上的所有点都较前一点有改善，包括 16 线程的情况
Dialogue: 0,0:18:33.14,0:18:34.50,English,,0,0,0,,You're still getting an improvement
Dialogue: 0,0:18:33.14,0:18:34.50,Chinese,,0,0,0,,在这之后，仍然会获得改进
Dialogue: 0,0:18:35.02,0:18:38.14,English,,0,0,0,,It would flatten out should have just shown the number for 32
Dialogue: 0,0:18:35.02,0:18:38.14,Chinese,,0,0,0,,这里会变扁平（如果我展示 32 线程的情况）
Dialogue: 0,0:18:38.14,0:18:40.02,English,,0,0,0,,But it would flatten out at this point
Dialogue: 0,0:18:38.14,0:18:40.02,Chinese,,0,0,0,,线条会在之后变得扁平
Dialogue: 0,0:18:40.56,0:18:43.78,English,,0,0,0,,But it actually is getting some advantage out of hyper-threading as well
Dialogue: 0,0:18:40.56,0:18:43.78,Chinese,,0,0,0,,但它实际上也从超线程中获得了一些增速
Dialogue: 0,0:18:45.34,0:18:48.14,English,,0,0,0,,So that's good it's not an amazing speed up
Dialogue: 0,0:18:45.34,0:18:48.14,Chinese,,0,0,0,,这很好，但这也不是一个惊人的加速
Dialogue: 0,0:18:48.46,0:18:57.48,English,,0,0,0,,So you can think of what they call the speed up is the performance of it running on a single core versus the performance on n cores
Dialogue: 0,0:18:48.46,0:18:57.48,Chinese,,0,0,0,,所以你可以想到他们所谓的加速是它在单核上运行的性能与 n 核上的性能相比
Dialogue: 0,0:18:57.48,0:19:00.30,English,,0,0,0,,And in the ideal case it goes n times faster
Dialogue: 0,0:18:57.48,0:19:00.30,Chinese,,0,0,0,,在理想情况下，它的速度将变快 n 倍
Dialogue: 0,0:19:00.94,0:19:02.28,English,,0,0,0,,And we're not quite hitting that
Dialogue: 0,0:19:00.94,0:19:02.28,Chinese,,0,0,0,,我们并没有达到那种性能
Dialogue: 0,0:19:05.90,0:19:12.04,English,,0,0,0,,Well but here's if you've already learned that it's generally bad to be accumulating into a memory
Dialogue: 0,0:19:05.90,0:19:12.04,Chinese,,0,0,0,,但你大概也已经知道了，直接在内存中进行累加是不好的（会比寄存器慢）
Dialogue: 0,0:19:12.58,0:19:15.50,English,,0,0,0,,And so why not do the thing we learned before
Dialogue: 0,0:19:12.58,0:19:15.50,Chinese,,0,0,0,,那么为什么试一下我们之前学到的东西呢
Dialogue: 0,0:19:15.90,0:19:20.50,English,,0,0,0,,Which is you accumulate in a register and you only update the memory when you're done with that
Dialogue: 0,0:19:15.90,0:19:20.50,Chinese,,0,0,0,,可以在寄存器内进行累加，再将累加好的结果更新在内存中
Dialogue: 0,0:19:21.30,0:19:24.76,English,,0,0,0,,So let's just do that and I'll call that the local version
Dialogue: 0,0:19:21.30,0:19:24.76,Chinese,,0,0,0,,让我们这样做一下，我把这个例子叫做本地版本
Dialogue: 0,0:19:25.20,0:19:28.60,English,,0,0,0,,I'll just increment a sum which is a local variable
Dialogue: 0,0:19:25.20,0:19:28.60,Chinese,,0,0,0,,我将增加一个本地变量 sum
Dialogue: 0,0:19:29.06,0:19:30.46,English,,0,0,0,,And only when I'm done
Dialogue: 0,0:19:29.06,0:19:30.46,Chinese,,0,0,0,,只有当我完成了
Dialogue: 0,0:19:31.24,0:19:35.30,English,,0,0,0,,Then I'll store it in the global array
Dialogue: 0,0:19:31.24,0:19:35.30,Chinese,,0,0,0,,我把它它存储在全局数组中
Dialogue: 0,0:19:37.14,0:19:40.52,English,,0,0,0,,Okay so it's functionally equivalent to the one we just showed
Dialogue: 0,0:19:37.14,0:19:40.52,Chinese,,0,0,0,,好的，它在功能上等同于我们刚刚展示的那个例子
Dialogue: 0,0:19:40.52,0:19:46.18,English,,0,0,0,,We're just moving instead of accumulating in a global array we're accumulating in a register
Dialogue: 0,0:19:40.52,0:19:46.18,Chinese,,0,0,0,,我们仅仅把现在寄存器中累加并且移动到全局数组中，而不是在全局数组中累加
Dialogue: 0,0:19:47.30,0:19:49.92,English,,0,0,0,,And here you see a pretty big performance improvement
Dialogue: 0,0:19:47.30,0:19:49.92,Chinese,,0,0,0,,这样，你可以看到我们又获得了相当大的性能提升
Dialogue: 0,0:19:51.18,0:20:00.04,English,,0,0,0,,So blue is what we showed with the global array,red or orange is what's this local variable
Dialogue: 0,0:19:51.18,0:20:00.04,Chinese,,0,0,0,,所以蓝色是我们用全局数组的，红色或橙色是局部变量
Dialogue: 0,0:20:00.76,0:20:04.56,English,,0,0,0,,And so you see it's actually interesting we're getting a performance improvement
Dialogue: 0,0:20:00.76,0:20:04.56,Chinese,,0,0,0,,你会看到我们得到了很有趣的性能提升
Dialogue: 0,0:20:05.38,0:20:11.12,English,,0,0,0,,As well although it bottoms out at eight
Dialogue: 0,0:20:05.38,0:20:11.12,Chinese,,0,0,0,,它在 8 线程达到最低点
Dialogue: 0,0:20:11.28,0:20:13.89,English,,0,0,0,,And it actually gets worse when you go to sixteen
Dialogue: 0,0:20:11.28,0:20:13.89,Chinese,,0,0,0,,在 16 线程时，它实际上会变得更糟
Dialogue: 0,0:20:14.44,0:20:17.24,English,,0,0,0,,And this is showing that hyper-threading isn't really helping here
Dialogue: 0,0:20:14.44,0:20:17.24,Chinese,,0,0,0,,这表明超线程在这方面并没有真正帮助
Dialogue: 0,0:20:17.24,0:20:21.98,English,,0,0,0,,Because basically the single thread is just accumulating
Dialogue: 0,0:20:17.24,0:20:21.98,Chinese,,0,0,0,,因为基本上，单线程只是在累加
Dialogue: 0,0:20:22.68,0:20:27.22,English,,0,0,0,,As fast as it can and adding to a register
Dialogue: 0,0:20:22.68,0:20:27.22,Chinese,,0,0,0,,尽可能快地把数加到寄存器上
Dialogue: 0,0:20:27.64,0:20:32.54,English,,0,0,0,,And so it's making pretty good use of what functional units it uses and putting multiple threads
Dialogue: 0,0:20:27.64,0:20:32.54,Chinese,,0,0,0,,因此，它正在很好地利用它使用的功能单元并放置多个线程
Dialogue: 0,0:20:33.02,0:20:34.50,English,,0,0,0,,Sharing it isn't really helping
Dialogue: 0,0:20:33.02,0:20:34.50,Chinese,,0,0,0,,分享它并没有真正帮助
Dialogue: 0,0:20:34.96,0:20:39.30,English,,0,0,0,,At least not on the shark machines
Dialogue: 0,0:20:34.96,0:20:39.30,Chinese,,0,0,0,,至少不在鲨鱼机上
Dialogue: 0,0:20:39.48,0:20:42.24,English,,0,0,0,,This actually might be different on different machines
Dialogue: 0,0:20:39.48,0:20:42.24,Chinese,,0,0,0,,这实际上可能在不同的机器上有所不同
Dialogue: 0,0:20:43.48,0:20:49.34,English,,0,0,0,,And actually if you recall from the performance optimization we found that if you're just doing a bunch of additions
Dialogue: 0,0:20:43.48,0:20:49.34,Chinese,,0,0,0,,实际上，如果你从性能优化中回忆起来，我们发现如果你只是做了很多补充
Dialogue: 0,0:20:49.96,0:20:54.36,English,,0,0,0,,You can make use as associativity and get more accumulation in parallel
Dialogue: 0,0:20:49.96,0:20:54.36,Chinese,,0,0,0,,你可以将其用作关联性并获得更多并行累积
Dialogue: 0,0:20:54.86,0:20:59.66,English,,0,0,0,,So you could actually speed up this program just the single threaded version of this program pretty well
Dialogue: 0,0:20:54.86,0:20:59.66,Chinese,,0,0,0,,所以你实际上可以加速这个程序只是这个程序的单线程版本
Dialogue: 0,0:21:00.24,0:21:04.66,English,,0,0,0,,But anyways it shows it okay this is starting to look like
Dialogue: 0,0:21:00.24,0:21:04.66,Chinese,,0,0,0,,但无论如何它已经很不错了，它看起来
Dialogue: 0,0:21:05.14,0:21:09.76,English,,0,0,0,,Your a your single threaded performance is pretty good and b
Dialogue: 0,0:21:05.14,0:21:09.76,Chinese,,0,0,0,,a 你的单线程性能非常好
Dialogue: 0,0:21:10.08,0:21:13.44,English,,0,0,0,,You're getting some useful speed-up out of parallelism
Dialogue: 0,0:21:10.08,0:21:13.44,Chinese,,0,0,0,,b 你可以从并行性中获得一些有用的加速
Dialogue: 0,0:21:14.48,0:21:19.36,English,,0,0,0,,But as said this is like the easiest example in the world to parallelize so if you can't do it here
Dialogue: 0,0:21:14.48,0:21:19.36,Chinese,,0,0,0,,但正如所说的，这就像世界上最简单的并行化示例，如果你不能在这里做到这一点
Dialogue: 0,0:21:19.90,0:21:24.52,English,,0,0,0,,Then life is pretty hopeless as far as multi-threading
Dialogue: 0,0:21:19.90,0:21:24.52,Chinese,,0,0,0,,然后就多线程而言，生活会变得无比绝望
Dialogue: 0,0:21:25.80,0:21:29.70,English,,0,0,0,,So let's talk about as mentioned this idea of speed-up
Dialogue: 0,0:21:25.80,0:21:29.70,Chinese,,0,0,0,,所以让我们谈谈关于加速这个想法
Dialogue: 0,0:21:30.70,0:21:35.14,English,,0,0,0,,So speed-up is just defined to be the time for a single-threaded program
Dialogue: 0,0:21:30.70,0:21:35.14,Chinese,,0,0,0,,因此，「加速比」定义为单线程程序的时间
Dialogue: 0,0:21:35.82,0:21:40.86,English,,0,0,0,,Divided by the time for pthreads running
Dialogue: 0,0:21:35.82,0:21:40.86,Chinese,,0,0,0,,除以多线程运行的时间
Dialogue: 0,0:21:41.47,0:21:45.66,English,,0,0,0,,Or actually will use it p cores instead of pthreads,question
Dialogue: 0,0:21:41.47,0:21:45.66,Chinese,,0,0,0,,或实际上可以叫它 p 核而不是 pthreads ，问题？
Dialogue: 0,0:21:45.78,0:21:51.64,English,,0,0,0,,[student speaking]
Dialogue: 0,0:21:45.78,0:21:51.64,Chinese,,0,0,0,,[同学提问]
Dialogue: 0,0:21:51.64,0:21:57.72,English,,0,0,0,,Yes generally you know the scheduler has some kind of load balancing built into it
Dialogue: 0,0:21:51.64,0:21:57.72,Chinese,,0,0,0,,是的，通常调度程序有一些内置的负载均衡设置
Dialogue: 0,0:21:58.54,0:22:05.14,English,,0,0,0,,And it will tend to especially in a case like this where the threads are sort of grabbing and running
Dialogue: 0,0:21:58.54,0:22:05.14,Chinese,,0,0,0,,特别是在这样的情况下，线程会抢占式运行
Dialogue: 0,0:22:05.72,0:22:10.96,English,,0,0,0,,Making...They will generally get spread across the cores
Dialogue: 0,0:22:05.72,0:22:10.96,Chinese,,0,0,0,,通常它们会利用所有核心
Dialogue: 0,0:22:11.92,0:22:14.60,English,,0,0,0,,So that's a pretty...the linux scheduler is pretty good at
Dialogue: 0,0:22:11.92,0:22:14.60,Chinese,,0,0,0,,Linux 调度程序非常擅长（线程调度）
Dialogue: 0,0:22:15.24,0:22:19.32,English,,0,0,0,,That when you have more threads than there are cores
Dialogue: 0,0:22:15.24,0:22:19.32,Chinese,,0,0,0,,当你的线程数大于核心数
Dialogue: 0,0:22:19.98,0:22:27.56,English,,0,0,0,,Then it basically starts scheduling them in some cyclic order
Dialogue: 0,0:22:19.98,0:22:27.56,Chinese,,0,0,0,,然后它基本上开始以某种循环顺序调度它们
Dialogue: 0,0:22:27.58,0:22:29.84,English,,0,0,0,,And you won't...you'll...
Dialogue: 0,0:22:27.58,0:22:29.84,Chinese,,0,0,0,,你不会 ...... 你会 ......
Dialogue: 0,0:22:30.68,0:22:33.86,English,,0,0,0,,At best you will not get any advantage
Dialogue: 0,0:22:30.68,0:22:33.86,Chinese,,0,0,0,,最好的情况，你不会得到任何好处
Dialogue: 0,0:22:34.00,0:22:39.00,English,,0,0,0,,And in a worst case you actually start slowing down from having more threads than are
Dialogue: 0,0:22:34.00,0:22:39.00,Chinese,,0,0,0,,实际上最坏的情况是你开始因为线程数的增加而放慢速度
Dialogue: 0,0:22:39.94,0:22:40.80,English,,0,0,0,,Good question
Dialogue: 0,0:22:39.94,0:22:40.80,Chinese,,0,0,0,,好问题
Dialogue: 0,0:22:41.24,0:22:43.00,English,,0,0,0,,So there's really two versions of speedup
Dialogue: 0,0:22:41.24,0:22:43.00,Chinese,,0,0,0,,所以有两种版本的「加速比」
Dialogue: 0,0:22:43.02,0:22:48.06,English,,0,0,0,,One is if I take my multi-threaded routine and run it with one thread
Dialogue: 0,0:22:43.02,0:22:48.06,Chinese,,0,0,0,,一个是我采用多线程例程并用一个线程运行它
Dialogue: 0,0:22:48.72,0:22:51.54,English,,0,0,0,,And then I might do it with p threads or cores
Dialogue: 0,0:22:48.72,0:22:51.54,Chinese,,0,0,0,,然后比上 P 个线程或者核的运行时间
Dialogue: 0,0:22:52.16,0:22:53.18,English,,0,0,0,,I can get a speedup
Dialogue: 0,0:22:52.16,0:22:53.18,Chinese,,0,0,0,,我得到一个（相对）加速比
Dialogue: 0,0:22:53.18,0:22:54.84,English,,0,0,0,,But actually the truer thing is
Dialogue: 0,0:22:53.18,0:22:54.84,Chinese,,0,0,0,,但更准确的做法是
Dialogue: 0,0:22:54.84,0:23:02.12,English,,0,0,0,,If I take the best-known sequential algorithm for performing this task with the best implementation of that
Dialogue: 0,0:22:54.84,0:23:02.12,Chinese,,0,0,0,,采用最好的顺序算法用最好的实践来执行此任务
Dialogue: 0,0:23:02.74,0:23:04.82,English,,0,0,0,,And then compare it against my parallel one
Dialogue: 0,0:23:02.74,0:23:04.82,Chinese,,0,0,0,,然后将它与我的并行性能比较
Dialogue: 0,0:23:04.84,0:23:10.22,English,,0,0,0,,And so that's referred to as absolute speedup which is the best measures
Dialogue: 0,0:23:04.84,0:23:10.22,Chinese,,0,0,0,,所以这被称为「绝对加速比」 ，也是更真实的指标
Dialogue: 0,0:23:10.22,0:23:17.14,English,,0,0,0,, You know you give both sides the opportunity to do the best implementation that they can  And then you compare it
Dialogue: 0,0:23:10.22,0:23:17.14,Chinese,,0,0,0,,因为让双方都有机会做到它们可以最好的实施，之后你比较它们
Dialogue: 0,0:23:18.08,0:23:24.12,English,,0,0,0,,And then what's referred to as the efficiency is how close to the speedup get to the ideal speedup？
Dialogue: 0,0:23:18.08,0:23:24.12,Chinese,,0,0,0,,另一个相关的指标是「效率（efficiency）」指的是靠近理想加速比的程度
Dialogue: 0,0:23:24.12,0:23:28.18,English,,0,0,0,,Which is if I'm running on p cores I should be p times faster
Dialogue: 0,0:23:24.12,0:23:28.18,Chinese,,0,0,0,,如果我在 P 核上运行，理想的加速比应该是快 P 倍
Dialogue: 0,0:23:28.88,0:23:30.14,English,,0,0,0,,And you'll see that we're
Dialogue: 0,0:23:28.88,0:23:30.14,Chinese,,0,0,0,,你会看到我们是......
Dialogue: 0,0:23:30.78,0:23:35.44,English,,0,0,0,,You know the question of hyper-threading versus not we're sort of here we're saying no you don't
Dialogue: 0,0:23:30.78,0:23:35.44,Chinese,,0,0,0,,你知道考虑到超线程与不考虑的问题，我们这里不应该采用超线程
Dialogue: 0,0:23:36.38,0:23:39.42,English,,0,0,0,,We're not (trying to) gaining from hyper-threading
Dialogue: 0,0:23:36.38,0:23:39.42,Chinese,,0,0,0,,我们不会从超线程中获益
Dialogue: 0,0:23:40.08,0:23:46.54,English,,0,0,0,,You can play this game various ways and you can argue back and forth Whether hyper-threading should count
Dialogue: 0,0:23:40.08,0:23:46.54,Chinese,,0,0,0,,你可以通过多种方式玩此游戏，还可以反复验证是否应该考虑超线程
Dialogue: 0,0:23:46.64,0:23:53.02,English,,0,0,0,,So for p is p the total number of possible threads or the total number of cores
Dialogue: 0,0:23:46.64,0:23:53.02,Chinese,,0,0,0,,因此，p 是线程总数或核心总数
Dialogue: 0,0:23:53.14,0:23:58.40,English,,0,0,0,,It's really a something to argue back and forth about
Dialogue: 0,0:23:53.14,0:23:58.40,Chinese,,0,0,0,,这真的是一种反复验证的东西
Dialogue: 0,0:24:00.24,0:24:08.74,English,,0,0,0,,So the point is the efficiency though is is measured as how much do we do relative to ideal
Dialogue: 0,0:24:00.24,0:24:08.74,Chinese,,0,0,0,,所以关键在于「效率」是衡量我们相对于理想的程度做到了怎样
Dialogue: 0,0:24:08.82,0:24:13.16,English,,0,0,0,,And so this is what you get for this code the local version of psum
Dialogue: 0,0:24:08.82,0:24:13.16,Chinese,,0,0,0,,这就是我们拿到的 psum 本地版本的并行性能表
Dialogue: 0,0:24:13.86,0:24:19.22,English,,0,0,0,,You'll see that the efficiency numbers are somewhere in the high somebody range
Dialogue: 0,0:24:13.86,0:24:19.22,Chinese,,0,0,0,,你会发现「效率」在一定的范围内（0～100%）
Dialogue: 0,0:24:21.08,0:24:22.26,English,,0,0,0,,Which is good but not great
Dialogue: 0,0:24:21.08,0:24:22.26,Chinese,,0,0,0,,这很好，但不完美
Dialogue: 0,0:24:22.98,0:24:26.32,English,,0,0,0,,It's pretty good actually if you can get 75 percent efficiency
Dialogue: 0,0:24:22.98,0:24:26.32,Chinese,,0,0,0,,如果你的效率是 75％，那真的很不错
Dialogue: 0,0:24:26.80,0:24:31.62,English,,0,0,0,,You're doing better than most but again that's because this should have been the world's easiest program to parallelize
Dialogue: 0,0:24:26.80,0:24:31.62,Chinese,,0,0,0,,这样的话你做得比大多数并行程序好，但这是因为这本就是世界上最简单的并行化程序
Dialogue: 0,0:24:33.94,0:24:40.84,English,,0,0,0,,So the best speedup we're getting is a factor of six out of 8 cores
Dialogue: 0,0:24:33.94,0:24:40.84,Chinese,,0,0,0,,我们在 8 核的情况下得到最好的加速比，值超过了 6
Dialogue: 0,0:24:41.32,0:24:45.58,English,,0,0,0,,Again that's pretty good but this really should be something you can do well
Dialogue: 0,0:24:41.32,0:24:45.58,Chinese,,0,0,0,,再次强调这是非常好的，但对于这个程序，你应该做到这么好
Dialogue: 0,0:24:47.74,0:24:52.96,English,,0,0,0,,So that just gives you a flavor of what parallel computing can be
Dialogue: 0,0:24:47.74,0:24:52.96,Chinese,,0,0,0,,这个例子只是让你了解并行计算的特点
Dialogue: 0,0:24:54.08,0:24:59.44,English,,0,0,0,,So now it's sort of back off and talk some general principles just like the speed-up
Dialogue: 0,0:24:54.08,0:24:59.44,Chinese,,0,0,0,,现在回过头来谈论一些一般原则，比如加速比
Dialogue: 0,0:25:00.80,0:25:04.80,English,,0,0,0,,There's a fella named Gene Amdahl who coincidentally just died a few weeks ago
Dialogue: 0,0:25:00.80,0:25:04.80,Chinese,,0,0,0,,有一个名叫 Gene Amdahl 的工程师几个星期前刚刚去世（2015年）
Dialogue: 0,0:25:04.84,0:25:06.28,English,,0,0,0,,He might have seen it in the news
Dialogue: 0,0:25:04.84,0:25:06.28,Chinese,,0,0,0,,可能在新闻中看到他
Dialogue: 0,0:25:06.72,0:25:11.42,English,,0,0,0,,He was one of the original pioneers at IBM in their mainframe computers
Dialogue: 0,0:25:06.72,0:25:11.42,Chinese,,0,0,0,,他是 IBM 大型计算机领域最初的先驱之一
Dialogue: 0,0:25:12.36,0:25:16.48,English,,0,0,0,,Then then at some point he in the 60s
Dialogue: 0,0:25:12.36,0:25:16.48,Chinese,,0,0,0,,他在 60 年代
Dialogue: 0,0:25:16.88,0:25:19.48,English,,0,0,0,,He started his own company called Amdahl Computers
Dialogue: 0,0:25:16.88,0:25:19.48,Chinese,,0,0,0,,他创办了自己的公司 「阿姆达尔公司」
Dialogue: 0,0:25:19.48,0:25:27.36,English,,0,0,0,,And they were like they were the cool company in mainframe computers if that could ever be considered cool right
Dialogue: 0,0:25:19.48,0:25:27.36,Chinese,,0,0,0,,他们是大型计算机领域很酷的一家公司
Dialogue: 0,0:25:28.28,0:25:33.04,English,,0,0,0,,And he built a competitor's to IBM that absolutely drove them crazy
Dialogue: 0,0:25:28.28,0:25:33.04,Chinese,,0,0,0,,他创建了 IBM 的一个强大竞争对手，并且让他们抓狂
Dialogue: 0,0:25:33.06,0:25:38.79,English,,0,0,0,,Because they had a virtual monopoly they actually were subject to antitrust suit
Dialogue: 0,0:25:33.06,0:25:38.79,Chinese,,0,0,0,,因为他们实际上是垄断的，所以他们受到了反垄断诉讼
Dialogue: 0,0:25:38.88,0:25:45.80,English,,0,0,0,,So Amdahl was a sort of the the rebel who broke away from the mother company and started a competitor
Dialogue: 0,0:25:38.88,0:25:45.80,Chinese,,0,0,0,,所以阿姆达尔是一个叛逆者，他脱离了母公司并成为母公司的竞争对手
Dialogue: 0,0:25:47.74,0:25:51.44,English,,0,0,0,,And he made this very simple observation that's called Amdahl law
Dialogue: 0,0:25:47.74,0:25:51.44,Chinese,,0,0,0,,他提出一个非常简单的量化标准，叫做「阿姆达尔定律」
Dialogue: 0,0:25:51.44,0:25:59.20,English,,0,0,0,,Which is...Basically junior high level algebra to think of this but it's actually a fairly perceptive point
Dialogue: 0,0:25:51.44,0:25:59.20,Chinese,,0,0,0,,基于初级高级代数，但实际上这是一个相当有洞察力的观点
Dialogue: 0,0:26:00.02,0:26:03.74,English,,0,0,0,,About what's the possible benefit of speeding up something
Dialogue: 0,0:26:00.02,0:26:03.74,Chinese,,0,0,0,,关于提升加速比后的带来的好处
Dialogue: 0,0:26:04.14,0:26:05.72,English,,0,0,0,,And this is discussed in the book
Dialogue: 0,0:26:04.14,0:26:05.72,Chinese,,0,0,0,,这在书中有讨论
Dialogue: 0,0:26:06.16,0:26:09.78,English,,0,0,0,,You know this isn't just for computers it's any process that you want to speed up
Dialogue: 0,0:26:06.16,0:26:09.78,Chinese,,0,0,0,,这不仅仅适用于计算机，也适用与你希望加速的任何过程
Dialogue: 0,0:26:10.40,0:26:11.98,English,,0,0,0,,And it's a very simple observation
Dialogue: 0,0:26:10.40,0:26:11.98,Chinese,,0,0,0,,这是一个非常简单的量化标准
Dialogue: 0,0:26:11.98,0:26:19.90,English,,0,0,0,,Which is suppose there's some fraction of a system that I can make go faster and I'll call that fraction P
Dialogue: 0,0:26:11.98,0:26:19.90,Chinese,,0,0,0,,假设一个系统中存在一些可加速的部分，我们将这个可加速的部分称为 p
Dialogue: 0,0:26:20.44,0:26:26.72,English,,0,0,0,,P is some number between zero and one point zero right 100% 0%
Dialogue: 0,0:26:20.44,0:26:26.72,Chinese,,0,0,0,, P 的范围在 0 到 1 之间（0 <= p <= 1），100％，0％
Dialogue: 0,0:26:27.96,0:26:31.46,English,,0,0,0,,And let's suppose we take that part that we're going to make run faster
Dialogue: 0,0:26:27.96,0:26:31.46,Chinese,,0,0,0,,让我们假设拿出想加速的那一部分 （P）
Dialogue: 0,0:26:31.86,0:26:34.24,English,,0,0,0,,And improve its performance by a factor K
Dialogue: 0,0:26:31.86,0:26:34.24,Chinese,,0,0,0,,并通过一个加速因子 k 来提高其性能
Dialogue: 0,0:26:37.08,0:26:44.10,English,,0,0,0,,Then we can just very simply talk about what will be the benefit of that performance so we'll call it T(k)
Dialogue: 0,0:26:37.08,0:26:44.10,Chinese,,0,0,0,,这时我们可以简单的讨论下哪些因素可以提升这个性能 T(k)
Dialogue: 0,0:26:44.74,0:26:52.00,English,,0,0,0,,And what it says is the fraction p of the time will be reduced by k
Dialogue: 0,0:26:44.74,0:26:52.00,Chinese,,0,0,0,,T(k) 和 p 成正比，和 k 成反比
Dialogue: 0,0:26:52.98,0:26:59.30,English,,0,0,0,,But the fraction that you can't change a 1-p will remain at its old time
Dialogue: 0,0:26:52.98,0:26:59.30,Chinese,,0,0,0,,但是你不能改变 p，所以 1 - p 也不会改变
Dialogue: 0,0:27:00.07,0:27:03.56,English,,0,0,0,,And that's Amdahl law that's it,that's the whole thing
Dialogue: 0,0:27:00.07,0:27:03.56,Chinese,,0,0,0,,这就是 Amdahl 法则就是这样，这就是整个事情
Dialogue: 0,0:27:03.98,0:27:05.46,English,,0,0,0,,And one interesting measure
Dialogue: 0,0:27:03.98,0:27:05.46,Chinese,,0,0,0,,还有一个有趣的实践
Dialogue: 0,0:27:05.94,0:27:11.00,English,,0,0,0,,What if k were infinity what if we had unbounded resources to speed things up
Dialogue: 0,0:27:05.94,0:27:11.00,Chinese,,0,0,0,,如果 k 是 ∞，如果我们有无限的资源去加速的话会怎么样？
Dialogue: 0,0:27:11.86,0:27:18.92,English,,0,0,0,,And what the observation is the best feed up you'll get is a 1-p
Dialogue: 0,0:27:11.86,0:27:18.92,Chinese,,0,0,0,,观察结果是你获得的最佳效果是 1 - p
Dialogue: 0,0:27:20.44,0:27:24.88,English,,0,0,0,,And so just think it this way if you have 10% of it that you can't change
Dialogue: 0,0:27:20.44,0:27:24.88,Chinese,,0,0,0,,因此，如果你有 10％ 的不可改变的话
Dialogue: 0,0:27:26.02,0:27:29.56,English,,0,0,0,,The other 90% you make infinitely fast
Dialogue: 0,0:27:26.02,0:27:29.56,Chinese,,0,0,0,,同时另外 90％ 你做得非常快
Dialogue: 0,0:27:31.24,0:27:33.76,English,,0,0,0,,Then your performance improvement will be a factor of 10
Dialogue: 0,0:27:31.24,0:27:33.76,Chinese,,0,0,0,,那么你的性能由这 10% 的不可加速部分来决定
Dialogue: 0,0:27:34.16,0:27:37.32,English,,0,0,0,,That's really all it's saying right pretty straightforward idea
Dialogue: 0,0:27:34.16,0:27:37.32,Chinese,,0,0,0,,这就是非常直接的想法
Dialogue: 0,0:27:38.56,0:27:41.10,English,,0,0,0,,So this has sort of direct implications in
Dialogue: 0,0:27:38.56,0:27:41.10,Chinese,,0,0,0,,所以这有一些直接影响
Dialogue: 0,0:27:41.40,0:27:48.00,English,,0,0,0,,So the example is suppose that we can improve the performance of some system of 90% of it
Dialogue: 0,0:27:41.40,0:27:48.00,Chinese,,0,0,0,,举个例子，假设我们可以提高某些系统的 90％ 的性能
Dialogue: 0,0:27:49.04,0:27:53.22,English,,0,0,0,,And we can speed up by factor 9 and that number is chosen to make the numbers work out
Dialogue: 0,0:27:49.04,0:27:53.22,Chinese,,0,0,0,,并且我们假设加速比因子是 9
Dialogue: 0,0:27:53.72,0:27:57.22,English,,0,0,0,,Then we'll get it best at 2x performance improvement
Dialogue: 0,0:27:53.72,0:27:57.22,Chinese,,0,0,0,,那么我们能获得最好的情况是性能提升 2 倍
Dialogue: 0,0:27:57.66,0:28:02.64,English,,0,0,0,,Basically what it says is the part of the system that you can't speed up will become your bottleneck
Dialogue: 0,0:27:57.66,0:28:02.64,Chinese,,0,0,0,,基本上，这说明了在系统中你无法加速的部分将会成为你的瓶颈
Dialogue: 0,0:28:04.02,0:28:06.08,English,,0,0,0,,And that's just the way it is
Dialogue: 0,0:28:04.02,0:28:06.08,Chinese,,0,0,0,,这就是它的工作方式
Dialogue: 0,0:28:06.24,0:28:09.58,English,,0,0,0,,So the implications for this repair while programming are fairly obvious
Dialogue: 0,0:28:06.24,0:28:09.58,Chinese,,0,0,0,,因此编程时对于这部分的修复对性能的影响是显著的
Dialogue: 0,0:28:09.74,0:28:14.00,English,,0,0,0,,That if we can take our application and chop off some fraction of it
Dialogue: 0,0:28:09.74,0:28:14.00,Chinese,,0,0,0,,如果我们可以让我们的应用程序去掉这部分
Dialogue: 0,0:28:14.60,0:28:18.18,English,,0,0,0,,And make it run k times faster by running it on k cores
Dialogue: 0,0:28:14.60,0:28:18.18,Chinese,,0,0,0,,那么可以在 K 核上性能提升 K 倍
Dialogue: 0,0:28:19.74,0:28:28.12,English,,0,0,0,,Then the part of it that's still running sequentially will come to will limit the ultimate performance
Dialogue: 0,0:28:19.74,0:28:28.12,Chinese,,0,0,0,,然后它按顺序运行的部分将限制最终性能
Dialogue: 0,0:28:30.18,0:28:33.62,English,,0,0,0,,We can get so that's not really an issue for this summation problem
Dialogue: 0,0:28:30.18,0:28:33.62,Chinese,,0,0,0,,我们可以看出这已经不单单是一个求和问题了
Dialogue: 0,0:28:33.62,0:28:37.56,English,,0,0,0,,Because it really does divide into as many independent tasks
Dialogue: 0,0:28:33.62,0:28:37.56,Chinese,,0,0,0,,因为它被分成了许多独立的任务
Dialogue: 0,0:28:37.76,0:28:42.60,English,,0,0,0,,As you have numbers and as you can see you can make them run
Dialogue: 0,0:28:37.76,0:28:42.60,Chinese,,0,0,0,,就像你有数字，或者如你所见，你可以让它们运行
Dialogue: 0,0:28:42.60,0:28:46.64,English,,0,0,0,,But many other applications do some part of it that I can't really make know parallel
Dialogue: 0,0:28:42.60,0:28:46.64,Chinese,,0,0,0,,但是许多其他应用程序在其中做了一些我无法实现并行的部分
Dialogue: 0,0:28:49.42,0:28:54.10,English,,0,0,0,,So just as an example and just for the sake of this class
Dialogue: 0,0:28:49.42,0:28:54.10,Chinese,,0,0,0,,所以只是一个例子，也只是为了这们课
Dialogue: 0,0:28:54.28,0:28:59.70,English,,0,0,0,,You know an example of a little bit more involved a problem in parallel programming and multi-threading
Dialogue: 0,0:28:54.28,0:28:59.70,Chinese,,0,0,0,,你知道很多例子都涉及并行编程和多线程问题
Dialogue: 0,0:29:00.10,0:29:02.44,English,,0,0,0,,Let's think about sorting a bunch of numbers
Dialogue: 0,0:29:00.10,0:29:02.44,Chinese,,0,0,0,,我们来考虑排序一堆数字
Dialogue: 0,0:29:02.52,0:29:05.84,English,,0,0,0,,So we have n numbers and we want to sort them
Dialogue: 0,0:29:02.52,0:29:05.84,Chinese,,0,0,0,,我们有 n 个数字，要对它们进行排序
Dialogue: 0,0:29:08.86,0:29:14.74,English,,0,0,0,,And we have some number of threads that we can do this with
Dialogue: 0,0:29:08.86,0:29:14.74,Chinese,,0,0,0,,而且我们可以使用多线程来处理
Dialogue: 0,0:29:14.74,0:29:16.52,English,,0,0,0,,Is there way we can speed this up？
Dialogue: 0,0:29:14.74,0:29:16.52,Chinese,,0,0,0,,有什么办法可以加度吗？
Dialogue: 0,0:29:17.30,0:29:20.26,English,,0,0,0,,And you think about it's not that clear how you do it
Dialogue: 0,0:29:17.30,0:29:20.26,Chinese,,0,0,0,,你想想你该怎么做，并不是很容易搞清楚
Dialogue: 0,0:29:20.26,0:29:23.28,English,,0,0,0,,There's actually a vast literature in parallel sorting
Dialogue: 0,0:29:20.26,0:29:23.28,Chinese,,0,0,0,,实际上有大量并行排序的文献
Dialogue: 0,0:29:23.76,0:29:29.24,English,,0,0,0,,And those you've taken or will take the class 210 will be exposed to a lot of this
Dialogue: 0,0:29:23.76,0:29:29.24,Chinese,,0,0,0,,那些已经或将要参加课程 210 的同学会接触到很多这样的知识
Dialogue: 0,0:29:29.76,0:29:32.80,English,,0,0,0,,But I'm just going to do a very simple version which is quicksort
Dialogue: 0,0:29:29.76,0:29:32.80,Chinese,,0,0,0,,但我只是想做一个非常简单的「快排」版本
Dialogue: 0,0:29:34.16,0:29:36.68,English,,0,0,0,,So quicksort is for example the
Dialogue: 0,0:29:34.16,0:29:36.68,Chinese,,0,0,0,,快速排序是，举个例子
Dialogue: 0,0:29:40.78,0:29:43.70,English,,0,0,0,,The C library program qsort is quicksort
Dialogue: 0,0:29:40.78,0:29:43.70,Chinese,,0,0,0,,C 语言库函数 qsort 就是「快排」
Dialogue: 0,0:29:43.70,0:29:50.72,English,,0,0,0,, it was invented in the early 1960s or 1950s by a guy named Tony Hoare
Dialogue: 0,0:29:43.70,0:29:50.72,Chinese,,0,0,0,,它大概是在上世纪 50， 60 年代由「东尼・霍尔」发明的
Dialogue: 0,0:29:51.58,0:29:55.12,English,,0,0,0,,Who also founded a lot of the fundamental logic of program
Dialogue: 0,0:29:51.58,0:29:55.12,Chinese,,0,0,0,,他也发明了很多程序的基本逻辑
Dialogue: 0,0:29:55.24,0:30:00.96,English,,0,0,0,,So he's like an amazing person still alive today lives in Cambridge England
Dialogue: 0,0:29:55.24,0:30:00.96,Chinese,,0,0,0,,他是一个传奇人物，现在依然生活在英国剑桥
Dialogue: 0,0:30:01.56,0:30:07.42,English,,0,0,0,,But if you ever have a chance to go to a talk by him do so he's amazing person
Dialogue: 0,0:30:01.56,0:30:07.42,Chinese,,0,0,0,,如果你有机会去听他的演讲，你就会发现他是一个很棒的人
Dialogue: 0,0:30:08.14,0:30:13.82,English,,0,0,0,,Anyways the idea quicksort is very simple and this is sort of the basic sorting algorithm
Dialogue: 0,0:30:08.14,0:30:13.82,Chinese,,0,0,0,,无论如何，「快排」的思想非常简单，它一种基本的排序算法
Dialogue: 0,0:30:13.84,0:30:19.68,English,,0,0,0,,You grab some element from the array that you're trying to sort that's called the pivot
Dialogue: 0,0:30:13.84,0:30:19.68,Chinese,,0,0,0,,你要从需要排序数列中挑出一个元素，称为 「基准」（pivot）
Dialogue: 0,0:30:20.42,0:30:27.68,English,,0,0,0,,And then you split the data so that you look at the elements that are either greater or less than the pivot
Dialogue: 0,0:30:20.42,0:30:27.68,Chinese,,0,0,0,,然后把大于和小于「基准」的数分开
Dialogue: 0,0:30:28.10,0:30:32.02,English,,0,0,0,,And potentially also equal let's just assume all the elements are unique here
Dialogue: 0,0:30:28.10,0:30:32.02,Chinese,,0,0,0,,同事也存在等于（基准）元素，这里我们假设所有元素都是唯一的
Dialogue: 0,0:30:32.56,0:30:36.94,English,,0,0,0,,So you just split it into two piles one is the less, one is a greater
Dialogue: 0,0:30:32.56,0:30:36.94,Chinese,,0,0,0,,所以你需要把数组分成两堆，一个小于基准，一个大于基准
Dialogue: 0,0:30:37.42,0:30:41.12,English,,0,0,0,,Now you creatively you recursively you sort those two piles
Dialogue: 0,0:30:37.42,0:30:41.12,Chinese,,0,0,0,,现在你对这两堆元素进行递归排序
Dialogue: 0,0:30:42.50,0:30:46.42,English,,0,0,0,,By the same method and when it's all done you end up with everything sorted
Dialogue: 0,0:30:42.50,0:30:46.42,Chinese,,0,0,0,,用同样的方法，当它们全部完成时，你会得到已排好序的数组
Dialogue: 0,0:30:46.86,0:30:49.34,English,,0,0,0,,One nice thing about it is,it can be done in place
Dialogue: 0,0:30:46.86,0:30:49.34,Chinese,,0,0,0,,快排有一个好处是它可以在「原地」完成排序
Dialogue: 0,0:30:49.34,0:30:57.36,English,,0,0,0,,Meaning if you have an array of data you can do this all just by swapping elements around and not have to use any extra space
Dialogue: 0,0:30:49.34,0:30:57.36,Chinese,,0,0,0,,意思是如果你要对数组进行排序，你可以通过交换元素来完成，而不需要额外的空间
Dialogue: 0,0:30:57.36,0:30:59.44,English,,0,0,0,,Which you would for example with merge sort
Dialogue: 0,0:30:57.36,0:30:59.44,Chinese,,0,0,0,,对于「归并排序」来说，需要额外的空间
Dialogue: 0,0:31:00.14,0:31:05.28,English,,0,0,0,,So this is a fairly simple algorithm and just to visualize it then
Dialogue: 0,0:31:00.14,0:31:05.28,Chinese,,0,0,0,,所以「快排」是一个相当简单的算法，可以把过程可视化
Dialogue: 0,0:31:06.06,0:31:09.62,English,,0,0,0,,You have some block of data X array and you want to sort it
Dialogue: 0,0:31:06.06,0:31:09.62,Chinese,,0,0,0,,想象一下，你有一个数组 X ，想要对它进行排序
Dialogue: 0,0:31:09.70,0:31:13.70,English,,0,0,0,,So you pick an element called the pivot and there's various strategies for doing that
Dialogue: 0,0:31:09.70,0:31:13.70,Chinese,,0,0,0,,然后你选出一个基准元素 p，挑选基准元素有很多策略
Dialogue: 0,0:31:14.88,0:31:19.42,English,,0,0,0,,And now you just subdivide X into three parts
Dialogue: 0,0:31:14.88,0:31:19.42,Chinese,,0,0,0,,现在你只需将数组 X 分为三个部分
Dialogue: 0,0:31:19.56,0:31:24.52,English,,0,0,0,,L the left hand, other right hand meaning less and greater than p
Dialogue: 0,0:31:19.56,0:31:24.52,Chinese,,0,0,0,,p 左边的 L 小于 p，右边的 R 大于 p
Dialogue: 0,0:31:25.06,0:31:26.82,English,,0,0,0,,And then you place p in the middle
Dialogue: 0,0:31:25.06,0:31:26.82,Chinese,,0,0,0,,然后你把 p 放在中间
Dialogue: 0,0:31:27.78,0:31:33.48,English,,0,0,0,,And then you recursively when you're doing this for in a sequential code
Dialogue: 0,0:31:27.78,0:31:33.48,Chinese,,0,0,0,,然后，你可以在顺序执行代码中进行递归操作
Dialogue: 0,0:31:33.48,0:31:39.03,English,,0,0,0,,You'll pick one of these two usually leftmost or rightmost whatever doesn't really matter
Dialogue: 0,0:31:33.48,0:31:39.03,Chinese,,0,0,0,,你将在 L 中选择一个基准，通常是最左边的或者最右边的元素，这并不重要
Dialogue: 0,0:31:39.40,0:31:46.57,English,,0,0,0,,And you'll recursively you apply the same method to the left side and
Dialogue: 0,0:31:39.40,0:31:46.57,Chinese,,0,0,0,,并且使用同样的方法对左边的元素进行递归
Dialogue: 0,0:31:46.86,0:31:51.96,English,,0,0,0,,And ultimately after enough recursions you get to the point where L has been sorted
Dialogue: 0,0:31:46.86,0:31:51.96,Chinese,,0,0,0,,最终，递归完成后 ，L 就已排好序了
Dialogue: 0,0:31:52.24,0:31:57.04,English,,0,0,0,,And that's shown in this kind of a swishy color thing and call that L'
Dialogue: 0,0:31:52.24,0:31:57.04,Chinese,,0,0,0,,这里用这种闪闪发光的颜色表示并称之为 L'
Dialogue: 0,0:31:57.98,0:31:59.30,English,,0,0,0,,And same with
Dialogue: 0,0:31:57.98,0:31:59.30,Chinese,,0,0,0,,同样
Dialogue: 0,0:32:03.86,0:32:07.16,English,,0,0,0,,You'll do the same thing now with the right hand side
Dialogue: 0,0:32:03.86,0:32:07.16,Chinese,,0,0,0,,同样在右边也是如此
Dialogue: 0,0:32:07.62,0:32:10.14,English,,0,0,0,,And when you're done this is usually done in place
Dialogue: 0,0:32:07.62,0:32:10.14,Chinese,,0,0,0,,这个递归操作通常会在原地完成所有的事情
Dialogue: 0,0:32:10.28,0:32:16.52,English,,0,0,0,,So you just the L part works on one array part of the array and the are other part on another
Dialogue: 0,0:32:10.28,0:32:16.52,Chinese,,0,0,0,,L 就在原来的数组中完成了排序，另一边也是在原数组中完成
Dialogue: 0,0:32:16.94,0:32:18.38,English,,0,0,0,,And when you're done they're in sorted order
Dialogue: 0,0:32:16.94,0:32:18.38,Chinese,,0,0,0,,当你完成时，整个数组就是排好序的了
Dialogue: 0,0:32:20.26,0:32:23.18,English,,0,0,0,,The very simple sort and generally has very good performance
Dialogue: 0,0:32:20.26,0:32:23.18,Chinese,,0,0,0,,这是非常简单的排序算法，而且大多是情况性能非常好
Dialogue: 0,0:32:24.64,0:32:30.54,English,,0,0,0,,So this is what the code for it looks like which is usually you have is a special case
Dialogue: 0,0:32:24.64,0:32:30.54,Chinese,,0,0,0,,这是一个段「快排」的代码，其中有两个特殊情况
Dialogue: 0,0:32:30.54,0:32:31.94,English,,0,0,0,,If there's only one or two elements
Dialogue: 0,0:32:30.54,0:32:31.94,Chinese,,0,0,0,,就是在只有一两个元素的时候
Dialogue: 0,0:32:33.04,0:32:35.28,English,,0,0,0,,And then you do this partitioning
Dialogue: 0,0:32:33.04,0:32:35.28,Chinese,,0,0,0,,除此之外你要分区处理
Dialogue: 0,0:32:35.28,0:32:41.50,English,,0,0,0,,So this routine of splitting it between the left and the right hand part is handled by a function called partition
Dialogue: 0,0:32:35.28,0:32:41.50,Chinese,,0,0,0,,这里有一个函数 partition 会把它分成左右两部分
Dialogue: 0,0:32:42.36,0:32:48.10,English,,0,0,0,,And then if there's more than one element in the left side you sort that
Dialogue: 0,0:32:42.36,0:32:48.10,Chinese,,0,0,0,,如果左边的元素大于 1 的话，继续进行递归
Dialogue: 0,0:32:48.72,0:32:51.92,English,,0,0,0,,And if there's more than one element in the right hand side you sort that
Dialogue: 0,0:32:48.72,0:32:51.92,Chinese,,0,0,0,,同样，如果右边也大于 1 个元素的话，就继续对它进行排序
Dialogue: 0,0:32:53.68,0:32:58.66,English,,0,0,0,,And then when all these recursions are done then the array is sorted
Dialogue: 0,0:32:53.68,0:32:58.66,Chinese,,0,0,0,,当所有的递归完成之后，数组就排序好了
Dialogue: 0,0:32:59.30,0:33:04.04,English,,0,0,0,,So pretty typical code and we won't go in the trickiest part writing the code is
Dialogue: 0,0:32:59.30,0:33:04.04,Chinese,,0,0,0,,这是非常典型的快排代码，这里并没有写最难部分的代码
Dialogue: 0,0:33:04.12,0:33:10.18,English,,0,0,0,,How do you make this partitioning go fast But I won't go into that just imagine it happens
Dialogue: 0,0:33:04.12,0:33:10.18,Chinese,,0,0,0,,如何让 partition 变得更快？我这里不会深入，你们可以思考一下
Dialogue: 0,0:33:11.74,0:33:15.90,English,,0,0,0,,So this algorithm actually has a natural version of parallelism
Dialogue: 0,0:33:11.74,0:33:15.90,Chinese,,0,0,0,,实际上这个算法有一个自然版的并行化算法
Dialogue: 0,0:33:16.28,0:33:20.58,English,,0,0,0,,Which is in my sequential version I was sorting both first the left
Dialogue: 0,0:33:16.28,0:33:20.58,Chinese,,0,0,0,,在我的顺序版本中，我首先对左边排序
Dialogue: 0,0:33:20.72,0:33:24.98,English,,0,0,0,,And then the left,the left and the left,the left,the left and kind of working my way
Dialogue: 0,0:33:20.72,0:33:24.98,Chinese,,0,0,0,,然后向左，向左，向左，向左......就像这样
Dialogue: 0,0:33:25.40,0:33:27.50,English,,0,0,0,,Until I got that whole array sorted
Dialogue: 0,0:33:25.40,0:33:27.50,Chinese,,0,0,0,,直到整个数组排好序
Dialogue: 0,0:33:27.78,0:33:30.44,English,,0,0,0,,And then I was coming back and I was working on the right
Dialogue: 0,0:33:27.78,0:33:30.44,Chinese,,0,0,0,,然后我回来对右边进行排序
Dialogue: 0,0:33:30.44,0:33:33.82,English,,0,0,0,,And then the left part of the right and the left to the left to the right and blah blah blah
Dialogue: 0,0:33:30.44,0:33:33.82,Chinese,,0,0,0,,然后是右边的左边部分和左边的左边部分，等等
Dialogue: 0,0:33:34.44,0:33:37.54,English,,0,0,0,,And doing these recursions because the way the codes written
Dialogue: 0,0:33:34.44,0:33:37.54,Chinese,,0,0,0,,然后按照代码进行递归
Dialogue: 0,0:33:40.18,0:33:44.50,English,,0,0,0,,Right I am doing the full sort of the left-hand part
Dialogue: 0,0:33:40.18,0:33:44.50,Chinese,,0,0,0,,这里我正在排序左边的部分
Dialogue: 0,0:33:45.16,0:33:49.60,English,,0,0,0,,And only after that is sorted then I'm doing the complete sort of the right-hand part
Dialogue: 0,0:33:45.16,0:33:49.60,Chinese,,0,0,0,,只有在左边的部分排序好了之后，我才能进行右边部分
Dialogue: 0,0:33:49.78,0:33:56.94,English,,0,0,0,,So the point is it's an algorithm where I'm working just on one part of the array of the time
Dialogue: 0,0:33:49.78,0:33:56.94,Chinese,,0,0,0,,这个算法的重点是同一时间我只能对一部分进行排序
Dialogue: 0,0:33:58.10,0:34:01.86,English,,0,0,0,,But there's a very natural recursion of parallelism here that says
Dialogue: 0,0:33:58.10,0:34:01.86,Chinese,,0,0,0,,但是这里有一个非常自然想法就是并行递归
Dialogue: 0,0:34:02.30,0:34:05.84,English,,0,0,0,,Okay I've got two parts they each need to be sorted
Dialogue: 0,0:34:02.30,0:34:05.84,Chinese,,0,0,0,,好的，我有两个部分，他们每个都需要排序
Dialogue: 0,0:34:06.28,0:34:10.76,English,,0,0,0,,Let me just fire off two threads and let them do with that
Dialogue: 0,0:34:06.28,0:34:10.76,Chinese,,0,0,0,,让我开启两个线程来处理
Dialogue: 0,0:34:12.30,0:34:16.54,English,,0,0,0,,And that's the...So it's what you call divide and conquer parallelism
Dialogue: 0,0:34:12.30,0:34:16.54,Chinese,,0,0,0,,这称为并行「分治」
Dialogue: 0,0:34:16.60,0:34:20.38,English,,0,0,0,,It's a very natural kind of parallelism it shows up in this code
Dialogue: 0,0:34:16.60,0:34:20.38,Chinese,,0,0,0,,像这里展示的代码一样，这是一种非常自然的并行想法
Dialogue: 0,0:34:23.40,0:34:26.68,English,,0,0,0,,So basically I'll do the same thing as before all at
Dialogue: 0,0:34:23.40,0:34:26.68,Chinese,,0,0,0,,所以一开始我会做与之前同样的事情
Dialogue: 0,0:34:26.90,0:34:31.44,English,,0,0,0,,The top level will be a purely sequential process of partitioning
Dialogue: 0,0:34:26.90,0:34:31.44,Chinese,,0,0,0,,最开始是纯粹顺序的分区
Dialogue: 0,0:34:32.60,0:34:38.50,English,,0,0,0,,And but then assuming a partition comes up with some non-trivial split
Dialogue: 0,0:34:32.60,0:34:38.50,Chinese,,0,0,0,,然而，假设一个分区出现了一些复杂的分裂
Dialogue: 0,0:34:39.08,0:34:44.28,English,,0,0,0,,Then I will recursively begin fork of two threads
Dialogue: 0,0:34:39.08,0:34:44.28,Chinese,,0,0,0,,这时我会开启两个线程进行递归
Dialogue: 0,0:34:44.94,0:34:47.40,English,,0,0,0,,Each of which will be responsible for the other and
Dialogue: 0,0:34:44.94,0:34:47.40,Chinese,,0,0,0,,每一个线程负责一部分
Dialogue: 0,0:34:47.40,0:34:51.44,English,,0,0,0,,So we'll sort of look like I'm working on the two parts in parallel
Dialogue: 0,0:34:47.40,0:34:51.44,Chinese,,0,0,0,,看起来就像我在并行地处理两个部分
Dialogue: 0,0:34:52.26,0:34:54.68,English,,0,0,0,,And eventually both sides will end up
Dialogue: 0,0:34:52.26,0:34:54.68,Chinese,,0,0,0,,最终双方都会结束
Dialogue: 0,0:34:55.18,0:34:59.08,English,,0,0,0,,Now this picture isn't really quite true and that it looked makes it look like
Dialogue: 0,0:34:55.18,0:34:59.08,Chinese,,0,0,0,,这张图片不太像，实际上看起来很像（看教授的手势）
Dialogue: 0,0:34:59.52,0:35:05.44,English,,0,0,0,,They're all kind of synchronized together and I'm doing a you know kaboom down like this
Dialogue: 0,0:34:59.52,0:35:05.44,Chinese,,0,0,0,,它们像是一起同步进行，就像我做的这样
Dialogue: 0,0:35:05.66,0:35:09.02,English,,0,0,0,,In a strict way but in fact they're not,it's very asynchronous
Dialogue: 0,0:35:05.66,0:35:09.02,Chinese,,0,0,0,,严格地说，它们不是同步而是异步的
Dialogue: 0,0:35:09.66,0:35:12.50,English,,0,0,0,,The left part is one thread the right is another
Dialogue: 0,0:35:09.66,0:35:12.50,Chinese,,0,0,0,,左边是一个线程，右边是另一个
Dialogue: 0,0:35:13.06,0:35:19.30,English,,0,0,0,,They just go at their own pace and at the end I'm just going to wait for it all to complete
Dialogue: 0,0:35:13.06,0:35:19.30,Chinese,,0,0,0,,它们按照自己的节奏前进，而我只是等待一切都结束
Dialogue: 0,0:35:19.74,0:35:23.70,English,,0,0,0,,But there's no strict temporal ordering on how that all occurs
Dialogue: 0,0:35:19.74,0:35:23.70,Chinese,,0,0,0,,但是这一切并没有严格的时间顺序
Dialogue: 0,0:35:28.28,0:35:33.60,English,,0,0,0,,So the way I'll write this in the code is available on the course website
Dialogue: 0,0:35:28.28,0:35:33.60,Chinese,,0,0,0,,因此，我将在课程网站上提供我写的这部分的代码
Dialogue: 0,0:35:33.60,0:35:35.36,English,,0,0,0,,I'm only going to show you a glimpse of it
Dialogue: 0,0:35:33.60,0:35:35.36,Chinese,,0,0,0,,我只会向你展示一下它
Dialogue: 0,0:35:36.02,0:35:38.40,English,,0,0,0,,It's a non-trivial amount of code it takes to do it
Dialogue: 0,0:35:36.02,0:35:38.40,Chinese,,0,0,0,,这需要比较复杂的代码才能完成
Dialogue: 0,0:35:38.88,0:35:43.36,English,,0,0,0,,But basically what I'm going to do is have a bunch of a pool of threads
Dialogue: 0,0:35:38.88,0:35:43.36,Chinese,,0,0,0,,基本上我要用一堆线程来做这件事情
Dialogue: 0,0:35:43.98,0:35:48.86,English,,0,0,0,,That are ready to work and that's a pretty typical way you write threaded code
Dialogue: 0,0:35:43.98,0:35:48.86,Chinese,,0,0,0,,这已经准备好了，这是一种典型编写线程代码的方式
Dialogue: 0,0:35:49.60,0:35:56.82,English,,0,0,0,,Because actually the initiation of a thread is a non-trivial amount of computation
Dialogue: 0,0:35:49.60,0:35:56.82,Chinese,,0,0,0,,因为实际上一个线程的启动需要复杂的计算量
Dialogue: 0,0:35:56.88,0:35:58.16,English,,0,0,0,,So usually what you do is
Dialogue: 0,0:35:56.88,0:35:58.16,Chinese,,0,0,0,,通常你所做的就是
Dialogue: 0,0:35:58.56,0:36:01.18,English,,0,0,0,,You say I've got this many cores
Dialogue: 0,0:35:58.56,0:36:01.18,Chinese,,0,0,0,,你说我有这么多核
Dialogue: 0,0:36:01.68,0:36:05.76,English,,0,0,0,,I'm going to create a set of that many threads
Dialogue: 0,0:36:01.68,0:36:05.76,Chinese,,0,0,0,,我要创建一组多线程
Dialogue: 0,0:36:06.58,0:36:10.95,English,,0,0,0,,And they will each work by sharing a task queue
Dialogue: 0,0:36:06.58,0:36:10.95,Chinese,,0,0,0,,他们将通过共享任务队列的方式来工作
Dialogue: 0,0:36:11.52,0:36:19.34,English,,0,0,0,,So some agent that is a forking of work for the different threads to do
Dialogue: 0,0:36:11.52,0:36:19.34,Chinese,,0,0,0,,所以一些代理正在创建不同的线程来工作
Dialogue: 0,0:36:19.70,0:36:25.38,English,,0,0,0,,They will do the work assigned to them when that's complete they'll come back and say ok I'm ready for something new
Dialogue: 0,0:36:19.70,0:36:25.38,Chinese,,0,0,0,,他们将去做分配给他们的工作，完成后会回来说好了，我已准备好接受新的任务了
Dialogue: 0,0:36:25.68,0:36:27.02,English,,0,0,0,,And it will give them something new
Dialogue: 0,0:36:25.68,0:36:27.02,Chinese,,0,0,0,,它会给他们一些新的任务
Dialogue: 0,0:36:27.16,0:36:34.54,English,,0,0,0,,So I've there's a little bit of code a very rudimentary code there of creating this task model and task scheduling
Dialogue: 0,0:36:27.16,0:36:34.54,Chinese,,0,0,0,,所以我有一些代码，一段非常简单的代码，为了创建这个任务模型和任务调度
Dialogue: 0,0:36:35.52,0:36:38.08,English,,0,0,0,,So the basic rule will be any given task
Dialogue: 0,0:36:35.52,0:36:38.08,Chinese,,0,0,0,,因此，基本规则是对于任何给定的任务
Dialogue: 0,0:36:39.02,0:36:46.68,English,,0,0,0,,Any given thread then at any given time has been assigned sub range of this array to be a sorting
Dialogue: 0,0:36:39.02,0:36:46.68,Chinese,,0,0,0,,任何给定的线程，在任何给定的时间，这个数组的子范围都被分配给了一个排序任务
Dialogue: 0,0:36:47.28,0:36:55.66,English,,0,0,0,,And it will be specified by the base meaning the starting point of this particular range
Dialogue: 0,0:36:47.28,0:36:55.66,Chinese,,0,0,0,,它将被基准所规定，意思是按照基准进行分割
Dialogue: 0,0:36:56.26,0:37:01.26,English,,0,0,0,,And then the number of elements that it's a told it's sort
Dialogue: 0,0:36:56.26,0:37:01.26,Chinese,,0,0,0,,然后对这些元素进行排序
Dialogue: 0,0:37:03.74,0:37:05.70,English,,0,0,0,,And one other thing I'll do is
Dialogue: 0,0:37:03.74,0:37:05.70,Chinese,,0,0,0,,我要做的另一件事是
Dialogue: 0,0:37:06.04,0:37:10.32,English,,0,0,0,,Once get down to this array being small enough
Dialogue: 0,0:37:06.04,0:37:10.32,Chinese,,0,0,0,,一旦这个数组足够小
Dialogue: 0,0:37:10.82,0:37:12.90,English,,0,0,0,,I'll just sort it sequentially
Dialogue: 0,0:37:10.82,0:37:12.90,Chinese,,0,0,0,,我就只能顺序排序
Dialogue: 0,0:37:13.60,0:37:20.96,English,,0,0,0,,And and we'll see how big that block is or not is actually performance parameter that you can use for tuning the program
Dialogue: 0,0:37:13.60,0:37:20.96,Chinese,,0,0,0,,并且我们将分析出该块的大小其实是可用于调整程序的性能参数
Dialogue: 0,0:37:21.82,0:37:25.32,English,,0,0,0,,So the point is that you don't want to take this down too far
Dialogue: 0,0:37:21.82,0:37:25.32,Chinese,,0,0,0,,所以重点是你不希望把块分的太小
Dialogue: 0,0:37:25.34,0:37:29.60,English,,0,0,0,,Because the sort of overhead of threads is enough that
Dialogue: 0,0:37:25.34,0:37:29.60,Chinese,,0,0,0,,因为线程的开销问题
Dialogue: 0,0:37:29.98,0:37:33.00,English,,0,0,0,,When you get to fine-grained you're actually going to start losing performance
Dialogue: 0,0:37:29.98,0:37:33.00,Chinese,,0,0,0,,当你得到细粒度时，实际上这时会开始失去性能优势
Dialogue: 0,0:37:35.38,0:37:39.48,English,,0,0,0,,So assume that it's bigger than that I've been given some block there
Dialogue: 0,0:37:35.38,0:37:39.48,Chinese,,0,0,0,,因此，假设这里块比我设定的参数要大
Dialogue: 0,0:37:40.04,0:37:43.78,English,,0,0,0,,What I'll do then is I'll run the partition step
Dialogue: 0,0:37:40.04,0:37:43.78,Chinese,,0,0,0,,那我下一步要做的是进行分区
Dialogue: 0,0:37:44.12,0:37:50.50,English,,0,0,0,,This thread will run it a partition step just using the exact function showed you or didn't show you
Dialogue: 0,0:37:44.12,0:37:50.50,Chinese,,0,0,0,,这个线程将运行分区操作，这里我没有写出该代码
Dialogue: 0,0:37:52.74,0:38:00.00,English,,0,0,0,,And then as long as and then I will create and add to the task queue two new tasks
Dialogue: 0,0:37:52.74,0:38:00.00,Chinese,,0,0,0,,然后我再创建两个任务并添加到任务队列当中
Dialogue: 0,0:38:00.84,0:38:05.06,English,,0,0,0,,A one de for the left part and one for the right part
Dialogue: 0,0:38:00.84,0:38:05.06,Chinese,,0,0,0,,左侧部分为一个，右侧部分为一个
Dialogue: 0,0:38:05.78,0:38:13.50,English,,0,0,0,,And then the scheduler that will assign two threads to handle those two parts
Dialogue: 0,0:38:05.78,0:38:13.50,Chinese,,0,0,0,,然后调度程序将分配两个线程来处理这两部分
Dialogue: 0,0:38:13.68,0:38:16.52,English,,0,0,0,,And so that code will that's exactly how the code is going to work
Dialogue: 0,0:38:13.68,0:38:16.52,Chinese,,0,0,0,,因此，这就是并行快排代码的工作方式
Dialogue: 0,0:38:16.66,0:38:21.78,English,,0,0,0,,It's going to keep reusing the same threads over and over again
Dialogue: 0,0:38:16.66,0:38:21.78,Chinese,,0,0,0,,它会一遍又一遍地重复使用相同的线程
Dialogue: 0,0:38:22.56,0:38:27.02,English,,0,0,0,,To but at any given time they'll be given a range of places
Dialogue: 0,0:38:22.56,0:38:27.02,Chinese,,0,0,0,,但在任何时候，他们都会得到一些的不同位置
Dialogue: 0,0:38:27.86,0:38:30.88,English,,0,0,0,,What typically will happen is they'll run their partitioning step
Dialogue: 0,0:38:27.86,0:38:30.88,Chinese,,0,0,0,,通常会发生的是他们将运行分区操作
Dialogue: 0,0:38:32.42,0:38:39.98,English,,0,0,0,,And then say okay I've done my job now assigned to new threads to do this and that's the general scheme of it
Dialogue: 0,0:38:32.42,0:38:39.98,Chinese,,0,0,0,,然后说好，我已经完成了我的工作，现在分配到新线程来做这个，这是它的通常做法
Dialogue: 0,0:38:40.12,0:38:42.40,English,,0,0,0,,Or they'll say this is a small enough block
Dialogue: 0,0:38:40.12,0:38:42.40,Chinese,,0,0,0,,或者他们会说这是一个足够小的块
Dialogue: 0,0:38:43.26,0:38:45.72,English,,0,0,0,,I'm just going to sort the darn thing
Dialogue: 0,0:38:43.26,0:38:45.72,Chinese,,0,0,0,,我只想解决这个问题（后面就不再分配多线程）
Dialogue: 0,0:38:45.76,0:38:48.16,English,,0,0,0,,Okay so that's really all the code does it's online
Dialogue: 0,0:38:45.76,0:38:48.16,Chinese,,0,0,0,,这就是所有的代码，都在课程网站上
Dialogue: 0,0:38:48.68,0:38:54.94,English,,0,0,0,,If you're interested in this kind of stuff it's... I think it's pretty well written code because I wrote it
Dialogue: 0,0:38:48.68,0:38:54.94,Chinese,,0,0,0,,如果你对它感兴趣的话 ...... 我认为这是写得很好的代码，因为这是我写的
Dialogue: 0,0:38:57.62,0:39:00.52,English,,0,0,0,,It so this is sort of that the
Dialogue: 0,0:38:57.62,0:39:00.52,Chinese,,0,0,0,,它就是这样的
Dialogue: 0,0:39:01.50,0:39:04.66,English,,0,0,0,,Somewhat simplified version of the code say
Dialogue: 0,0:39:01.50,0:39:04.66,Chinese,,0,0,0,,这是一段稍微简化后版本的代码
Dialogue: 0,0:39:05.20,0:39:09.42,English,,0,0,0,,Initialize my task queue scheduling system
Dialogue: 0,0:39:05.20,0:39:09.42,Chinese,,0,0,0,,首先初始化我的任务队列调度系统
Dialogue: 0,0:39:10.88,0:39:20.30,English,,0,0,0,,Create global variables of describing the beginning and end of this array to be sorted create a new task queue
Dialogue: 0,0:39:10.88,0:39:20.30,Chinese,,0,0,0,,新建全局变量保存要排序的数组的开头和结尾，创建一个新的任务队列
Dialogue: 0,0:39:20.82,0:39:24.14,English,,0,0,0,,And then this is the main function the tqsort_helper
Dialogue: 0,0:39:20.82,0:39:24.14,Chinese,,0,0,0,,然后是主函数 tqsort_helper
Dialogue: 0,0:39:25.00,0:39:31.68,English,,0,0,0,,Is given some range of addresses and a pointer to the task queue
Dialogue: 0,0:39:25.00,0:39:31.68,Chinese,,0,0,0,,它接受一个地址范围和一个队列指针作为参数
Dialogue: 0,0:39:31.86,0:39:34.72,English,,0,0,0,,That's used to manage these tasks
Dialogue: 0,0:39:31.86,0:39:34.72,Chinese,,0,0,0,,那用于管理这些任务
Dialogue: 0,0:39:35.64,0:39:36.82,English,,0,0,0,,And then uh
Dialogue: 0,0:39:35.64,0:39:36.82,Chinese,,0,0,0,,然后
Dialogue: 0,0:39:40.38,0:39:43.84,English,,0,0,0,,When it's all done. We'll just wait till all the tasks have completed
Dialogue: 0,0:39:40.38,0:39:43.84,Chinese,,0,0,0,,当它完成时......我们要等待所有的任务完成
Dialogue: 0,0:39:43.84,0:39:49.70,English,,0,0,0,, This is at the top level, this isn't part of any recursion this is the top level code
Dialogue: 0,0:39:43.84,0:39:49.70,Chinese,,0,0,0,,这是顶层的设计，上层代码，而不是任何递归的一部分，
Dialogue: 0,0:39:50.08,0:39:51.84,English,,0,0,0,,And then it will free up the data structures
Dialogue: 0,0:39:50.08,0:39:51.84,Chinese,,0,0,0,,然后它将释放我设计的数据结构
Dialogue: 0,0:39:54.24,0:39:58.06,English,,0,0,0,,And then this is the part of it that actually does the real work
Dialogue: 0,0:39:54.24,0:39:58.06,Chinese,,0,0,0,,这是实际完成工作的部分代码
Dialogue: 0,0:39:59.00,0:40:04.82,English,,0,0,0,,It will say so now the tqsort_helper is the part
Dialogue: 0,0:39:59.00,0:40:04.82,Chinese,,0,0,0,,现在可以说 tqsort_helper 是
Dialogue: 0,0:40:04.94,0:40:17.16,English,,0,0,0,,That's a scientists to sort some particulars poises from the starting address the base and some number of elements
Dialogue: 0,0:40:04.94,0:40:17.16,Chinese,,0,0,0,,这是一个科学方法从数组的起始地址和一些元素中整理出的一些特定的元素
Dialogue: 0,0:40:19.06,0:40:22.12,English,,0,0,0,,And so this is what each task will do
Dialogue: 0,0:40:19.06,0:40:22.12,Chinese,,0,0,0,,所以这就是每个任务都需要做的
Dialogue: 0,0:40:22.46,0:40:26.68,English,,0,0,0,,And it says okay if this is a small enough block of elements
Dialogue: 0,0:40:22.46,0:40:26.68,Chinese,,0,0,0,,如果这是一个足够小的元素块
Dialogue: 0,0:40:27.16,0:40:30.42,English,,0,0,0,,I'm just going to call my serial quicksort to do it
Dialogue: 0,0:40:27.16,0:40:30.42,Chinese,,0,0,0,,我就调用排序函数（qsort_serial）来处理
Dialogue: 0,0:40:31.66,0:40:34.90,English,,0,0,0,,Otherwise I'm going to
Dialogue: 0,0:40:31.66,0:40:34.90,Chinese,,0,0,0,,否则，我就要
Dialogue: 0,0:40:45.44,0:40:47.24,English,,0,0,0,,Oh it's a little bit messier this okay
Dialogue: 0,0:40:45.44,0:40:47.24,Chinese,,0,0,0,,这下比较麻烦了
Dialogue: 0,0:40:47.86,0:40:53.56,English,,0,0,0,,Now otherwise it's going to spawn a task to do the sorting
Dialogue: 0,0:40:47.86,0:40:53.56,Chinese,,0,0,0,,否则它会创建一个任务来进行排序
Dialogue: 0,0:40:54.04,0:40:54.80,English,,0,0,0,,Let's see
Dialogue: 0,0:40:54.04,0:40:54.80,Chinese,,0,0,0,,让我们来康康
Dialogue: 0,0:40:55.32,0:40:57.90,English,,0,0,0,,I was a little mixed up,this is a high level
Dialogue: 0,0:40:55.32,0:40:57.90,Chinese,,0,0,0,,我有点混了，这个是较为上层（抽象）的代码
Dialogue: 0,0:40:57.90,0:41:04.22,English,,0,0,0,,So the actual splitting occurs in this thing which is where it
Dialogue: 0,0:40:57.90,0:41:04.22,Chinese,,0,0,0,,所以实际的分割在这里发生
Dialogue: 0,0:41:06.42,0:41:08.28,English,,0,0,0,,So this is the actual thread routine
Dialogue: 0,0:41:06.42,0:41:08.28,Chinese,,0,0,0,,所以这是实际的线程例程
Dialogue: 0,0:41:09.68,0:41:14.20,English,,0,0,0,,And what it's saying is run the partition here
Dialogue: 0,0:41:09.68,0:41:14.20,Chinese,,0,0,0,,这里运行分区操作
Dialogue: 0,0:41:15.36,0:41:20.98,English,,0,0,0,,And then call this tqsort_helper which you just saw on the left and the right parts
Dialogue: 0,0:41:15.36,0:41:20.98,Chinese,,0,0,0,,然后在左右两边调用 tqsort_helper
Dialogue: 0,0:41:25.00,0:41:31.36,English,,0,0,0,,So just to review then the actual spawning of a task is done by this helper routine
Dialogue: 0,0:41:25.00,0:41:31.36,Chinese,,0,0,0,,回顾一下，任务的实际产生是由这个辅助例程完成的
Dialogue: 0,0:41:32.10,0:41:37.02,English,,0,0,0,,But then that what it calls is the thread routine is
Dialogue: 0,0:41:32.10,0:41:37.02,Chinese,,0,0,0,,那就是所谓的线程例程
Dialogue: 0,0:41:38.18,0:41:40.70,English,,0,0,0,,What does the work here and what it will do is
Dialogue: 0,0:41:38.18,0:41:40.70,Chinese,,0,0,0,,在这里发生作用，它将要做的是
Dialogue: 0,0:41:41.00,0:41:43.16,English,,0,0,0,,It will do the partitioning within that thread
Dialogue: 0,0:41:41.00,0:41:43.16,Chinese,,0,0,0,,它将在该线程内进行分区
Dialogue: 0,0:41:43.60,0:41:52.06,English,,0,0,0,,And then it will just throw back and add to the task queue two calls to this helper
Dialogue: 0,0:41:43.60,0:41:52.06,Chinese,,0,0,0,,然后它向任务队列添加两个任务，并调用这函数
Dialogue: 0,0:41:53.82,0:42:00.16,English,,0,0,0,,But as that kind of...So between these two routines you can see it's doing this idea of a divide and conquer parallelism
Dialogue: 0,0:41:53.82,0:42:00.16,Chinese,,0,0,0,,所以在这两个例程之间，你可以看到它在运用这种分治的思想
Dialogue: 0,0:42:02.00,0:42:06.12,English,,0,0,0,,So this is a performance running on the shark machines
Dialogue: 0,0:42:02.00,0:42:06.12,Chinese,,0,0,0,,这是在鲨鱼机器上运行（并行快排）的性能表
Dialogue: 0,0:42:07.42,0:42:18.24,English,,0,0,0,,And this is a fairly straightforward,I'm just taking some number of random value 2^37
Dialogue: 0,0:42:07.42,0:42:18.24,Chinese,,0,0,0,,而这是一个相当直接的方法，我取了 2^37 个随机数
Dialogue: 0,0:42:22.52,0:42:23.42,English,,0,0,0,,That can't be right
Dialogue: 0,0:42:22.52,0:42:23.42,Chinese,,0,0,0,,好像哪里不对
Dialogue: 0,0:42:25.56,0:42:29.56,English,,0,0,0,,Finish this is numbers not 2^37 right you agree with me
Dialogue: 0,0:42:25.56,0:42:29.56,Chinese,,0,0,0,,这是数字（134,217,728）肯定不等于 2^37。你们同意吗？
Dialogue: 0,0:42:31.04,0:42:34.28,English,,0,0,0,,2^37 is 128 billion roughly
Dialogue: 0,0:42:31.04,0:42:34.28,Chinese,,0,0,0,, 2^37 大约是 1280 亿
Dialogue: 0,0:42:34.52,0:42:37.46,English,,0,0,0,,So this number is not right I'll have to check it out
Dialogue: 0,0:42:34.52,0:42:37.46,Chinese,,0,0,0,,这个数字不对，我得去查一下
Dialogue: 0,0:42:39.40,0:42:43.94,English,,0,0,0,,And now what this x axis
Dialogue: 0,0:42:39.40,0:42:43.94,Chinese,,0,0,0,,这个 x 轴表示什么
Dialogue: 0,0:42:44.00,0:42:47.20,English,,0,0,0,,So the y axis just denotes how long does it take to complete
Dialogue: 0,0:42:44.00,0:42:47.20,Chinese,,0,0,0,,y 轴表示完成所需的时间
Dialogue: 0,0:42:47.82,0:42:52.26,English,,0,0,0,,By the way one thing if you're used to measuring performance based on CPU time
Dialogue: 0,0:42:47.82,0:42:52.26,Chinese,,0,0,0,,顺便提一下，如果你之前习惯根据 CPU 时间测量性能
Dialogue: 0,0:42:52.92,0:42:57.92,English,,0,0,0,,That's not useful when you're talking a parallel computing you really want to talk a elapsed time
Dialogue: 0,0:42:52.92,0:42:57.92,Chinese,,0,0,0,,当你真的要计算一个并行计算的时间的时候，那是没有用的，\N你希望关心的应该是整个流程完整经过的时间
Dialogue: 0,0:42:58.44,0:43:04.52,English,,0,0,0,,The time that you'd get from looking at a clock and measuring it and dealing with whatever inefficiency occurs
Dialogue: 0,0:42:58.44,0:43:04.52,Chinese,,0,0,0,,你需要通过时钟来观测，特别是在处理低效任务的时候
Dialogue: 0,0:43:04.98,0:43:08.66,English,,0,0,0,,These are actually the elapsed run time of the entire program
Dialogue: 0,0:43:04.98,0:43:08.66,Chinese,,0,0,0,,这实际上是整个程序的完整运行时间
Dialogue: 0,0:43:11.04,0:43:15.20,English,,0,0,0,,And you'll see that it varies according to this thing called the serial fraction
Dialogue: 0,0:43:11.04,0:43:15.20,Chinese,,0,0,0,,你会发现，它根据「serial fraction」而进行变化
Dialogue: 0,0:43:15.54,0:43:24.64,English,,0,0,0,,The serial fraction is just at what point do I slide between a serial quicksort or keep dividing
Dialogue: 0,0:43:15.54,0:43:24.64,Chinese,,0,0,0,,「serial fraction」是快排和分割之间的滑动点
Dialogue: 0,0:43:24.80,0:43:26.80,English,,0,0,0,,So how big does the array need to be
Dialogue: 0,0:43:24.80,0:43:26.80,Chinese,,0,0,0,,那么我们需要多大的数组？
Dialogue: 0,0:43:27.20,0:43:30.22,English,,0,0,0,,As a fraction expressed as a fraction of the original array
Dialogue: 0,0:43:27.20,0:43:30.22,Chinese,,0,0,0,,作为表示原始数组大小的分数
Dialogue: 0,0:43:31.52,0:43:36.04,English,,0,0,0,,Before I will go into recursion
Dialogue: 0,0:43:31.52,0:43:36.04,Chinese,,0,0,0,,在我进入递归之前
Dialogue: 0,0:43:36.14,0:43:40.06,English,,0,0,0,,If I were actually to write this a real application I wouldn't do it based on a fraction
Dialogue: 0,0:43:36.14,0:43:40.06,Chinese,,0,0,0,,如果我真的要把这个写成应用程序，我不会根据一小部分来做的
Dialogue: 0,0:43:40.14,0:43:47.00,English,,0,0,0,,I'd do it based on a block size to say anything smaller than a thousand elements or some number like that
Dialogue: 0,0:43:40.14,0:43:47.00,Chinese,,0,0,0,,我会根据块的大小来做，可以说任何小于 1000 个元素或类似的数字
Dialogue: 0,0:43:47.18,0:43:51.08,English,,0,0,0,,But this code just happens to be expressed this way
Dialogue: 0,0:43:47.18,0:43:51.08,Chinese,,0,0,0,,但是这个代码恰好以这种方式表示
Dialogue: 0,0:43:51.32,0:43:54.64,English,,0,0,0,,But the thing to notice that's interesting is you'll see here
Dialogue: 0,0:43:51.32,0:43:54.64,Chinese,,0,0,0,,但要注意，这里有个有趣的事情
Dialogue: 0,0:43:57.08,0:44:01.14,English,,0,0,0,,If the fraction is 1 it basically says I won't split this at all
Dialogue: 0,0:43:57.08,0:44:01.14,Chinese,,0,0,0,,如果分数是 1 ，它根本不会拆分
Dialogue: 0,0:44:01.14,0:44:04.10,English,,0,0,0,,I'm just going to call a sequential quicksort
Dialogue: 0,0:44:01.14,0:44:04.10,Chinese,,0,0,0,,我仅仅是进行了顺序执行的快排
Dialogue: 0,0:44:04.24,0:44:07.00,English,,0,0,0,,So this is a purely sequential version of it
Dialogue: 0,0:44:04.24,0:44:07.00,Chinese,,0,0,0,,所以这是纯粹顺序执行的版本
Dialogue: 0,0:44:07.56,0:44:10.80,English,,0,0,0,,And what it shows is if I once I start 2
Dialogue: 0,0:44:07.56,0:44:10.80,Chinese,,0,0,0,,一旦我们从 2 开始就能看到
Dialogue: 0,0:44:11.48,0:44:15.43,English,,0,0,0,,I'll be willing to sort of split this up and do parallelism
Dialogue: 0,0:44:11.48,0:44:15.43,Chinese,,0,0,0,,我把这个拆开来做并行计算
Dialogue: 0,0:44:15.92,0:44:18.92,English,,0,0,0,,I start making run faster and faster and faster
Dialogue: 0,0:44:15.92,0:44:18.92,Chinese,,0,0,0,,我运行的越来越快了
Dialogue: 0,0:44:20.14,0:44:22.24,English,,0,0,0,,And then I get into this trough
Dialogue: 0,0:44:20.14,0:44:22.24,Chinese,,0,0,0,,然后我进入这个低谷
Dialogue: 0,0:44:22.94,0:44:27.76,English,,0,0,0,,And now if I start going finer and finer grain then I'm running into the problem
Dialogue: 0,0:44:22.94,0:44:27.76,Chinese,,0,0,0,,现在，如果我拆分的越来越细，我就会遇到这个问题
Dialogue: 0,0:44:27.76,0:44:34.12,English,,0,0,0,,Where the thread overhead is more than the advantage I'm getting by doing the parallelism
Dialogue: 0,0:44:27.76,0:44:34.12,Chinese,,0,0,0,,（在这个低点）线程开销掩盖了我通过并行计算获得的优势
Dialogue: 0,0:44:34.26,0:44:41.54,English,,0,0,0,,And I'm faster to run that block bigger sort just use a sequential algorithm rather than parallel
Dialogue: 0,0:44:34.26,0:44:41.54,Chinese,,0,0,0,,这时我运行那个大块的排序会更快，所以我们只是使用顺序算法，而不是并行算法
Dialogue: 0,0:44:43.96,0:44:47.40,English,,0,0,0,,But the good news here is this is a pretty long trough here
Dialogue: 0,0:44:43.96,0:44:47.40,Chinese,,0,0,0,,但这里的好消息是，这是一个相当长的低谷
Dialogue: 0,0:44:47.64,0:44:50.72,English,,0,0,0,,So it means is if you're trying to tune this program
Dialogue: 0,0:44:47.64,0:44:50.72,Chinese,,0,0,0,,这意味着，如果你正打算调整这个程序的话
Dialogue: 0,0:44:51.74,0:44:57.40,English,,0,0,0,,It's not that hard you're not going to pay a huge penalty if you don't know a parameter exactly
Dialogue: 0,0:44:51.74,0:44:57.40,Chinese,,0,0,0,,如果你不知道具体的参数，你也不会很难去调试，或是付出很大的代价
Dialogue: 0,0:44:58.04,0:45:04.26,English,,0,0,0,,So as long as this is a huge range right 30 from a 32 to 4096
Dialogue: 0,0:44:58.04,0:45:04.26,Chinese,,0,0,0,,这个范围很大，从 32 到 4096
Dialogue: 0,0:45:04.28,0:45:15.34,English,,0,0,0,,It's a factor of a lot...2^15 and 2^12,2^7 fact 128
Dialogue: 0,0:45:04.28,0:45:15.34,Chinese,,0,0,0,,幂也很大 ... 2^15 和 2^12 , 2^7 就是 128
Dialogue: 0,0:45:16.12,0:45:19.04,English,,0,0,0,,See how I do my arithmetic and powers at 2
Dialogue: 0,0:45:16.12,0:45:19.04,Chinese,,0,0,0,,看看我如何做 2 的幂运算
Dialogue: 0,0:45:19.42,0:45:23.66,English,,0,0,0,,Anyways it's roughly at you know 128 so
Dialogue: 0,0:45:19.42,0:45:23.66,Chinese,,0,0,0,,不管怎么说，大概是 128，所以......
Dialogue: 0,0:45:23.82,0:45:29.38,English,,0,0,0,, Several orders of magnitude,decimal orders of magnitude over which you get pretty comparable performance
Dialogue: 0,0:45:23.82,0:45:29.38,Chinese,,0,0,0,, 几个数量级，小数个数量级，在此基础上，你可以获得相当不错的性能
Dialogue: 0,0:45:29.54,0:45:33.88,English,,0,0,0,,So that means from a performance tuning point of view it's not that hard to do
Dialogue: 0,0:45:29.54,0:45:33.88,Chinese,,0,0,0,,所以，这意味着从性能调优的角度来看，这并不难
Dialogue: 0,0:45:34.62,0:45:41.74,English,,0,0,0,,And you also see we're getting a pretty decent speed up on our eight core to a hyper-threaded machine
Dialogue: 0,0:45:34.62,0:45:41.74,Chinese,,0,0,0,,而且你也看到我们的速度在我们的八核到超线程机器上的改进表现的相当不错
Dialogue: 0,0:45:41.80,0:45:44.80,English,,0,0,0,,We're getting up basically out 7x performance
Dialogue: 0,0:45:41.80,0:45:44.80,Chinese,,0,0,0,,基本上我们的性能可以提升 7 倍
Dialogue: 0,0:45:45.62,0:45:50.60,English,,0,0,0,,And hyper-threading really isn't helping us at all is part of the lesson here
Dialogue: 0,0:45:45.62,0:45:50.60,Chinese,,0,0,0,,在这里超线程真的对我们一点帮助都没有
Dialogue: 0,0:45:51.24,0:45:53.86,English,,0,0,0,,But if you just think of it as eight cores then that's pretty good
Dialogue: 0,0:45:51.24,0:45:53.86,Chinese,,0,0,0,,但如果你只考虑八个核心，那就非常好了
Dialogue: 0,0:45:59.28,0:46:05.78,English,,0,0,0,,So there is an obvious place here where there's Amdahl law issue going on
Dialogue: 0,0:45:59.28,0:46:05.78,Chinese,,0,0,0,,很明显，这就是「阿姆达尔定律」所要表达的
Dialogue: 0,0:46:05.80,0:46:08.26,English,,0,0,0,,If you think at that first top-level split
Dialogue: 0,0:46:05.80,0:46:08.26,Chinese,,0,0,0,,考虑第一个顶层分裂
Dialogue: 0,0:46:09.32,0:46:16.50,English,,0,0,0,,The first call to partition is being done over the entire ray by a sequential process,right
Dialogue: 0,0:46:09.32,0:46:16.50,Chinese,,0,0,0,,第一次调用 partition 是通过在数组中顺序执行完成的
Dialogue: 0,0:46:16.82,0:46:24.38,English,,0,0,0,,So at the very least that is not going parallel at all,there's going exactly one thread is doing the initial partition
Dialogue: 0,0:46:16.82,0:46:24.38,Chinese,,0,0,0,,因此，至少这里根本没有并行，只有一个线程正在进行初始分区
Dialogue: 0,0:46:25.72,0:46:30.64,English,,0,0,0,,And then that splits into two so at most you have two threads worth of parallelism
Dialogue: 0,0:46:25.72,0:46:30.64,Chinese,,0,0,0,,然后分成两个，所以最多你有两个并行的线程
Dialogue: 0,0:46:31.24,0:46:33.38,English,,0,0,0,,And then the next level down at most four
Dialogue: 0,0:46:31.24,0:46:33.38,Chinese,,0,0,0,,然后再往下最多有 4 个线程
Dialogue: 0,0:46:33.42,0:46:34.72,English,,0,0,0,,And so you really don't...
Dialogue: 0,0:46:33.42,0:46:34.72,Chinese,,0,0,0,,所以你不必......
Dialogue: 0,0:46:34.72,0:46:41.42,English,,0,0,0,,You have to get several levels of recursion down before you're really running on all the cores that you have available
Dialogue: 0,0:46:34.72,0:46:41.42,Chinese,,0,0,0,,你必须进行几次递归之后才能利用上所有可用的核
Dialogue: 0,0:46:41.70,0:46:46.04,English,,0,0,0,,So you'd think that that's limiting your speedup，it does
Dialogue: 0,0:46:41.70,0:46:46.04,Chinese,,0,0,0,,所以你会想这是不是限制了你的加速比？确实
Dialogue: 0,0:46:46.04,0:46:53.32,English,,0,0,0,,That's part of the reason why our best performance is a factor of seven and not a factor of eight or more
Dialogue: 0,0:46:46.04,0:46:53.32,Chinese,,0,0,0,,这也是为什么我们最好的性能（加速比）是 7 分，而不是 8 分以上的部分原因
Dialogue: 0,0:46:59.10,0:47:09.30,English,,0,0,0,,So there's quite a bit of work as mentioned on how to speed up performance,including how to make quicksort go faster
Dialogue: 0,0:46:59.10,0:47:09.30,Chinese,,0,0,0,,因此，在如何提高性能方面有很多工作要做，包括如何让「快排」速度更快
Dialogue: 0,0:47:12.00,0:47:15.62,English,,0,0,0,,So there's a vast body of literature on parallel sort
Dialogue: 0,0:47:12.00,0:47:15.62,Chinese,,0,0,0,,因此，有大量关于并行排序的文献
Dialogue: 0,0:47:19.92,0:47:21.38,English,,0,0,0,,So one thing I tried
Dialogue: 0,0:47:19.92,0:47:21.38,Chinese,,0,0,0,,我还试过
Dialogue: 0,0:47:21.72,0:47:27.04,English,,0,0,0,,was to say okay well let's try and do this partitioning step
Dialogue: 0,0:47:21.72,0:47:27.04,Chinese,,0,0,0,,就是将分区并行化
Dialogue: 0,0:47:27.94,0:47:32.70,English,,0,0,0,,They least the top couple levels let's try and do a parallel version of that and
Dialogue: 0,0:47:27.94,0:47:32.70,Chinese,,0,0,0,,至少是最层的几步，让我们试一下对它进行并行处理
Dialogue: 0,0:47:33.34,0:47:36.16,English,,0,0,0,,So the idea is you pick one pivot element
Dialogue: 0,0:47:33.34,0:47:36.16,Chinese,,0,0,0,,现在你要选择一个基准元素
Dialogue: 0,0:47:36.38,0:47:39.24,English,,0,0,0,,But now you fire in this example for threads
Dialogue: 0,0:47:36.38,0:47:39.24,Chinese,,0,0,0,,但这里你要用多个线程
Dialogue: 0,0:47:40.42,0:47:47.18,English,,0,0,0,,And each of those four threads runs a partition step on one-fourth of the range
Dialogue: 0,0:47:40.42,0:47:47.18,Chinese,,0,0,0,,这四个线程中的每一个都只在各自数组的四分之一上执行分区步骤
Dialogue: 0,0:47:48.26,0:47:51.12,English,,0,0,0,,And it don't generate their own versions of left and right
Dialogue: 0,0:47:48.26,0:47:51.12,Chinese,,0,0,0,,并且它不会生成自己的左右部分
Dialogue: 0,0:47:52.26,0:47:59.12,English,,0,0,0,,And then you globally figure out how many are in each of these sub ranges
Dialogue: 0,0:47:52.26,0:47:59.12,Chinese,,0,0,0,,然后你全局计算有多少的子分区
Dialogue: 0,0:48:00.46,0:48:07.00,English,,0,0,0,,And then you tell each thread okay now you copy your part of it over to the relevant section of the array
Dialogue: 0,0:48:00.46,0:48:07.00,Chinese,,0,0,0,,然后你告诉每个线程，复制对应的部分到数组的相关位置
Dialogue: 0,0:48:09.60,0:48:13.78,English,,0,0,0,,But the good news so there's some amount of synchronization that goes on there
Dialogue: 0,0:48:09.60,0:48:13.78,Chinese,,0,0,0,,但好消息是，那里是一些同步操作
Dialogue: 0,0:48:14.48,0:48:18.14,English,,0,0,0,,But you can imagine that this partitioning step
Dialogue: 0,0:48:14.48,0:48:18.14,Chinese,,0,0,0,,但你可以想象这个分区步骤
Dialogue: 0,0:48:18.44,0:48:23.78,English,,0,0,0,,Once when you're running it is completely independent of across the different threads
Dialogue: 0,0:48:18.44,0:48:23.78,Chinese,,0,0,0,,一旦你运行它就完全由不同的独立线程来处理
Dialogue: 0,0:48:23.82,0:48:26.52,English,,0,0,0,,So it's getting a almost ideal speed-up
Dialogue: 0,0:48:23.82,0:48:26.52,Chinese,,0,0,0,,所以能获得了几乎理想的加速比
Dialogue: 0,0:48:27.62,0:48:32.90,English,,0,0,0,,So I implemented this and tried and I couldn't make it run faster than the original code
Dialogue: 0,0:48:27.62,0:48:32.90,Chinese,,0,0,0,,所以我实现了这个并尝试了，但是我无法让它比原始代码运行得更快
Dialogue: 0,0:48:33.72,0:48:39.68,English,,0,0,0,,And I think the the problem with this was the copying the cost of copying data
Dialogue: 0,0:48:33.72,0:48:39.68,Chinese,,0,0,0,,我认为问题是出在复制数据的开销上
Dialogue: 0,0:48:41.96,0:48:47.80,English,,0,0,0,,Here was even though it's being done by multiple threads
Dialogue: 0,0:48:41.96,0:48:47.80,Chinese,,0,0,0,,这里，即使（这个分区过程）是由多个线程完成的
Dialogue: 0,0:48:48.30,0:48:51.24,English,,0,0,0,,And getting pretty good performance out of the memory system
Dialogue: 0,0:48:48.30,0:48:51.24,Chinese,,0,0,0,,并在内存系统中获得相当不错的性能
Dialogue: 0,0:48:51.26,0:48:56.12,English,,0,0,0,,Because you're doing sequential you know all the cache issues are pretty good here
Dialogue: 0,0:48:51.26,0:48:56.12,Chinese,,0,0,0,,因为你在做顺序复制，而这里的缓存都是相当不错的
Dialogue: 0,0:48:56.80,0:48:58.94,English,,0,0,0,,But that's just enough extra work
Dialogue: 0,0:48:56.80,0:48:58.94,Chinese,,0,0,0,,但这只是额外的工作
Dialogue: 0,0:48:59.52,0:49:04.88,English,,0,0,0,,That has to be done for this parallel code that doesn't have to be done the sequential code is totally in place
Dialogue: 0,0:48:59.52,0:49:04.88,Chinese,,0,0,0,,对于并行部分（分区）我们这样做很不错，但是在顺序部分我们根本不需要\N（做这些额外部分），因为本来顺序代码本就是原地操作
Dialogue: 0,0:49:05.82,0:49:08.96,English,,0,0,0,,Meaning not using any additional storage not copying
Dialogue: 0,0:49:05.82,0:49:08.96,Chinese,,0,0,0,,意思是不使用任何其他存储空间，不用复制
Dialogue: 0,0:49:09.34,0:49:13.12,English,,0,0,0,,And so that's just enough of a penalty on the parallel part
Dialogue: 0,0:49:09.34,0:49:13.12,Chinese,,0,0,0,,所以这足够给我们并行部分带来一些损失
Dialogue: 0,0:49:13.56,0:49:16.04,English,,0,0,0,,That it didn't really improve performance at all
Dialogue: 0,0:49:13.56,0:49:16.04,Chinese,,0,0,0,,所以对于整体而言，它没有真正提高性能
Dialogue: 0,0:49:16.56,0:49:20.54,English,,0,0,0,,So that code is shown as part of the code on the course website
Dialogue: 0,0:49:16.56,0:49:20.54,Chinese,,0,0,0,,这部分代码在课程网站上可以找到
Dialogue: 0,0:49:20.68,0:49:27.90,English,,0,0,0,,But like I said I banged on it quite a bit and trying to tune it And squeak it in various ways and could never make it
Dialogue: 0,0:49:20.68,0:49:27.90,Chinese,,0,0,0,,但就像我说的，我经常打磨它，并试图用各种方法来调整它，但始终无法让它变得更完美
Dialogue: 0,0:49:28.46,0:49:31.54,English,,0,0,0,,So I got better overall performance out of this program
Dialogue: 0,0:49:28.46,0:49:31.54,Chinese,,0,0,0,,所以我从这个项目中获得了更好的整体表现
Dialogue: 0,0:49:33.34,0:49:38.70,English,,0,0,0,,And so that's again a lesson and that's one of the unfortunate lessons is you can spend a lot of time
Dialogue: 0,0:49:33.34,0:49:38.70,Chinese,,0,0,0,,所以这又是一个教训，这是一个不幸的教训，你可以花很多时间
Dialogue: 0,0:49:40.16,0:49:43.64,English,,0,0,0,,Trying to make a program run faster and get absolutely nowhere
Dialogue: 0,0:49:40.16,0:49:43.64,Chinese,,0,0,0,,试图让程序运行得更快，但是发现没有改进成功
Dialogue: 0,0:49:44.72,0:49:47.34,English,,0,0,0,,And it's frustrating because you put in a lot of work
Dialogue: 0,0:49:44.72,0:49:47.34,Chinese,,0,0,0,,这很令人沮丧，因为你投入了大量的工作
Dialogue: 0,0:49:47.90,0:49:52.72,English,,0,0,0,,And you know it's a pretty cool idea and you'd love to publish a paper about it or tell your friends about it
Dialogue: 0,0:49:47.90,0:49:52.72,Chinese,,0,0,0,,而且你知道这是一个非常酷的想法，你打算发表一篇关于它的论文或者告诉你的朋友
Dialogue: 0,0:49:53.02,0:49:55.64,English,,0,0,0,,And it just goes nowhere and it just sits there
Dialogue: 0,0:49:53.02,0:49:55.64,Chinese,,0,0,0,,但我们确实拿它没办法
Dialogue: 0,0:49:55.98,0:50:02.20,English,,0,0,0,,There's nothing...unfortunately there's not...an accumulated repository of the bad ideas of computer science
Dialogue: 0,0:49:55.98,0:50:02.20,Chinese,,0,0,0,,很不幸的是，目前也没有一个不断扩充的计算机科学错误点子合集让你来参考
Dialogue: 0,0:50:02.30,0:50:03.70,English,,0,0,0,,Don't waste your time trying this
Dialogue: 0,0:50:02.30,0:50:03.70,Chinese,,0,0,0,,告诉你不要浪费时间尝试这个
Dialogue: 0,0:50:04.30,0:50:06.30,English,,0,0,0,,That people can talk about so
Dialogue: 0,0:50:04.30,0:50:06.30,Chinese,,0,0,0,,我们可以谈论这个事情
Dialogue: 0,0:50:06.88,0:50:09.18,English,,0,0,0,,This is just a lesson to learn
Dialogue: 0,0:50:06.88,0:50:09.18,Chinese,,0,0,0,,这确实是你必须吸取的教训
Dialogue: 0,0:50:11.90,0:50:15.34,English,,0,0,0,,So anyways that was my experience with that
Dialogue: 0,0:50:11.90,0:50:15.34,Chinese,,0,0,0,,所以，不管怎么样，我的经验是
Dialogue: 0,0:50:15.64,0:50:21.78,English,,0,0,0,,Again other people have spent a lot more time this is one of the most common applications
Dialogue: 0,0:50:15.64,0:50:21.78,Chinese,,0,0,0,,再强调一下，其他人花了很多时间，其中这个就是最常见的
Dialogue: 0,0:50:22.10,0:50:24.52,English,,0,0,0,,That people try to do parallel programming for
Dialogue: 0,0:50:22.10,0:50:24.52,Chinese,,0,0,0,,人们尝试做并行计算的应用程序之一
Dialogue: 0,0:50:26.68,0:50:30.78,English,,0,0,0,,So some of the lessons from this is you need a good strategy
Dialogue: 0,0:50:26.68,0:50:30.78,Chinese,,0,0,0,,因此，一些教训是你需要一个好的策略
Dialogue: 0,0:50:30.80,0:50:33.42,English,,0,0,0,,For how you're going to get parallelism out of your application
Dialogue: 0,0:50:30.80,0:50:33.42,Chinese,,0,0,0,,了解如何从应用程序中获得并行性
Dialogue: 0,0:50:34.10,0:50:38.94,English,,0,0,0,,And I showed you two basic versions one is partitioned into k parts
Dialogue: 0,0:50:34.10,0:50:38.94,Chinese,,0,0,0,,我向你展示了两个基本版本，一个是分区分为 k 个部分
Dialogue: 0,0:50:39.00,0:50:42.26,English,,0,0,0,,They're more or less completely independent of each other
Dialogue: 0,0:50:39.00,0:50:42.26,Chinese,,0,0,0,,它们或多或少完全相互独立
Dialogue: 0,0:50:42.78,0:50:46.78,English,,0,0,0,,Or something like a divide and conquer strategy where you can keep splitting it
Dialogue: 0,0:50:42.78,0:50:46.78,Chinese,,0,0,0,,或者类似于分治的策略，你可以继续分裂它
Dialogue: 0,0:50:46.90,0:50:50.92,English,,0,0,0,,But the two splits that you create out of that can go concurrently
Dialogue: 0,0:50:46.90,0:50:50.92,Chinese,,0,0,0,,同时你创建的两个分裂可以并行运行
Dialogue: 0,0:50:51.78,0:50:54.98,English,,0,0,0,,These other different types of parallelism to
Dialogue: 0,0:50:51.78,0:50:54.98,Chinese,,0,0,0,,这些其他不同类型的并行
Dialogue: 0,0:50:55.60,0:50:57.74,English,,0,0,0,,In general you want to make the inner loops
Dialogue: 0,0:50:55.60,0:50:57.74,Chinese,,0,0,0,,通常，当你在进行内部循环时
Dialogue: 0,0:50:57.74,0:51:02.56,English,,0,0,0,,You can't have any synchronization primitives in there it will just run too slow
Dialogue: 0,0:50:57.74,0:51:02.56,Chinese,,0,0,0,,你不能在里面写任何同步原语，因为这样会导致运行得很慢
Dialogue: 0,0:51:03.28,0:51:07.90,English,,0,0,0,,Amdahl as I mentioned is always sort of lurking in the background of
Dialogue: 0,0:51:03.28,0:51:07.90,Chinese,,0,0,0,,我提到的「阿姆达尔定律」总是存在着
Dialogue: 0,0:51:08.00,0:51:13.36,English,,0,0,0,,If you can always speedup a part of your program then the other part will become the bottleneck
Dialogue: 0,0:51:08.00,0:51:13.36,Chinese,,0,0,0,,如果你可以经常提升程序某部分的速度时，那么另一些部分就将成为瓶颈
Dialogue: 0,0:51:14.26,0:51:17.81,English,,0,0,0,,But the other thing is like I said you can do it
Dialogue: 0,0:51:14.26,0:51:17.81,Chinese,,0,0,0,,但是另外的是，你们可以尝试
Dialogue: 0,0:51:17.81,0:51:22.50,English,,0,0,0,,You've got the tools you've learned with pthreads
Dialogue: 0,0:51:17.81,0:51:22.50,Chinese,,0,0,0,,你已经掌握了线程的工具
Dialogue: 0,0:51:22.92,0:51:27.22,English,,0,0,0,,And your knowledge of programming and your understanding of cache memories and things like that
Dialogue: 0,0:51:22.92,0:51:27.22,Chinese,,0,0,0,,还有编程知识，缓存和内存之类的知识
Dialogue: 0,0:51:27.74,0:51:32.80,English,,0,0,0,,You've got the tools you need to be an effective programmer of this kind of thing
Dialogue: 0,0:51:27.74,0:51:32.80,Chinese,,0,0,0,,你已经掌握了成为一名高效程序员所需的工具
Dialogue: 0,0:51:33.94,0:51:41.36,English,,0,0,0,,But you have to and there's nothing that beats sort of trial and error and testing and tuning experimenting
Dialogue: 0,0:51:33.94,0:51:41.36,Chinese,,0,0,0,,但你最好...没有什么能比试错和测试还有图灵测试更重要了
Dialogue: 0,0:51:41.78,0:51:44.16,English,,0,0,0,,If there's some parameters that need to be set
Dialogue: 0,0:51:41.78,0:51:44.16,Chinese,,0,0,0,,如果需要设置一些参数
Dialogue: 0,0:51:44.32,0:51:48.28,English,,0,0,0,,Then you want to run experiments through the parameters to try and figure out
Dialogue: 0,0:51:44.32,0:51:48.28,Chinese,,0,0,0,,这时你应该通过多运行几次带不同参数的程序来弄清楚
Dialogue: 0,0:51:48.88,0:51:50.14,English,,0,0,0,,What the setting should be
Dialogue: 0,0:51:48.88,0:51:50.14,Chinese,,0,0,0,,参数应该设置为什么
Dialogue: 0,0:51:52.08,0:51:54.76,English,,0,0,0,,So that's sort of a little bit about parallel programming
Dialogue: 0,0:51:52.08,0:51:54.76,Chinese,,0,0,0,,以上是并行编程的一些介绍
Dialogue: 0,0:51:55.16,0:52:01.50,English,,0,0,0,,Let me just finish this lecture with a little bit of sort of classic issues about concurrency
Dialogue: 0,0:51:55.16,0:52:01.50,Chinese,,0,0,0,,现在让我来讲一些有关并发的经典问题来结束本次课
Dialogue: 0,0:52:01.62,0:52:05.32,English,,0,0,0,,That are critical when you're dealing with
Dialogue: 0,0:52:01.62,0:52:05.32,Chinese,,0,0,0,,这些问题很重要，特别是在
Dialogue: 0,0:52:06.50,0:52:11.14,English,,0,0,0,,These systems based on what you call a shared memory model of computation
Dialogue: 0,0:52:06.50,0:52:11.14,Chinese,,0,0,0,,基于共享内存计算模型的系统
Dialogue: 0,0:52:11.76,0:52:17.62,English,,0,0,0,,So multi-core is an example of conceptually multi-threaded computation
Dialogue: 0,0:52:11.76,0:52:17.62,Chinese,,0,0,0,,因此，多核是多线程计算的一个例子
Dialogue: 0,0:52:17.62,0:52:21.38,English,,0,0,0,,Remember you're working within a single virtual address space
Dialogue: 0,0:52:17.62,0:52:21.38,Chinese,,0,0,0,,还记得，你的程序是工作在单个虚拟地址空间内的
Dialogue: 0,0:52:22.48,0:52:24.68,English,,0,0,0,,And you have private stacks
Dialogue: 0,0:52:22.48,0:52:24.68,Chinese,,0,0,0,,你有一些私有的栈
Dialogue: 0,0:52:25.18,0:52:30.26,English,,0,0,0,,But the more global the heap memory is completely shared across threads
Dialogue: 0,0:52:25.18,0:52:30.26,Chinese,,0,0,0,,但更全局性的，像堆内存完全是跨线程共享的
Dialogue: 0,0:52:31.04,0:52:35.06,English,,0,0,0,,And so that's what you call the shared memory programming model
Dialogue: 0,0:52:31.04,0:52:35.06,Chinese,,0,0,0,,这就是共享内存编程模型
Dialogue: 0,0:52:35.18,0:52:36.88,English,,0,0,0,,What we've really been looking at this course
Dialogue: 0,0:52:35.18,0:52:36.88,Chinese,,0,0,0,,这就是我们这次课真正关注的
Dialogue: 0,0:52:38.76,0:52:42.97,English,,0,0,0,,So there's a certain interesting question about called memory consistency models
Dialogue: 0,0:52:38.76,0:52:42.97,Chinese,,0,0,0,,关于内存一致性模型，有一个很有意思的问题
Dialogue: 0,0:52:43.94,0:52:46.58,English,,0,0,0,,And here I'll illustrate it with a very simple example
Dialogue: 0,0:52:43.94,0:52:46.58,Chinese,,0,0,0,,这里，我将用一个非常简单的例子来说明它
Dialogue: 0,0:52:47.12,0:52:50.78,English,,0,0,0,,Imagine we have two global variables a and b
Dialogue: 0,0:52:47.12,0:52:50.78,Chinese,,0,0,0,,想象一下，我们有两个全局变量 a 和 b
Dialogue: 0,0:52:51.02,0:52:52.22,English,,0,0,0,,And we have two different threads
Dialogue: 0,0:52:51.02,0:52:52.22,Chinese,,0,0,0,,我们有两个不同的线程
Dialogue: 0,0:52:53.08,0:52:58.66,English,,0,0,0,,And so the first thread is going to write meaning assign the value to a
Dialogue: 0,0:52:53.08,0:52:58.66,Chinese,,0,0,0,,第一个线程将会进行写操作，给 a 赋值
Dialogue: 0,0:52:59.12,0:53:02.02,English,,0,0,0,,And it's going to read meaning print the value of b
Dialogue: 0,0:52:59.12,0:53:02.02,Chinese,,0,0,0,,并且它将进行读操作，打印 b 的值
Dialogue: 0,0:53:02.72,0:53:08.84,English,,0,0,0,,And the other thread is going to do the opposite it's going to write assigned the value to b and print the value of a
Dialogue: 0,0:53:02.72,0:53:08.84,Chinese,,0,0,0,,另一个线程将执行相反的操作，它将为 b 赋值，并打印 a 的值
Dialogue: 0,0:53:09.40,0:53:14.20,English,,0,0,0,,And so now the question is what are the possible outputs for this program
Dialogue: 0,0:53:09.40,0:53:14.20,Chinese,,0,0,0,,现在问题来了，这个程序输出的结果可能是什么
Dialogue: 0,0:53:15.52,0:53:21.12,English,,0,0,0,,And so there's a model that sort of the accepted standard called sequential consistency
Dialogue: 0,0:53:15.52,0:53:21.12,Chinese,,0,0,0,,有一个模型，像公认的标准一样，叫做「顺序一致性」
Dialogue: 0,0:53:21.64,0:53:24.22,English,,0,0,0,,Which means that these events can occur
Dialogue: 0,0:53:21.64,0:53:24.22,Chinese,,0,0,0,,这意味着可以发生这些事件
Dialogue: 0,0:53:24.68,0:53:33.56,English,,0,0,0,,these that within a single thread things have to occur in the sequential order of that thread
Dialogue: 0,0:53:24.68,0:53:33.56,Chinese,,0,0,0,,单个线程中的东西一定要按照该线程的顺序来进行
Dialogue: 0,0:53:34.52,0:53:40.98,English,,0,0,0,,But across threads whether write a write b occurs first is completely arbitrary
Dialogue: 0,0:53:34.52,0:53:40.98,Chinese,,0,0,0,,但是跨线程的情况，先写 a 还是先写入 b 是完全随意的
Dialogue: 0,0:53:41.30,0:53:43.80,English,,0,0,0,,And similarly whether writing of b occurs
Dialogue: 0,0:53:41.30,0:53:43.80,Chinese,,0,0,0,,并且类似地 b 的写入会发生在
Dialogue: 0,0:53:44.56,0:53:52.20,English,,0,0,0,,Between these two actions or before is all too arbitrary
Dialogue: 0,0:53:44.56,0:53:52.20,Chinese,,0,0,0,,这两个操作之间或以前都有可能，非常随意
Dialogue: 0,0:53:52.28,0:54:01.56,English,,0,0,0,,So what it means is you can take two different threads and you can interleave their events in anyway
Dialogue: 0,0:53:52.28,0:54:01.56,Chinese,,0,0,0,,这意味着你可以操作两个不同的线程，而且你可以任意交错它们这两个事件
Dialogue: 0,0:54:02.26,0:54:10.98,English,,0,0,0,,But you should be able to pull out of that interleaving the sequential order of either of both of the two threads
Dialogue: 0,0:54:02.26,0:54:10.98,Chinese,,0,0,0,,但是，你应该可以顺序的提出在两个线程中的交错事件
Dialogue: 0,0:54:12.48,0:54:16.54,English,,0,0,0,,So when you do that you end up you can enumerate in the example like this
Dialogue: 0,0:54:12.48,0:54:16.54,Chinese,,0,0,0,,所以，当你这样做的时候，你可以像这样列出所有情况
Dialogue: 0,0:54:17.00,0:54:19.26,English,,0,0,0,,All the possibilities you can say well look it
Dialogue: 0,0:54:17.00,0:54:19.26,Chinese,,0,0,0,,你们看到的就是所有的情况
Dialogue: 0,0:54:20.12,0:54:22.48,English,,0,0,0,,First is either going to be write a or write b
Dialogue: 0,0:54:20.12,0:54:22.48,Chinese,,0,0,0,,第一步，先写 a还是先写 b，两种情况选一个
Dialogue: 0,0:54:23.40,0:54:24.60,English,,0,0,0,,Let's pick write a
Dialogue: 0,0:54:23.40,0:54:24.60,Chinese,,0,0,0,,我们选择先写 a
Dialogue: 0,0:54:25.42,0:54:30.04,English,,0,0,0,,So now the next event will be either read of b or write of b
Dialogue: 0,0:54:25.42,0:54:30.04,Chinese,,0,0,0,,所以接下来的事件是要么读取 b 要么写入 b
Dialogue: 0,0:54:31.86,0:54:36.10,English,,0,0,0,,And then if I do write a read b
Dialogue: 0,0:54:31.86,0:54:36.10,Chinese,,0,0,0,,如果我选择写入 a 读取 b
Dialogue: 0,0:54:36.78,0:54:38.42,English,,0,0,0,,Then I've completed this thread
Dialogue: 0,0:54:36.78,0:54:38.42,Chinese,,0,0,0,,现在我完成了这个线程
Dialogue: 0,0:54:39.04,0:54:44.44,English,,0,0,0,,And so now the only possibility is to write to b and read a, and so forth
Dialogue: 0,0:54:39.04,0:54:44.44,Chinese,,0,0,0,,所以现在唯一的可能是写入 b 并读取 a，以此类推
Dialogue: 0,0:54:44.52,0:54:48.74,English,,0,0,0,,You work out all the possible things you get six different event orderings
Dialogue: 0,0:54:44.52,0:54:48.74,Chinese,,0,0,0,,如果你列出所有的可能性，你会得到 6 种不同的事件顺序
Dialogue: 0,0:54:49.52,0:54:53.08,English,,0,0,0,,And then what will be printed is well first of all
Dialogue: 0,0:54:49.52,0:54:53.08,Chinese,,0,0,0,,然后首先要打印的是
Dialogue: 0,0:54:53.22,0:54:59.42,English,,0,0,0,,Whether you print b before a would depend on the relative ordering of those two threads
Dialogue: 0,0:54:53.22,0:54:59.42,Chinese,,0,0,0,,是否在a之前打印b，取决于这两个线程的相对执行顺序
Dialogue: 0,0:54:59.42,0:55:02.34,English,,0,0,0,,So that's shown I'm showing the b value in blue
Dialogue: 0,0:54:59.42,0:55:02.34,Chinese,,0,0,0,,所以，这里我用蓝色显示 b 的值
Dialogue: 0,0:55:03.06,0:55:07.54,English,,0,0,0,,And the red value in red I'm sorry the a value in red
Dialogue: 0,0:55:03.06,0:55:07.54,Chinese,,0,0,0,,红色的是 a 的值
Dialogue: 0,0:55:09.02,0:55:14.88,English,,0,0,0,,And you'll get these different possibilities,these are all the six possible outputs of this program
Dialogue: 0,0:55:09.02,0:55:14.88,Chinese,,0,0,0,,你会得到这个程序的六种可能的输出
Dialogue: 0,0:55:15.54,0:55:22.88,English,,0,0,0,,But you'll see that there are two other outputs one could imagine that won't arise
Dialogue: 0,0:55:15.54,0:55:22.88,Chinese,,0,0,0,,但是你会发现有两个其他的输出不会出现
Dialogue: 0,0:55:23.78,0:55:28.52,English,,0,0,0,,One is to print 100 and 1
Dialogue: 0,0:55:23.78,0:55:28.52,Chinese,,0,0,0,,一种是打印 100， 1
Dialogue: 0,0:55:28.58,0:55:34.28,English,,0,0,0,,In other words to have them both print the original values of these two variables
Dialogue: 0,0:55:28.58,0:55:34.28,Chinese,,0,0,0,,换句话说，就是打印这两个变量的原始值
Dialogue: 0,0:55:34.88,0:55:36.62,English,,0,0,0,,And that's impossible because
Dialogue: 0,0:55:34.88,0:55:36.62,Chinese,,0,0,0,,这是不可能的
Dialogue: 0,0:55:37.74,0:55:39.86,English,,0,0,0,,I have to have done at least one write
Dialogue: 0,0:55:37.74,0:55:39.86,Chinese,,0,0,0,,因为我必须至少完成一次写操作
Dialogue: 0,0:55:42.26,0:55:45.84,English,,0,0,0,,Before I can reach either of these two print statements right
Dialogue: 0,0:55:42.26,0:55:45.84,Chinese,,0,0,0,,之后才能执行两条打印语句的其中一条
Dialogue: 0,0:55:46.28,0:55:53.62,English,,0,0,0,,So it's not possible for these to still be in their original values of When I hit these print statements
Dialogue: 0,0:55:46.28,0:55:53.62,Chinese,,0,0,0,,所以当我执行打印语句时，它们不可能保持原来的值
Dialogue: 0,0:55:56.14,0:56:01.06,English,,0,0,0,,And whichever order I hit these two,so those two are impossible
Dialogue: 0,0:55:56.14,0:56:01.06,Chinese,,0,0,0,,无论我以怎样的顺序执行，他们两个不可能都不变
Dialogue: 0,0:56:01.36,0:56:04.48,English,,0,0,0,,So that's the idea of sequential consistency that there's
Dialogue: 0,0:56:01.36,0:56:04.48,Chinese,,0,0,0,,所以这就是顺序一致性的思想
Dialogue: 0,0:56:05.16,0:56:10.96,English,,0,0,0,,Some very large number but of possible outputs of a program
Dialogue: 0,0:56:05.16,0:56:10.96,Chinese,,0,0,0,,即使这个程序会输出很大的值
Dialogue: 0,0:56:11.42,0:56:17.26,English,,0,0,0,,But in any case they can't violate The ordering implied by the individual threads
Dialogue: 0,0:56:11.42,0:56:17.26,Chinese,,0,0,0,,但无论如何，他们都不能违反当个线程的内在执行顺序
Dialogue: 0,0:56:19.44,0:56:23.36,English,,0,0,0,,So you'd say okay that seems like pretty obvious thing
Dialogue: 0,0:56:19.44,0:56:23.36,Chinese,,0,0,0,,所以你说那好吧，这本来看起来就很明显
Dialogue: 0,0:56:24.66,0:56:29.16,English,,0,0,0,,But actually if you think from a hardware perspective it's not that trivial to make that happen
Dialogue: 0,0:56:24.66,0:56:29.16,Chinese,,0,0,0,,但实际上，如果你从硬件的角度思考，实现这一目标并非易事
Dialogue: 0,0:56:30.04,0:56:36.04,English,,0,0,0,,So let me just throw a show you a scenario of multi-core hardware
Dialogue: 0,0:56:30.04,0:56:36.04,Chinese,,0,0,0,,接下来我会展示一个多核硬件的场景
Dialogue: 0,0:56:36.58,0:56:38.70,English,,0,0,0,,That would violate sequential consistency
Dialogue: 0,0:56:36.58,0:56:38.70,Chinese,,0,0,0,,这会违反顺序一致性
Dialogue: 0,0:56:39.72,0:56:42.98,English,,0,0,0,,Assume that each of our threads has its own private cache
Dialogue: 0,0:56:39.72,0:56:42.98,Chinese,,0,0,0,,假设我们的每个线程都有自己的私有缓存
Dialogue: 0,0:56:44.68,0:56:49.74,English,,0,0,0,,And so if I execute this statement
Dialogue: 0,0:56:44.68,0:56:49.74,Chinese,,0,0,0,,所以如果我执行这条语句
Dialogue: 0,0:56:50.14,0:56:57.26,English,,0,0,0,,What I'll do is I will grab a copy of a from the main memory and bring it into my cache
Dialogue: 0,0:56:50.14,0:56:57.26,Chinese,,0,0,0,,我要做的是从内存中复制 a 到线程的缓存中
Dialogue: 0,0:56:57.82,0:56:59.92,English,,0,0,0,,And I will assign this new value to it
Dialogue: 0,0:56:57.82,0:56:59.92,Chinese,,0,0,0,,然后我给 a 赋一个新值
Dialogue: 0,0:57:00.96,0:57:08.20,English,,0,0,0,,And similarly a thread to will grab a copy of its of b and update that
Dialogue: 0,0:57:00.96,0:57:08.20,Chinese,,0,0,0,,类似地，线程 2 也将获得 b 的副本并（在缓存中）更新它
Dialogue: 0,0:57:09.68,0:57:13.98,English,,0,0,0,,And now if I do my two print statements
Dialogue: 0,0:57:09.68,0:57:13.98,Chinese,,0,0,0,,如果我限制执行这两条打印语句
Dialogue: 0,0:57:14.54,0:57:18.02,English,,0,0,0,,If thread two picks up the value from the memory
Dialogue: 0,0:57:14.54,0:57:18.02,Chinese,,0,0,0,,如果线程 2 从内存中获取 a 的值
Dialogue: 0,0:57:18.54,0:57:24.10,English,,0,0,0,,Not knowing that thread 1 as a modified copy of that value  then it would naturally print one
Dialogue: 0,0:57:18.54,0:57:24.10,Chinese,,0,0,0,,但它不知道线程 1 已经修改了 a 的副本的值，所以这里很自然输出 1
Dialogue: 0,0:57:24.96,0:57:30.44,English,,0,0,0,,And similarly if thread one picked up a copy of b from main memory it would print 100
Dialogue: 0,0:57:24.96,0:57:30.44,Chinese,,0,0,0,,类似地，如果线程 1 从内存中获取到 b 的副本，那么这里会输出 100
Dialogue: 0,0:57:30.54,0:57:36.90,English,,0,0,0,,So we'd see exactly this unallowable execution and the reason is
Dialogue: 0,0:57:30.54,0:57:36.90,Chinese,,0,0,0,,所以我们确实看到了不可能执行成功的情况，原因是
Dialogue: 0,0:57:37.48,0:57:42.36,English,,0,0,0,,Because each of these threads have their own private copies of these variables
Dialogue: 0,0:57:37.48,0:57:42.36,Chinese,,0,0,0,,因为每个线程中都存在这些变量的私有副本
Dialogue: 0,0:57:42.84,0:57:45.40,English,,0,0,0,,And they're not properly synchronized
Dialogue: 0,0:57:42.84,0:57:45.40,Chinese,,0,0,0,,并且它们没有正确得进行同步
Dialogue: 0,0:57:46.18,0:57:50.90,English,,0,0,0,,But you could see in a hardware scenario it would be easy to build this hardware and make that mistake
Dialogue: 0,0:57:46.18,0:57:50.90,Chinese,,0,0,0,,但你可以看到，在硬件场景中，你很容易构造出这种硬件并犯这样的错误
Dialogue: 0,0:57:52.30,0:57:55.92,English,,0,0,0,,So how does it work in a multi-core processor well
Dialogue: 0,0:57:52.30,0:57:55.92,Chinese,,0,0,0,,那么如何在多核处理器中处理好这种情况呢
Dialogue: 0,0:57:56.46,0:57:59.26,English,,0,0,0,,They have a trick they call it snoopy caches
Dialogue: 0,0:57:56.46,0:57:59.26,Chinese,,0,0,0,,这里会运用一个技巧，称之为「snoopy caches」
Dialogue: 0,0:58:00.34,0:58:05.72,English,,0,0,0,,And it's a little bit like the readers writers of synchronization that
Dialogue: 0,0:58:00.34,0:58:05.72,Chinese,,0,0,0,,它有点像读写者同步机制
Dialogue: 0,0:58:05.72,0:58:07.94,English,,0,0,0,,You're working on for your proxies
Dialogue: 0,0:58:05.72,0:58:07.94,Chinese,,0,0,0,,这些是由代理完成的
Dialogue: 0,0:58:08.56,0:58:13.28,English,,0,0,0,,That you want to make it so that if everyone's just reading some shared value
Dialogue: 0,0:58:08.56,0:58:13.28,Chinese,,0,0,0,,想要做到每个线程都会读取一些共享的值
Dialogue: 0,0:58:13.64,0:58:19.44,English,,0,0,0,,They should be able to get copies into their own caches  to optimize the performance of it
Dialogue: 0,0:58:13.64,0:58:19.44,Chinese,,0,0,0,,并且他们应该可以复制一份副本保存在自己的缓存中来优化性能
Dialogue: 0,0:58:20.26,0:58:24.96,English,,0,0,0,,But if one of them wants to write to it,it needs to get an exclusive copy of it
Dialogue: 0,0:58:20.26,0:58:24.96,Chinese,,0,0,0,,但如果其中一个线程想要对（某变量）进行写操作，他需要获得一份独有的副本
Dialogue: 0,0:58:25.62,0:58:27.58,English,,0,0,0,,And lock out any other thread
Dialogue: 0,0:58:25.62,0:58:27.58,Chinese,,0,0,0,,并且要对它加锁
Dialogue: 0,0:58:28.06,0:58:35.46,English,,0,0,0,,From accessing that either to read it or to write it from long enough to make the update
Dialogue: 0,0:58:28.06,0:58:35.46,Chinese,,0,0,0,,阻止其他线程对它进行读操作或者写操作，以便获取足够的时间对它完成更新
Dialogue: 0,0:58:36.42,0:58:37.56,English,,0,0,0,,And so
Dialogue: 0,0:58:36.42,0:58:37.56,Chinese,,0,0,0,,所以
Dialogue: 0,0:58:40.12,0:58:48.16,English,,0,0,0,,They have a protocol where they tag actually and these tags are at the level of cache lines typically
Dialogue: 0,0:58:40.12,0:58:48.16,Chinese,,0,0,0,,他们遵循一个协议，实际是一种标签，这些标签通常位于缓存行这个级别
Dialogue: 0,0:58:48.78,0:58:55.28,English,,0,0,0,,So the tagged cache line in main memory with its state and the typical state would be invalid
Dialogue: 0,0:58:48.78,0:58:55.28,Chinese,,0,0,0,,因此，如果内存中有缓存行被标记了，就意味着缓存行的状态为「无效」\n（不能被其他线程进行读写）
Dialogue: 0,0:58:56.12,0:58:59.52,English,,0,0,0,,It's shared or it's exclusive
Dialogue: 0,0:58:56.12,0:58:59.52,Chinese,,0,0,0,,它要么是共享的，要么是排他的
Dialogue: 0,0:59:00.14,0:59:06.74,English,,0,0,0,,So shared means that there can be a copies of it but they can only be read-only copies
Dialogue: 0,0:59:00.14,0:59:06.74,Chinese,,0,0,0,,所以「共享」意味着他们是只读副本
Dialogue: 0,0:59:07.34,0:59:14.08,English,,0,0,0,,And exclusive meaning that it's exclusively available to a single thread
Dialogue: 0,0:59:07.34,0:59:14.08,Chinese,,0,0,0,,「排他」意味着它仅供单个线程使用
Dialogue: 0,0:59:15.84,0:59:19.36,English,,0,0,0,,So this is built into them the hardware of a multi-core processor
Dialogue: 0,0:59:15.84,0:59:19.36,Chinese,,0,0,0,,它内置于多核处理器的硬件中
Dialogue: 0,0:59:20.08,0:59:21.44,English,,0,0,0,,So what will happen that is
Dialogue: 0,0:59:20.08,0:59:21.44,Chinese,,0,0,0,,那么，将会发生的事是
Dialogue: 0,0:59:22.76,0:59:30.18,English,,0,0,0,,In order to do a write to a thread 1 will acquire an exclusive copy of this element
Dialogue: 0,0:59:22.76,0:59:30.18,Chinese,,0,0,0,,为了对 a 进行写操作， 线程 1 会获得这个元素独有的拷贝
Dialogue: 0,0:59:30.18,0:59:34.88,English,,0,0,0,,And that actually tagging happens down here at the main memory and in the cache both
Dialogue: 0,0:59:30.18,0:59:34.88,Chinese,,0,0,0,,实际上，内存和缓存都会被标记（标记此变量为排他）
Dialogue: 0,0:59:37.86,0:59:44.22,English,,0,0,0,,Oh and similarly if thread 2 wants a to write to b
Dialogue: 0,0:59:37.86,0:59:44.22,Chinese,,0,0,0,,类似的，如果线程 2 想要对 b 进行写操作
Dialogue: 0,0:59:44.52,0:59:46.72,English,,0,0,0,,It must get an exclusive copy of that
Dialogue: 0,0:59:44.52,0:59:46.72,Chinese,,0,0,0,,它必须得到它的独有副本
Dialogue: 0,0:59:48.44,0:59:54.46,English,,0,0,0,,And then when the read occurs what happens is actually this cache miss
Dialogue: 0,0:59:48.44,0:59:54.46,Chinese,,0,0,0,,然后进行读操作时，此时的缓存缺失
Dialogue: 0,0:59:54.68,1:00:01.34,English,,0,0,0,,Will send out a signal on a bus a shared communication medium saying I want to read a
Dialogue: 0,0:59:54.68,1:00:01.34,Chinese,,0,0,0,,将会给共享通信总线发送一个信号，说我想要读取 a
Dialogue: 0,1:00:02.50,1:00:06.32,English,,0,0,0,,And instead of the main memory responding to it actually it will
Dialogue: 0,1:00:02.50,1:00:06.32,Chinese,,0,0,0,,但这次不会从内存中直接读取
Dialogue: 0,1:00:07.84,1:00:11.54,English,,0,0,0,,That result will be supplied by the other cache
Dialogue: 0,1:00:07.84,1:00:11.54,Chinese,,0,0,0,,而是由其他的缓存来提供对应的值
Dialogue: 0,1:00:12.42,1:00:16.54,English,,0,0,0,,And it will convert the state of this element to being a shared element
Dialogue: 0,1:00:12.42,1:00:16.54,Chinese,,0,0,0,,它会将该元素的状态设置为「共享」
Dialogue: 0,1:00:18.74,1:00:23.20,English,,0,0,0,,Locally but you'll see that the main memory element isn't updated yet it
Dialogue: 0,1:00:18.74,1:00:23.20,Chinese,,0,0,0,,但是你会看到内存中的元素还没被更新
Dialogue: 0,1:00:23.20,1:00:26.30,English,,0,0,0,,Goes through the whole write back protocol you've already seen
Dialogue: 0,1:00:23.20,1:00:26.30,Chinese,,0,0,0,,通过这个你已经看到了整个写入协议的流程
Dialogue: 0,1:00:26.82,1:00:29.50,English,,0,0,0,,And sometimes it will update that there's different implementations
Dialogue: 0,1:00:26.82,1:00:29.50,Chinese,,0,0,0,,有时它的更新有不同的实现
Dialogue: 0,1:00:30.16,1:00:31.88,English,,0,0,0,,But this is why it's called a snoopy cache is
Dialogue: 0,1:00:30.16,1:00:31.88,Chinese,,0,0,0,,但它被称为 snoopy cache 的原因是
Dialogue: 0,1:00:32.04,1:00:40.70,English,,0,0,0,,That it basically thread 2 is peeking into or getting it access to information That's available in thread 1 cache
Dialogue: 0,1:00:32.04,1:00:40.70,Chinese,,0,0,0,,基本上线程 2 想要读取线程 1 中已经缓存的信息
Dialogue: 0,1:00:43.10,1:00:48.96,English,,0,0,0,,And so now thread 2 will correctly get a copy of a
Dialogue: 0,1:00:43.10,1:00:48.96,Chinese,,0,0,0,,所以现在线程 2 获得了正确的 a 的拷贝
Dialogue: 0,1:00:49.46,1:00:50.98,English,,0,0,0,,That's in this shared state
Dialogue: 0,1:00:49.46,1:00:50.98,Chinese,,0,0,0,,处在共享状态
Dialogue: 0,1:00:51.62,1:00:57.30,English,,0,0,0,,And the same goes would be it will snoop over and thread two will one will get a readable copy
Dialogue: 0,1:00:51.62,1:00:57.30,Chinese,,0,0,0,,同样，线程 1 也获得了一个可读的副本
Dialogue: 0,1:00:57.88,1:00:59.92,English,,0,0,0,,These are now all marked as shared state
Dialogue: 0,1:00:57.88,1:00:59.92,Chinese,,0,0,0,,现在这些都标记为共享状态
Dialogue: 0,1:01:00.52,1:01:04.68,English,,0,0,0,,And so if either of them want to write
Dialogue: 0,1:01:00.52,1:01:04.68,Chinese,,0,0,0,,所以如果其中一个想要进行写操作
Dialogue: 0,1:01:04.68,1:01:08.74,English,,0,0,0,,They'd have to now basically get exclusive access to it
Dialogue: 0,1:01:04.68,1:01:08.74,Chinese,,0,0,0,,现在他们必须获得独占权限
Dialogue: 0,1:01:09.06,1:01:16.04,English,,0,0,0,,And that would have to then disable the copy in the other location
Dialogue: 0,1:01:09.06,1:01:16.04,Chinese,,0,0,0,,这样以来就会禁用其它地方副本的操作
Dialogue: 0,1:01:16.16,1:01:20.48,English,,0,0,0,,So you can imagine this protocol being non-trivial actually to get right and to implement
Dialogue: 0,1:01:16.16,1:01:20.48,Chinese,,0,0,0,,所以你可以想象，这个协议实现起来有一定的难度
Dialogue: 0,1:01:20.90,1:01:24.80,English,,0,0,0,,And it gets way more complicated than this with all the variations on it
Dialogue: 0,1:01:20.90,1:01:24.80,Chinese,,0,0,0,,因为它比较复杂，而且有很多的变化
Dialogue: 0,1:01:26.10,1:01:31.10,English,,0,0,0,,So but it's become the norm in multi-core hardware design
Dialogue: 0,1:01:26.10,1:01:31.10,Chinese,,0,0,0,,但是它已成为多核硬件设计的常态
Dialogue: 0,1:01:31.86,1:01:36.36,English,,0,0,0,,But it's actually part of the factor that limits the core count on a processor
Dialogue: 0,1:01:31.86,1:01:36.36,Chinese,,0,0,0,,实际上这也是限制处理器核心数量的因素之一
Dialogue: 0,1:01:37.08,1:01:43.32,English,,0,0,0,,Because just the hardware involved in keeping the consistency across the caches is non-trivial
Dialogue: 0,1:01:37.08,1:01:43.32,Chinese,,0,0,0,,因为从硬件上保持高速缓存之间一致性并非易事
Dialogue: 0,1:01:43.32,1:01:49.12,English,,0,0,0,,It has to work very fast we're talking at the cache rate access speeds
Dialogue: 0,1:01:43.32,1:01:49.12,Chinese,,0,0,0,,它的工作速度必须非常快，这里我们说的是缓存的访问速度
Dialogue: 0,1:01:49.88,1:01:52.30,English,,0,0,0,,So there's not a lot of time involved in there
Dialogue: 0,1:01:49.88,1:01:52.30,Chinese,,0,0,0,,所以在那里面的时间并不多
Dialogue: 0,1:01:52.42,1:01:54.96,English,,0,0,0,,So actually implementing this stuff making it run
Dialogue: 0,1:01:52.42,1:01:54.96,Chinese,,0,0,0,,所以实际上实现这个东西，让它运行
Dialogue: 0,1:01:55.42,1:02:01.70,English,,0,0,0,,Making it scale across say 8 cores,10 cores,16 cores is not a not a trivial thing
Dialogue: 0,1:01:55.42,1:02:01.70,Chinese,,0,0,0,,将其扩展为 8 核， 10 核， 16 核并不是一件容易的事
Dialogue: 0,1:02:02.20,1:02:07.72,English,,0,0,0,,But that that goes on in the background and so you can for most systems nowadays you can assume that
Dialogue: 0,1:02:02.20,1:02:07.72,Chinese,,0,0,0,,但是这种情况在后台发生，所以你假设现代大多数系统
Dialogue: 0,1:02:09.88,1:02:15.84,English,,0,0,0,,There's some memory consistency model that you can program to that's supported by the hardware of the system
Dialogue: 0,1:02:09.88,1:02:15.84,Chinese,,0,0,0,,是内存一致性模型，并且你可以根据系统的硬件支持的内存一致性模型来编程
Dialogue: 0,1:02:17.30,1:02:24.22,English,,0,0,0,,And that this serial serializability that's referred to as sort of the easiest to understand
Dialogue: 0,1:02:17.30,1:02:24.22,Chinese,,0,0,0,,而这种被称为最容易理解的是可序列化
Dialogue: 0,1:02:24.34,1:02:26.28,English,,0,0,0,,There's others at a little bit more nuanced
Dialogue: 0,1:02:24.34,1:02:26.28,Chinese,,0,0,0,,还有其他一些，只有细微差别
Dialogue: 0,1:02:29.04,1:02:33.40,English,,0,0,0,,Well guess that fell off the bottom here and doesn't seem right
Dialogue: 0,1:02:29.04,1:02:33.40,Chinese,,0,0,0,,好吧，到底了，好像不对
Dialogue: 0,1:02:42.30,1:02:42.98,English,,0,0,0,,That's it
Dialogue: 0,1:02:42.30,1:02:42.98,Chinese,,0,0,0,,好了
Dialogue: 0,1:02:43.88,1:02:46.80,English,,0,0,0,,Okay so just to wrap that up then
Dialogue: 0,1:02:43.88,1:02:46.80,Chinese,,0,0,0,,我们重温一下
Dialogue: 0,1:02:48.56,1:02:50.82,English,,0,0,0,,It gives you a flavor of and
Dialogue: 0,1:02:48.56,1:02:50.82,Chinese,,0,0,0,,它给你一种想法就是
Dialogue: 0,1:02:52.10,1:02:57.62,English,,0,0,0,,You can see that getting programs to run fast through multi-threading is not easy
Dialogue: 0,1:02:52.10,1:02:57.62,Chinese,,0,0,0,,你知道想要通过多线程让程序加速运行并不容易
Dialogue: 0,1:02:58.16,1:03:02.98,English,,0,0,0,,You often have to rewrite your application,you have to think about the algorithm,you have to worry about debugging
Dialogue: 0,1:02:58.16,1:03:02.98,Chinese,,0,0,0,,你经常需要重写你的应用程序，设计算法，调试代码
Dialogue: 0,1:03:03.52,1:03:06.52,English,,0,0,0,,It as you've already discovered at both the
Dialogue: 0,1:03:03.52,1:03:06.52,Chinese,,0,0,0,,或许你已经发现
Dialogue: 0,1:03:07.28,1:03:12.28,English,,0,0,0,,The shell lab and the proxy lab that concurrency where you can't predict the order of events
Dialogue: 0,1:03:07.28,1:03:12.28,Chinese,,0,0,0,,「shell lab」 和「proxy lab」的并发事件，你无法预测他们的执行顺序
Dialogue: 0,1:03:12.88,1:03:16.30,English,,0,0,0,,Makes it much more difficult to debug code
Dialogue: 0,1:03:12.88,1:03:16.30,Chinese,,0,0,0,,这让调试代码变得非常困难
Dialogue: 0,1:03:16.80,1:03:18.62,English,,0,0,0,,So all these factors come in
Dialogue: 0,1:03:16.80,1:03:18.62,Chinese,,0,0,0,,所以当这些因素出现时
Dialogue: 0,1:03:20.18,1:03:24.30,English,,0,0,0,,And you have to have some understanding of the underlying mechanisms that are used
Dialogue: 0,1:03:20.18,1:03:24.30,Chinese,,0,0,0,,你必须对潜在的机制有一定的了解
Dialogue: 0,1:03:24.98,1:03:27.02,English,,0,0,0,,And what their performance implications are
Dialogue: 0,1:03:24.98,1:03:27.02,Chinese,,0,0,0,,以及它们对性能的影响是什么
Dialogue: 0,1:03:27.66,1:03:30.12,English,,0,0,0,,So in particular let me just observe here that
Dialogue: 0,1:03:27.66,1:03:30.12,Chinese,,0,0,0,,因此，我要在此特别指出
Dialogue: 0,1:03:32.58,1:03:34.98,English,,0,0,0,,If I'm like doing synchronization
Dialogue: 0,1:03:32.58,1:03:34.98,Chinese,,0,0,0,,如果我喜欢做同步
Dialogue: 0,1:03:37.36,1:03:43.06,English,,0,0,0,,Across threads like you saw that original one where they are fighting over this global variable
Dialogue: 0,1:03:37.36,1:03:43.06,Chinese,,0,0,0,,像之前的那个版本，他们正在争夺这个全局变量
Dialogue: 0,1:03:43.58,1:03:44.98,English,,0,0,0,, psum whatever it was called
Dialogue: 0,1:03:43.58,1:03:44.98,Chinese,,0,0,0,, psum 无论它叫什么
Dialogue: 0,1:03:46.12,1:03:48.24,English,,0,0,0,,You can imagine these the caches
Dialogue: 0,1:03:46.12,1:03:48.24,Chinese,,0,0,0,,你可以想象这些缓存......
Dialogue: 0,1:03:48.66,1:03:57.48,English,,0,0,0,,In this battle with each other to try and get exclusive access to this single memory of value
Dialogue: 0,1:03:48.66,1:03:57.48,Chinese,,0,0,0,,在这场与对方的战斗中，都在试图去抢占单个内存值的独占访问权限
Dialogue: 0,1:03:58.34,1:04:04.04,English,,0,0,0,,And because each one is running as fast as it possibly can
Dialogue: 0,1:03:58.34,1:04:04.04,Chinese,,0,0,0,,并且因为每一个缓存（访问）都在尽力的变快
Dialogue: 0,1:04:04.20,1:04:11.20,English,,0,0,0,,But each one requires getting exclusive copy writing to it and releasing it
Dialogue: 0,1:04:04.20,1:04:11.20,Chinese,,0,0,0,,但是每个线程必须获得独占权限之后才能进行复制，写入，释放
Dialogue: 0,1:04:11.32,1:04:15.98,English,,0,0,0,,So that locking mechanism is flying back and forth between these caches
Dialogue: 0,1:04:11.32,1:04:15.98,Chinese,,0,0,0,,所以锁定机制在这些缓存之间来回周旋着
Dialogue: 0,1:04:16.68,1:04:18.72,English,,0,0,0,,And it's really not very fast so
Dialogue: 0,1:04:16.68,1:04:18.72,Chinese,,0,0,0,,它真的不是很快
Dialogue: 0,1:04:19.16,1:04:22.52,English,,0,0,0,,That's the kind of thing is why
Dialogue: 0,1:04:19.16,1:04:22.52,Chinese,,0,0,0,,这就是为什么......
Dialogue: 0,1:04:24.02,1:04:29.18,English,,0,0,0,,And also you know as an application programmer you're making calls
Dialogue: 0,1:04:24.02,1:04:29.18,Chinese,,0,0,0,,而且你知道作为应用程序，你调用
Dialogue: 0,1:04:30.18,1:04:35.50,English,,0,0,0,,Semaphore call bounces you up into the OS kernel which is a cost involved
Dialogue: 0,1:04:30.18,1:04:35.50,Chinese,,0,0,0,,信号量访问操作系统内核会有一些代价
Dialogue: 0,1:04:36.20,1:04:43.04,English,,0,0,0,,So this thing has all the bad all the things that make programs not run the way you really like them to
Dialogue: 0,1:04:36.20,1:04:43.04,Chinese,,0,0,0,,所以这东西是有缺点的，让程序不能按照你喜欢的方式运行
Dialogue: 0,1:04:43.52,1:04:48.48,English,,0,0,0,,So that's one of the challenges in parallel programming is how do you actually
Dialogue: 0,1:04:43.52,1:04:48.48,Chinese,,0,0,0,,因此，并行编程的挑战之一就是
Dialogue: 0,1:04:49.16,1:04:57.24,English,,0,0,0,,Make use of the parallelism that's there Without getting bogged down by the cost of the various mechanisms of control
Dialogue: 0,1:04:49.16,1:04:57.24,Chinese,,0,0,0,,你如何实际利用存在的并行性，而不被各种控制机制的成本所困住
Dialogue: 0,1:04:58.86,1:05:03.54,English,,0,0,0,,Oh so anyways this is part of what you have to appreciate and understand as a programmer
Dialogue: 0,1:04:58.86,1:05:03.54,Chinese,,0,0,0,,所以无论如何，这是作为一个程序员，你必须接受和理解的部分
Dialogue: 0,1:05:04.00,1:05:08.56,English,,0,0,0,,Is how these things work at a level deep enough that you'll have some sense of
Dialogue: 0,1:05:04.00,1:05:08.56,Chinese,,0,0,0,,对这些东西的运行机制了解足够深之后，你会有一定的感悟
Dialogue: 0,1:05:08.56,1:05:13.28,English,,0,0,0,,What makes programs run faster or slower where the mistakes could want
Dialogue: 0,1:05:08.56,1:05:13.28,Chinese,,0,0,0,,洞悉什么会让程序运行的更快或者更慢，什么情况会出错
Dialogue: 0,1:05:14.98,1:05:18.62,English,,0,0,0,,So that's just a little flavor of a much bigger topic
Dialogue: 0,1:05:14.98,1:05:18.62,Chinese,,0,0,0,,所以，这只是为了让你们了解有更广阔的话题
Dialogue: 0,1:05:19.48,1:05:20.48,English,,0,0,0,,So that's it for today
Dialogue: 0,1:05:19.48,1:05:20.48,Chinese,,0,0,0,,今天的课就到这里
