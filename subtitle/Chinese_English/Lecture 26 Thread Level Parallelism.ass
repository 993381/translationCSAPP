[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 26 Thread Level Parallelism.mp4
Video File: ../../../../Desktop/csapp/Lecture 26 Thread Level Parallelism.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 1534
Active Line: 1541
Video Position: 117257

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,44,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:01.12,English,,0,0,0,,Hello everyone
Dialogue: 0,0:00:00.00,0:00:01.12,Chinese,,0,0,0,,大家好
Dialogue: 0,0:00:03.78,0:00:08.28,English,,0,0,0,,Interesting,how far fewer seats are filled than at the beginning of the course
Dialogue: 0,0:00:03.78,0:00:08.28,Chinese,,0,0,0,,有趣的是，来的同学比课程刚开始时少很多
Dialogue: 0,0:00:09.70,0:00:14.56,English,,0,0,0,,So that of course we're in the final stretch of this course
Dialogue: 0,0:00:09.70,0:00:14.56,Chinese,,0,0,0,,显然，我们已经到了课程的最后阶段
Dialogue: 0,0:00:15.14,0:00:16.72,English,,0,0,0,,You're working on the last lab
Dialogue: 0,0:00:15.14,0:00:16.72,Chinese,,0,0,0,,你正在做最后一个 Lab
Dialogue: 0,0:00:17.44,0:00:23.58,English,,0,0,0,,And the material that we're covering both this lecture and next lecture are not on the exam
Dialogue: 0,0:00:17.44,0:00:23.58,Chinese,,0,0,0,,本次讲座和下一次讲座中所涉及的资料都不在考试中
Dialogue: 0,0:00:23.58,0:00:25.02,English,,0,0,0,,And you don't need them for your lab
Dialogue: 0,0:00:23.58,0:00:25.02,Chinese,,0,0,0,,而且你正在做的 Lab 也不需要这些内容
Dialogue: 0,0:00:25.02,0:00:28.38,English,,0,0,0,,So at some level you could just to know and skip it all
Dialogue: 0,0:00:25.02,0:00:28.38,Chinese,,0,0,0,,所以在某种程度上你可以跳过本讲内容
Dialogue: 0,0:00:28.38,0:00:31.40,English,,0,0,0,,And if your only purpose in taking this course is to pass it
Dialogue: 0,0:00:28.38,0:00:31.40,Chinese,,0,0,0,,如果你参加这门课程的目的仅仅是通过考试的话
Dialogue: 0,0:00:33.14,0:00:37.52,English,,0,0,0,,Or to get some grade in it and that's it well go ahead to now
Dialogue: 0,0:00:33.14,0:00:37.52,Chinese,,0,0,0,,或者仅仅为了刷学分，那你现在可以离开了
Dialogue: 0,0:00:38.16,0:00:44.90,English,,0,0,0,,But on the other hand the material we're talking about is very relevant to where computers are today
Dialogue: 0,0:00:38.16,0:00:44.90,Chinese,,0,0,0,,但另一方面，我们今天要讨论的内容，与现阶段的计算机
Dialogue: 0,0:00:44.90,0:00:46.38,English,,0,0,0,,And where they're going in the future
Dialogue: 0,0:00:44.90,0:00:46.38,Chinese,,0,0,0,,以及未来计算机的发展状态，都息息相关
Dialogue: 0,0:00:46.88,0:00:49.28,English,,0,0,0,,And so if you think about the longer term
Dialogue: 0,0:00:46.88,0:00:49.28,Chinese,,0,0,0,,所以，如果从长远角度考虑
Dialogue: 0,0:00:49.28,0:00:54.02,English,,0,0,0,,And whatever your investment is in the computer industry and computer technology is
Dialogue: 0,0:00:49.28,0:00:54.02,Chinese,,0,0,0,,无论你想投身到计算机工业界或学术界
Dialogue: 0,0:00:54.54,0:00:56.86,English,,0,0,0,,Then I think you'll find these very worthwhile
Dialogue: 0,0:00:54.54,0:00:56.86,Chinese,,0,0,0,,我认为你会发现这些内容都非常有意义
Dialogue: 0,0:00:57.48,0:01:01.36,English,,0,0,0,,But so think of this more as the icing on the cake
Dialogue: 0,0:00:57.48,0:01:01.36,Chinese,,0,0,0,,所以可以认为这些内容更多是锦上添花
Dialogue: 0,0:01:01.40,0:01:05.28,English,,0,0,0,,You've learned the hard stuff you've done the grinding part
Dialogue: 0,0:01:01.40,0:01:05.28,Chinese,,0,0,0,,你已经学习了困难的部分
Dialogue: 0,0:01:05.70,0:01:12.44,English,,0,0,0,,And now you get to think beyond the sort of narrow confines of the course material and think bigger
Dialogue: 0,0:01:05.70,0:01:12.44,Chinese,,0,0,0,,现在，你可以不局限于课本的内容，进行更广阔的思考
Dialogue: 0,0:01:12.50,0:01:18.00,English,,0,0,0,,But that's really the way you should be viewing this lecture and the last lecture which will be on Thursday
Dialogue: 0,0:01:12.50,0:01:18.00,Chinese,,0,0,0,,这是你学习本次课和下周最后一次课的视角。
Dialogue: 0,0:01:18.68,0:01:21.30,English,,0,0,0,,So today what we're going to talk about is parallelism
Dialogue: 0,0:01:18.68,0:01:21.30,Chinese,,0,0,0,,所以今天我们要讨论的是并行性
Dialogue: 0,0:01:22.98,0:01:24.20,English,,0,0,0,,And the issue is that...
Dialogue: 0,0:01:22.98,0:01:24.20,Chinese,,0,0,0,,问题是 ......
Dialogue: 0,0:01:25.98,0:01:26.86,English,,0,0,0,,That
Dialogue: 0,0:01:25.98,0:01:26.86,Chinese,,0,0,0,,是
Dialogue: 0,0:01:28.12,0:01:28.54,English,,0,0,0,,Wow
Dialogue: 0,0:01:28.12,0:01:28.54,Chinese,,0,0,0,,哇
Dialogue: 0,0:01:33.18,0:01:37.26,English,,0,0,0,,That PowerPoint is a product made by a certain company in Seattle that
Dialogue: 0,0:01:33.18,0:01:37.26,Chinese,,0,0,0,, PowerPoint 是由西雅图的某家公司（微软）的产品
Dialogue: 0,0:01:38.08,0:01:40.08,English,,0,0,0,,It's not always reliable but
Dialogue: 0,0:01:38.08,0:01:40.08,Chinese,,0,0,0,,显然它不是很稳定
Dialogue: 0,0:01:41.04,0:01:49.30,English,,0,0,0,,The issue is as you know nowadays when you buy a computer you don't get just one CPU on the processor chip
Dialogue: 0,0:01:41.04,0:01:49.30,Chinese,,0,0,0,,问题是如今你购买的电脑的处理器上不会只有一个 CPU
Dialogue: 0,0:01:49.38,0:01:52.42,English,,0,0,0,,You have at least two on a typical laptop
Dialogue: 0,0:01:49.38,0:01:52.42,Chinese,,0,0,0,,一般你的笔记本上就至少有两个
Dialogue: 0,0:01:53.10,0:02:00.50,English,,0,0,0,,Even my phone has two cores in it and as well as four graphic processing units
Dialogue: 0,0:01:53.10,0:02:00.50,Chinese,,0,0,0,,甚至连我的手机都有两个 CPU 以及四个图形处理单元
Dialogue: 0,0:02:01.34,0:02:07.80,English,,0,0,0,,And a typical the next generation of iPad will be a six core processor
Dialogue: 0,0:02:01.34,0:02:07.80,Chinese,,0,0,0,,而下一代 iPad 将拥有六核处理器
Dialogue: 0,0:02:07.92,0:02:15.90,English,,0,0,0,,So these have become not just the sort of specialized domain of high machines
Dialogue: 0,0:02:07.92,0:02:15.90,Chinese,,0,0,0,,所以这些（多处理器）不仅仅限于高规格的计算机
Dialogue: 0,0:02:16.00,0:02:18.60,English,,0,0,0,,But actually there all the time
Dialogue: 0,0:02:16.00,0:02:18.60,Chinese,,0,0,0,,也会在日常出现
Dialogue: 0,0:02:19.06,0:02:25.80,English,,0,0,0,,And actually we'll talk some next time why is it that instead of having one fast computer
Dialogue: 0,0:02:19.06,0:02:25.80,Chinese,,0,0,0,,实际上我们下次会谈到为什么不是采用一个极快的单核计算机
Dialogue: 0,0:02:25.80,0:02:31.20,English,,0,0,0,,You get two medium size medium performance processors on a chip or more
Dialogue: 0,0:02:25.80,0:02:31.20,Chinese,,0,0,0,,而是使用两个或多个中等速度的多核处理器
Dialogue: 0,0:02:31.68,0:02:35.60,English,,0,0,0,,And that that's actually a really interesting technology issue that I'll talk about next time
Dialogue: 0,0:02:31.68,0:02:35.60,Chinese,,0,0,0,,这实际上是一个非常有趣的技术问题，我将在下次讨论
Dialogue: 0,0:02:36.18,0:02:39.96,English,,0,0,0,,But it's the way it is,so you can think of it when you write a program
Dialogue: 0,0:02:36.18,0:02:39.96,Chinese,,0,0,0,,但它就是这样的，所以当你写一个程序
Dialogue: 0,0:02:41.92,0:02:44.10,English,,0,0,0,,Ah and it runs as a single thread
Dialogue: 0,0:02:41.92,0:02:44.10,Chinese,,0,0,0,,并且是单线程运行时
Dialogue: 0,0:02:44.50,0:02:50.40,English,,0,0,0,,Then you're basically not making use of the computing resources that you have available to you
Dialogue: 0,0:02:44.50,0:02:50.40,Chinese,,0,0,0,,所以你基本上没有（完全）运用能供你使用的计算资源
Dialogue: 0,0:02:51.10,0:02:56.98,English,,0,0,0,,So the natural thing is well could we make our programs run faster by doing multiple threads
Dialogue: 0,0:02:51.10,0:02:56.98,Chinese,,0,0,0,,因此，可以很自然地通过使用多线程，让程序跑的更快
Dialogue: 0,0:02:57.60,0:02:58.64,English,,0,0,0,,So you've already learned
Dialogue: 0,0:02:57.60,0:02:58.64,Chinese,,0,0,0,,所以你已经知道了
Dialogue: 0,0:02:59.16,0:03:04.52,English,,0,0,0,,Or you're in the process of applying a multi-threaded programming
Dialogue: 0,0:02:59.16,0:03:04.52,Chinese,,0,0,0,,或者说你正在使用多线程编程
Dialogue: 0,0:03:05.00,0:03:06.10,English,,0,0,0,,As a way to
Dialogue: 0,0:03:05.00,0:03:06.10,Chinese,,0,0,0,,作为一种
Dialogue: 0,0:03:09.58,0:03:13.88,English,,0,0,0,,Deal with a concurrency of external events
Dialogue: 0,0:03:09.58,0:03:13.88,Chinese,,0,0,0,,处理外部事件并发性的方式
Dialogue: 0,0:03:14.08,0:03:17.82,English,,0,0,0,,There's multiple clients who want to make use of a server
Dialogue: 0,0:03:14.08,0:03:17.82,Chinese,,0,0,0,,有多个客户想要使用服务器
Dialogue: 0,0:03:18.24,0:03:22.32,English,,0,0,0,,And instead of serving one and then another and then another if you can handle them all
Dialogue: 0,0:03:18.24,0:03:22.32,Chinese,,0,0,0,,你可以同时处理他们的请求，而不是挨个处理
Dialogue: 0,0:03:23.00,0:03:25.80,English,,0,0,0,,It's sort of a an external use of concurrency
Dialogue: 0,0:03:23.00,0:03:25.80,Chinese,,0,0,0,,这是某种外部访问的并发性
Dialogue: 0,0:03:26.60,0:03:29.56,English,,0,0,0,,But what we'll talk about today is more internal use
Dialogue: 0,0:03:26.60,0:03:29.56,Chinese,,0,0,0,,但我们今天要讨论的更多是内部请求
Dialogue: 0,0:03:29.82,0:03:37.40,English,,0,0,0,,Can  make use of multiple threads running on multiple cores to make a program run a single program run faster
Dialogue: 0,0:03:29.82,0:03:37.40,Chinese,,0,0,0,,可以利用在多个内核上运行的多个线程，使运行单个程序更快
Dialogue: 0,0:03:38.16,0:03:41.14,English,,0,0,0,,And the message behind that is yes but
Dialogue: 0,0:03:38.16,0:03:41.14,Chinese,,0,0,0,,其背后的含义是肯定但有条件的。
Dialogue: 0,0:03:41.86,0:03:50.02,English,,0,0,0,,And what mean is it is truly possible and people spend a lot of time making programs run faster by using multiple threads
Dialogue: 0,0:03:41.86,0:03:50.02,Chinese,,0,0,0,,人们确实可以通过花大量时间使程序多线程运行，从而变快
Dialogue: 0,0:03:50.50,0:03:53.76,English,,0,0,0,,But it's harder than you'd think it should be and
Dialogue: 0,0:03:50.50,0:03:53.76,Chinese,,0,0,0,,但它比你想象的要难得多
Dialogue: 0,0:03:53.98,0:03:57.92,English,,0,0,0,,It's fraught with as you probably already experienced programming bugs
Dialogue: 0,0:03:53.98,0:03:57.92,Chinese,,0,0,0,,它可能存在着许多的 bug
Dialogue: 0,0:03:58.40,0:04:04.04,English,,0,0,0,,But also it's just really darn hard to get the kind of performance out of a multi-core processor
Dialogue: 0,0:03:58.40,0:04:04.04,Chinese,,0,0,0,,但是，从多核处理器中获得这种你想得到的性能提升
Dialogue: 0,0:04:04.06,0:04:06.34,English,,0,0,0,,That you should would think it'd be available
Dialogue: 0,0:04:04.06,0:04:06.34,Chinese,,0,0,0,,真的很难
Dialogue: 0,0:04:06.86,0:04:08.12,English,,0,0,0,,So we'll talk about some of that
Dialogue: 0,0:04:06.86,0:04:08.12,Chinese,,0,0,0,,所以我们将讨论其中的一些内容
Dialogue: 0,0:04:09.48,0:04:12.72,English,,0,0,0,,And then we'll finish it up a little bit understanding of
Dialogue: 0,0:04:09.48,0:04:12.72,Chinese,,0,0,0,,然后我们将对它进行一些了解
Dialogue: 0,0:04:13.28,0:04:20.46,English,,0,0,0,,How when you writing concurrent programs you want to think about the state of memory
Dialogue: 0,0:04:13.28,0:04:20.46,Chinese,,0,0,0,,如何在编写并发程序时考虑内存状态
Dialogue: 0,0:04:20.92,0:04:27.78,English,,0,0,0,,And how that's a challenge for multi-core processors or in fact any concurrent system
Dialogue: 0,0:04:20.92,0:04:27.78,Chinese,,0,0,0,,这对于多核处理器或实际上任何并发系统来说都是一个挑战
Dialogue: 0,0:04:30.58,0:04:37.90,English,,0,0,0,,So there's actually two sources of concurrency on a modern processor multiple cores
Dialogue: 0,0:04:30.58,0:04:37.90,Chinese,,0,0,0,,因此，在现代多核处理器上实际上有两个并发源
Dialogue: 0,0:04:37.96,0:04:43.08,English,,0,0,0,,Which is you have actually a multiple cpus on a single chip
Dialogue: 0,0:04:37.96,0:04:43.08,Chinese,,0,0,0,,你在一块芯片上实际上有多个 cpus
Dialogue: 0,0:04:43.54,0:04:45.48,English,,0,0,0,,But there's also something called hyper-threading
Dialogue: 0,0:04:43.54,0:04:45.48,Chinese,,0,0,0,,但也有一种称为超线程的东西
Dialogue: 0,0:04:46.18,0:04:48.54,English,,0,0,0,,Which is in my experience is less useful
Dialogue: 0,0:04:46.18,0:04:48.54,Chinese,,0,0,0,,根据我的经验，这不太有用
Dialogue: 0,0:04:48.98,0:04:50.02,English,,0,0,0,,But let me go through this
Dialogue: 0,0:04:48.98,0:04:50.02,Chinese,,0,0,0,,但让我来看看
Dialogue: 0,0:04:50.50,0:04:56.36,English,,0,0,0,,So this is what a typical modern processor looks like processor chip
Dialogue: 0,0:04:50.50,0:04:56.36,Chinese,,0,0,0,,所以这就是典型的现代处理器芯片看起来的样子
Dialogue: 0,0:04:57.04,0:04:58.96,English,,0,0,0,,Is that there's actually on a single chip
Dialogue: 0,0:04:57.04,0:04:58.96,Chinese,,0,0,0,,那是真的在一块芯片上吗？
Dialogue: 0,0:04:59.66,0:05:03.28,English,,0,0,0,,There's multiple independent CPUs
Dialogue: 0,0:04:59.66,0:05:03.28,Chinese,,0,0,0,,有多个独立的 CPU
Dialogue: 0,0:05:04.72,0:05:09.32,English,,0,0,0,,And each of them has some part of the cache hierarchy
Dialogue: 0,0:05:04.72,0:05:09.32,Chinese,,0,0,0,,并且它们每一个都具有缓存结构的一部分
Dialogue: 0,0:05:10.44,0:05:15.28,English,,0,0,0,,Which is private to that particular core
Dialogue: 0,0:05:10.44,0:05:15.28,Chinese,,0,0,0,,这部分缓存是对每个 CPU 是私有的
Dialogue: 0,0:05:15.94,0:05:20.04,English,,0,0,0,,And then there is another part of the cache hierarchy that's shared across cores
Dialogue: 0,0:05:15.94,0:05:20.04,Chinese,,0,0,0,,然后这部分是共享的缓存结构
Dialogue: 0,0:05:20.60,0:05:23.66,English,,0,0,0,,And then they all have a common interface to main memory
Dialogue: 0,0:05:20.60,0:05:23.66,Chinese,,0,0,0,,然后他们都有一个与主内存的通用接口
Dialogue: 0,0:05:25.28,0:05:28.34,English,,0,0,0,,So if these cores are running and this is what happens a lot is
Dialogue: 0,0:05:25.28,0:05:28.34,Chinese,,0,0,0,,因此，如果这些核心正在运行，那么就会发生很多事情
Dialogue: 0,0:05:28.42,0:05:32.28,English,,0,0,0,,They're running programs that are completely independent have nothing to do with each
Dialogue: 0,0:05:28.42,0:05:32.28,Chinese,,0,0,0,,他们运行各自完全独立，互不相关的程序
Dialogue: 0,0:05:32.78,0:05:36.90,English,,0,0,0,,Other then they more or less just exist and run and they're happy as can be
Dialogue: 0,0:05:32.78,0:05:36.90,Chinese,,0,0,0,,除此之外，他们各自存在和运行着
Dialogue: 0,0:05:36.90,0:05:40.06,English,,0,0,0,,They are caching parts of their own state
Dialogue: 0,0:05:36.90,0:05:40.06,Chinese,,0,0,0,,他们缓存着各自的状态
Dialogue: 0,0:05:40.70,0:05:49.42,English,,0,0,0,,And you know sometimes this cache will get polluted by the junk from other programs in terms of performance
Dialogue: 0,0:05:40.70,0:05:49.42,Chinese,,0,0,0,,而且在性能方面，有时这个缓存会其他程序的垃圾污染
Dialogue: 0,0:05:49.66,0:05:51.74,English,,0,0,0,,But it will matter with functionality
Dialogue: 0,0:05:49.66,0:05:51.74,Chinese,,0,0,0,,但这对功能性也有影响
Dialogue: 0,0:05:52.46,0:05:56.52,English,,0,0,0,,The trick when you're trying to do multi-core programming as a parallel computing thing
Dialogue: 0,0:05:52.46,0:05:56.52,Chinese,,0,0,0,,当你使用多核程序来进行并行计算时，诀窍是
Dialogue: 0,0:05:56.62,0:06:05.30,English,,0,0,0,,Somehow getting all these cores working on parts of different parts of a single problem in a way that
Dialogue: 0,0:05:56.62,0:06:05.30,Chinese,,0,0,0,,通过某种方式，让这些核心处理单个问题的不同部分
Dialogue: 0,0:06:06.52,0:06:09.12,English,,0,0,0,,Makes it so that you get the performance out of it
Dialogue: 0,0:06:06.52,0:06:09.12,Chinese,,0,0,0,,从而获得所需性能
Dialogue: 0,0:06:09.16,0:06:13.72,English,,0,0,0,,They don't spend all their time basically arguing with each other about who has access to what
Dialogue: 0,0:06:09.16,0:06:13.72,Chinese,,0,0,0,,他们并没有把所有的时间花在争论谁可以访问什么
Dialogue: 0,0:06:14.70,0:06:18.70,English,,0,0,0,,And also they're not stepping over each other and messing up each other's state
Dialogue: 0,0:06:14.70,0:06:18.70,Chinese,,0,0,0,,而且他们也没有干扰对方，弄乱对方的状态
Dialogue: 0,0:06:22.22,0:06:28.78,English,,0,0,0,,So hyper threading is a little bit more into the deep works of how a processor operates
Dialogue: 0,0:06:22.22,0:06:28.78,Chinese,,0,0,0,,因此，超线程更多涉及到一些底层工作，如处理器如何运行
Dialogue: 0,0:06:29.46,0:06:35.06,English,,0,0,0,,You'll recall from the lecture on a performance or what's chapter 5 of the book
Dialogue: 0,0:06:29.46,0:06:35.06,Chinese,,0,0,0,,你可以回忆下之前的视频或者查看书的第五章
Dialogue: 0,0:06:35.76,0:06:43.86,English,,0,0,0,,That a modern microprocessor looks absolutely nothing like the model that you get by looking at assembly code instructions
Dialogue: 0,0:06:35.76,0:06:43.86,Chinese,,0,0,0,,现代微处理器看起来绝对不像汇编代码那样
Dialogue: 0,0:06:44.00,0:06:47.20,English,,0,0,0,,The model of assembly code is you execute one instruction
Dialogue: 0,0:06:44.00,0:06:47.20,Chinese,,0,0,0,,汇编代码的模型是执行一条指令
Dialogue: 0,0:06:47.78,0:06:50.65,English,,0,0,0,,Then you execute the next one then you execute the next one
Dialogue: 0,0:06:47.78,0:06:50.65,Chinese,,0,0,0,,然后执行下一个，然后执行下一个
Dialogue: 0,0:06:51.02,0:06:52.86,English,,0,0,0,,Modern processors don't do that at all
Dialogue: 0,0:06:51.02,0:06:52.86,Chinese,,0,0,0,,现代处理器根本不这样做
Dialogue: 0,0:06:53.34,0:06:59.00,English,,0,0,0,,They haven't done it for...well they haven't done it that way for 30 years
Dialogue: 0,0:06:53.34,0:06:59.00,Chinese,,0,0,0,,他们没有这样做 ...... 他们 30 年来没有这样做过
Dialogue: 0,0:06:59.60,0:07:04.06,English,,0,0,0,,And since 1995 so since 20 years
Dialogue: 0,0:06:59.60,0:07:04.06,Chinese,,0,0,0,,自 1995 年以来，自 20 年以来
Dialogue: 0,0:07:04.60,0:07:06.60,English,,0,0,0,,They do it in this totally different way
Dialogue: 0,0:07:04.60,0:07:06.60,Chinese,,0,0,0,,他们以完全不同的方式来设计处理器结构
Dialogue: 0,0:07:07.04,0:07:12.28,English,,0,0,0,,Which is sometimes referred to as out of order processing and so just real quickly
Dialogue: 0,0:07:07.04,0:07:12.28,Chinese,,0,0,0,,这有时被称为无序处理
Dialogue: 0,0:07:13.14,0:07:16.36,English,,0,0,0,,The the basic idea is on the processor chip
Dialogue: 0,0:07:13.14,0:07:16.36,Chinese,,0,0,0,,基本思路是在处理器芯片上
Dialogue: 0,0:07:16.36,0:07:20.78,English,,0,0,0,,There's multiple functional units that are capable of doing different types of operation
Dialogue: 0,0:07:16.36,0:07:20.78,Chinese,,0,0,0,,有多个功能单元能够执行不同类型的操作
Dialogue: 0,0:07:21.24,0:07:26.76,English,,0,0,0,,There's ones for integer arithmetic these ones for floating-point arithmetic and so forth
Dialogue: 0,0:07:21.24,0:07:26.76,Chinese,,0,0,0,,有一些用于整数运算，有些用于浮点运算等等
Dialogue: 0,0:07:27.14,0:07:32.76,English,,0,0,0,,And then there's separate blocks that interface to the memory actually to the cache memories
Dialogue: 0,0:07:27.14,0:07:32.76,Chinese,,0,0,0,,然后这些单独的块，它们实际上与高速缓存存储器连接
Dialogue: 0,0:07:33.38,0:07:38.96,English,,0,0,0,,And they're both loading meaning reading from the memory and storing writing out to memory
Dialogue: 0,0:07:33.38,0:07:38.96,Chinese,,0,0,0,,而且它们都是从内存中读取数据并将写入到内存中
Dialogue: 0,0:07:39.76,0:07:43.14,English,,0,0,0,,But these units are sort of operate independently
Dialogue: 0,0:07:39.76,0:07:43.14,Chinese,,0,0,0,,但这些单位块有点像独立运作
Dialogue: 0,0:07:43.60,0:07:50.88,English,,0,0,0,,And what happens is there's a block of logic which is actually enormous with huge block of logic in an x86 processor
Dialogue: 0,0:07:43.60,0:07:50.88,Chinese,,0,0,0,,接下来会发生的是，在x 86 处理器中存在大量逻辑块，其中存在巨大的逻辑块
Dialogue: 0,0:07:51.44,0:07:54.40,English,,0,0,0,,That reads the instructions out of the instruction stream
Dialogue: 0,0:07:51.44,0:07:54.40,Chinese,,0,0,0,,它从指令流中读取指令
Dialogue: 0,0:07:54.86,0:08:01.16,English,,0,0,0,,Rips them apart into little pieces， keeps track of data dependencies and control dependencies
Dialogue: 0,0:07:54.86,0:08:01.16,Chinese,,0,0,0,,将它们分成小，并可以跟踪数据依赖性和控制依赖性
Dialogue: 0,0:08:01.66,0:08:07.92,English,,0,0,0,,And then schedules all the various operations in your program on these different functional units
Dialogue: 0,0:08:01.66,0:08:07.92,Chinese,,0,0,0,,然后在这些不同的功能单元上，分配程序的各自操作指令
Dialogue: 0,0:08:08.02,0:08:14.70,English,,0,0,0,,So we talked some about that of in the context of how can you write up program that chenguwill sort of maximize
Dialogue: 0,0:08:08.02,0:08:14.70,Chinese,,0,0,0,,所以我们之前就如何编写程序来最大化处理器
Dialogue: 0,0:08:15.78,0:08:21.64,English,,0,0,0,,How much is going on down here by writing your code in a particular ways
Dialogue: 0,0:08:15.78,0:08:21.64,Chinese,,0,0,0,,这一内容讨论过
Dialogue: 0,0:08:22.62,0:08:26.22,English,,0,0,0,,So all this is an introduction to say
Dialogue: 0,0:08:22.62,0:08:26.22,Chinese,,0,0,0,,所以这一切都是介绍说
Dialogue: 0,0:08:26.60,0:08:29.26,English,,0,0,0,,This is how you have to understand what hyper threading is
Dialogue: 0,0:08:26.60,0:08:29.26,Chinese,,0,0,0,,你必须了解超线程是怎样的
Dialogue: 0,0:08:30.82,0:08:35.46,English,,0,0,0,,So in a single execution mode there's basically one instruction decoder
Dialogue: 0,0:08:30.82,0:08:35.46,Chinese,,0,0,0,,因此，在单个执行单元中，基本上都有一个指令解码器
Dialogue: 0,0:08:36.54,0:08:40.76,English,,0,0,0,,And it has its own set of state here its own program counter
Dialogue: 0,0:08:36.54,0:08:40.76,Chinese,,0,0,0,,它有自己的状态集合，有自己的程序计数器
Dialogue: 0,0:08:41.18,0:08:46.76,English,,0,0,0,,Its own queue of operations that it's already decoded and haven't completed yet
Dialogue: 0,0:08:41.18,0:08:46.76,Chinese,,0,0,0,,有自己已经解码但未执行的操作队列
Dialogue: 0,0:08:47.34,0:08:53.84,English,,0,0,0,,It has its own set of registers they're actually not registers like you'd expect， they're highly virtualized registers
Dialogue: 0,0:08:47.34,0:08:53.84,Chinese,,0,0,0,,它有自己的一组寄存器，它们实际上不是你想的那种寄存器，而是一种高度虚拟化的寄存器
Dialogue: 0,0:08:54.52,0:09:01.84,English,,0,0,0,,But all this state is there to help to service the execution of one thread of execution
Dialogue: 0,0:08:54.52,0:09:01.84,Chinese,,0,0,0,,但是所有这些状态都是为了帮助执行程序的某一个线程
Dialogue: 0,0:09:02.82,0:09:05.26,English,,0,0,0,,With hyper threading basically what you do is
Dialogue: 0,0:09:02.82,0:09:05.26,Chinese,,0,0,0,,超线程的基本思想是
Dialogue: 0,0:09:05.82,0:09:12.78,English,,0,0,0,,The idea that is to say 90% of all programs don't really make use of all these functional units
Dialogue: 0,0:09:05.82,0:09:12.78,Chinese,,0,0,0,, 90 ％的程序都没有完全利用所有这些功能单元
Dialogue: 0,0:09:12.94,0:09:16.86,English,,0,0,0,,Especially if you're blocking on a load
Dialogue: 0,0:09:12.94,0:09:16.86,Chinese,,0,0,0,,特别是因为缓存缺失
Dialogue: 0,0:09:16.86,0:09:19.16,English,,0,0,0,,Because there's a miss in a cache
Dialogue: 0,0:09:16.86,0:09:19.16,Chinese,,0,0,0,,而导致负载阻塞时
Dialogue: 0,0:09:19.86,0:09:24.00,English,,0,0,0,,Then all these arithmetic units are sitting there without anything useful work to do
Dialogue: 0,0:09:19.86,0:09:24.00,Chinese,,0,0,0,,所有这些算术单元都处于空闲状态
Dialogue: 0,0:09:25.52,0:09:28.20,English,,0,0,0,,Oh and so why don't we just double up
Dialogue: 0,0:09:25.52,0:09:28.20,Chinese,,0,0,0,,所以我们为什么不加倍
Dialogue: 0,0:09:29.06,0:09:32.46,English,,0,0,0,,Or quadruple upper K times up
Dialogue: 0,0:09:29.06,0:09:32.46,Chinese,,0,0,0,,或者翻 K 倍
Dialogue: 0,0:09:33.04,0:09:39.54,English,,0,0,0,,The state associated with the decoding and control parts of the program
Dialogue: 0,0:09:33.04,0:09:39.54,Chinese,,0,0,0,,与程序的解码和控制部分相关联的状态区域
Dialogue: 0,0:09:40.12,0:09:42.34,English,,0,0,0,,So that you can have multiple threads running
Dialogue: 0,0:09:40.12,0:09:42.34,Chinese,,0,0,0,,这样你就可以运行多个线程
Dialogue: 0,0:09:43.68,0:09:46.56,English,,0,0,0,,And sharing these functional units among each other
Dialogue: 0,0:09:43.68,0:09:46.56,Chinese,,0,0,0,,并在彼此之间共享这些功能单元
Dialogue: 0,0:09:46.64,0:09:52.32,English,,0,0,0,,So they're operating really independently their states are not intertwined
Dialogue: 0,0:09:46.64,0:09:52.32,Chinese,,0,0,0,,因此，他们真正地独立运行，他们的状态区域不是交织在一起的
Dialogue: 0,0:09:52.90,0:09:59.24,English,,0,0,0,,But they're sort of making more use of the available hardware for performing functions
Dialogue: 0,0:09:52.90,0:09:59.24,Chinese,,0,0,0,,但他们某种程度上能更多的使用可用硬件来执行函数
Dialogue: 0,0:09:59.56,0:10:02.32,English,,0,0,0,,And so that's called hyper threading that's an Intel term
Dialogue: 0,0:09:59.56,0:10:02.32,Chinese,,0,0,0,,因此，这称为超线程，是英特尔术语
Dialogue: 0,0:10:02.90,0:10:06.78,English,,0,0,0,,You also sometimes hear call SMT simultaneous multi-threading
Dialogue: 0,0:10:02.90,0:10:06.78,Chinese,,0,0,0,,有时也被称为 SMT 同步多线程
Dialogue: 0,0:10:07.58,0:10:11.46,English,,0,0,0,,And in my experience and we'll see here the numbers
Dialogue: 0,0:10:07.58,0:10:11.46,Chinese,,0,0,0,,根据我的经验，接下来我们将看到数据
Dialogue: 0,0:10:11.98,0:10:13.72,English,,0,0,0,,It doesn't really make that big a difference
Dialogue: 0,0:10:11.98,0:10:13.72,Chinese,,0,0,0,,它并没有发挥很大的作用
Dialogue: 0,0:10:14.00,0:10:19.72,English,,0,0,0,,But it turns out to be in the sort of large picture things
Dialogue: 0,0:10:14.00,0:10:19.72,Chinese,,0,0,0,,但事实证明，这是一种大局观
Dialogue: 0,0:10:20.16,0:10:24.60,English,,0,0,0,,A relatively inexpensive feature for them to throw on to processors and so they do it
Dialogue: 0,0:10:20.16,0:10:24.60,Chinese,,0,0,0,,能往处理器中加入一个相对便宜的特性时，便添加了
Dialogue: 0,0:10:25.28,0:10:32.30,English,,0,0,0,,And so nowadays at least with an x86 processor usually have 2-way hyper-threading in them
Dialogue: 0,0:10:25.28,0:10:32.30,Chinese,,0,0,0,,因此，现在至少使用 x86 处理器通常有双向超线程
Dialogue: 0,0:10:34.02,0:10:40.64,English,,0,0,0,,So given that if you look at our shark machines which are a little bit old there's sort of 2010 era machine
Dialogue: 0,0:10:34.02,0:10:40.64,Chinese,,0,0,0,,因此，如果你看到鲨鱼机器的配置，那是 2010 年代的机器
Dialogue: 0,0:10:41.10,0:10:43.92,English,,0,0,0,,But they were high-end machines in their day
Dialogue: 0,0:10:41.10,0:10:43.92,Chinese,,0,0,0,,但他们当时是高端机器
Dialogue: 0,0:10:43.92,0:10:47.20,English,,0,0,0,,And so they still actually are more powerful than
Dialogue: 0,0:10:43.92,0:10:47.20,Chinese,,0,0,0,,所以它们实际上仍比
Dialogue: 0,0:10:47.72,0:10:53.56,English,,0,0,0,,What you'd buy as say a desktop and way more powerful than as a laptop that you'd get today
Dialogue: 0,0:10:47.72,0:10:53.56,Chinese,,0,0,0,,如今你买的台式机或者笔记本更强大
Dialogue: 0,0:10:53.56,0:10:55.54,English,,0,0,0,,So they're actually pretty decent machines
Dialogue: 0,0:10:53.56,0:10:55.54,Chinese,,0,0,0,,所以他们实际上是相当不错的机器
Dialogue: 0,0:10:55.92,0:11:02.00,English,,0,0,0,,And actually we'll talk next time about why computers aren't a lot faster than they were five years ago
Dialogue: 0,0:10:55.92,0:11:02.00,Chinese,,0,0,0,,实际上，我们下次会谈到为什么计算机不比五年前快得多
Dialogue: 0,0:11:02.00,0:11:04.10,English,,0,0,0,,That's actually an interesting technology thing
Dialogue: 0,0:11:02.00,0:11:04.10,Chinese,,0,0,0,,这实际上是一项有趣的技术
Dialogue: 0,0:11:05.18,0:11:12.22,English,,0,0,0,,So they are server class machines so they have multiple cores
Dialogue: 0,0:11:05.18,0:11:12.22,Chinese,,0,0,0,,鲨鱼机器是服务器类机器，有多个内核
Dialogue: 0,0:11:12.80,0:11:23.54,English,,0,0,0,,And they have eight of them which is a lot you can buy ten core machines x86 machines on a single chip
Dialogue: 0,0:11:12.80,0:11:23.54,Chinese,,0,0,0,,他们有八个核心，你可以购买在一个芯片上有十台核心机器的 x86 机器
Dialogue: 0,0:11:23.60,0:11:25.14,English,,0,0,0,,But I don't think you can get more yet
Dialogue: 0,0:11:23.60,0:11:25.14,Chinese,,0,0,0,,但我觉得你应该买不到比 10 更多的了
Dialogue: 0,0:11:25.36,0:11:29.16,English,,0,0,0,,So these were fairly advanced machine of their day
Dialogue: 0,0:11:25.36,0:11:29.16,Chinese,,0,0,0,,所以这些都是当时相当先进的机器
Dialogue: 0,0:11:29.16,0:11:31.50,English,,0,0,0,,And they also have two-way hyper threading
Dialogue: 0,0:11:29.16,0:11:31.50,Chinese,,0,0,0,,而且他们也有双向超线程
Dialogue: 0,0:11:32.64,0:11:33.52,English,,0,0,0,,So in theory
Dialogue: 0,0:11:32.64,0:11:33.52,Chinese,,0,0,0,,所以在理论上
Dialogue: 0,0:11:36.96,0:11:40.34,English,,0,0,0,,You should be able to get sixteen independent threads running
Dialogue: 0,0:11:36.96,0:11:40.34,Chinese,,0,0,0,,你应该能够运行 16 个独立的线程
Dialogue: 0,0:11:40.62,0:11:44.72,English,,0,0,0,,Sort of 16 way parallelism potentially out of a program
Dialogue: 0,0:11:40.62,0:11:44.72,Chinese,,0,0,0,,或者说在一个程序上运行 16 个并行线程
Dialogue: 0,0:11:44.74,0:11:50.36,English,,0,0,0,,If you can keep everything working and keep bad things from happening
Dialogue: 0,0:11:44.74,0:11:50.36,Chinese,,0,0,0,,如果你能没有出错的正常运行的化
Dialogue: 0,0:11:55.18,0:12:01.94,English,,0,0,0,,So let's give a really trivial application one that should be very simple to make run in parallel
Dialogue: 0,0:11:55.18,0:12:01.94,Chinese,,0,0,0,,接下来我们来看一个能够并行运行的简单程序
Dialogue: 0,0:12:02.42,0:12:07.74,English,,0,0,0,,That says imaginary we want to sum up the numbers between 0 and n-1
Dialogue: 0,0:12:02.42,0:12:07.74,Chinese,,0,0,0,,假设我们要求 0 到 n - 1 的数字和
Dialogue: 0,0:12:07.74,0:12:12.38,English,,0,0,0,,Which is by the way a really stupid thing to do because there's a very simple closed-form formula for it
Dialogue: 0,0:12:07.74,0:12:12.38,Chinese,,0,0,0,,这是一个非常愚蠢的事情，因为它有一个非常简单的公式可以计算
Dialogue: 0,0:12:13.28,0:12:15.58,English,,0,0,0,,Which is good in the sense it will let us check our work
Dialogue: 0,0:12:13.28,0:12:15.58,Chinese,,0,0,0,,当然这个公式可以用来帮我们检查正确性
Dialogue: 0,0:12:15.76,0:12:18.36,English,,0,0,0,,But it's a completely stupid application
Dialogue: 0,0:12:15.76,0:12:18.36,Chinese,,0,0,0,,但这是一个非常愚蠢的程序
Dialogue: 0,0:12:19.00,0:12:21.02,English,,0,0,0,,But it just shows you this idea
Dialogue: 0,0:12:19.00,0:12:21.02,Chinese,,0,0,0,,只是为了解释并行性的思想
Dialogue: 0,0:12:21.74,0:12:24.44,English,,0,0,0,,And so what we're just going to do is block off
Dialogue: 0,0:12:21.74,0:12:24.44,Chinese,,0,0,0,,所以我们要做的就是分块
Dialogue: 0,0:12:24.98,0:12:31.68,English,,0,0,0,,If we have n way parallelism we're just going to split a range of numbers n ways
Dialogue: 0,0:12:24.98,0:12:31.68,Chinese,,0,0,0,,如果我们有 n 个并行线路，则我们将这组数分割成 n 份
Dialogue: 0,0:12:32.58,0:12:37.60,English,,0,0,0,,And just have a single threads sum up one nth of the numbers
Dialogue: 0,0:12:32.58,0:12:37.60,Chinese,,0,0,0,,只需要一个线程对 1 / n 的数求和
Dialogue: 0,0:12:38.20,0:12:43.50,English,,0,0,0,,And then they'll collectively sum together the result in some way or another
Dialogue: 0,0:12:38.20,0:12:43.50,Chinese,,0,0,0,,然后他们将以某种方式将结果加起来
Dialogue: 0,0:12:43.82,0:12:46.42,English,,0,0,0,,So this is about as easy a parallel program as you could imagine
Dialogue: 0,0:12:43.82,0:12:46.42,Chinese,,0,0,0,,所以这就是一个很简单的并行程序
Dialogue: 0,0:12:47.84,0:12:53.54,English,,0,0,0,,So let's do a 1 version which is said well gee understand how to use threads
Dialogue: 0,0:12:47.84,0:12:53.54,Chinese,,0,0,0,,如果我们知道怎样使用线程，信号量，互斥等概念
Dialogue: 0,0:12:54.20,0:12:58.90,English,,0,0,0,,Pthreads and  know about these things called semaphores or mutual exclusion
Dialogue: 0,0:12:54.20,0:12:58.90,Chinese,,0,0,0,,我们可以写出该程序的版本 1
Dialogue: 0,0:12:59.42,0:13:04.58,English,,0,0,0,,So what I'll do is just all I'll have one place in memory
Dialogue: 0,0:12:59.42,0:13:04.58,Chinese,,0,0,0,,首先我们在内存中分配一个空间
Dialogue: 0,0:13:04.58,0:13:08.14,English,,0,0,0,,Where I'm collecting the sum over all n values
Dialogue: 0,0:13:04.58,0:13:08.14,Chinese,,0,0,0,,在那里储存来自 N 个线程的元素和
Dialogue: 0,0:13:08.88,0:13:11.86,English,,0,0,0,,And for a thread to be able to add to that
Dialogue: 0,0:13:08.88,0:13:11.86,Chinese,,0,0,0,,每个线程都能增加它的值
Dialogue: 0,0:13:12.10,0:13:19.28,English,,0,0,0,,If it will lock it it will get a mutual exclusive access to it increment it and then unlock it
Dialogue: 0,0:13:12.10,0:13:19.28,Chinese,,0,0,0,,如果它将锁定它，它将获得互斥的访问权限，然后将其解锁
Dialogue: 0,0:13:19.40,0:13:24.66,English,,0,0,0,,And we'll just let all the threads go helter-skelter locking and unlocking this
Dialogue: 0,0:13:19.40,0:13:24.66,Chinese,,0,0,0,,让所有的线程都进行慌乱地锁定和解锁
Dialogue: 0,0:13:25.72,0:13:27.52,English,,0,0,0,,So the code for that's pretty easy to write it
Dialogue: 0,0:13:25.72,0:13:27.52,Chinese,,0,0,0,,因此这个代码很容易写
Dialogue: 0,0:13:27.86,0:13:36.46,English,,0,0,0,,It's a here's the code of course all threaded code looks a lot messier than you think it should but
Dialogue: 0,0:13:27.86,0:13:36.46,Chinese,,0,0,0,,当然所有线程代码看起来都比你想象的要麻烦得多
Dialogue: 0,0:13:37.12,0:13:39.32,English,,0,0,0,,In the end it's a fairly straightforward code
Dialogue: 0,0:13:37.12,0:13:39.32,Chinese,,0,0,0,,但它看上去仍是一个相当简单的代码
Dialogue: 0,0:13:40.16,0:13:41.32,English,,0,0,0,,So in particular
Dialogue: 0,0:13:40.16,0:13:41.32,Chinese,,0,0,0,,具体来说
Dialogue: 0,0:13:42.96,0:13:44.46,English,,0,0,0,,This is the thread routine is
Dialogue: 0,0:13:42.96,0:13:44.46,Chinese,,0,0,0,,这是线程例程
Dialogue: 0,0:13:46.12,0:13:55.02,English,,0,0,0,,Passing through this weird vargp structure that you do with threads
Dialogue: 0,0:13:46.12,0:13:55.02,Chinese,,0,0,0,,通过这个奇怪的 vargp 结构体
Dialogue: 0,0:13:55.26,0:13:58.20,English,,0,0,0,,The way you pass arguments to a thread routine
Dialogue: 0,0:13:55.26,0:13:58.20,Chinese,,0,0,0,,你将参数传递给线程例程
Dialogue: 0,0:13:58.60,0:14:02.84,English,,0,0,0,,But basically it's figuring out where is the start and end range of the numbers
Dialogue: 0,0:13:58.60,0:14:02.84,Chinese,,0,0,0,,基本上它的作用是弄清楚数字的开始和结束区域
Dialogue: 0,0:14:03.56,0:14:09.52,English,,0,0,0,,Then adding for all i between the start before the end
Dialogue: 0,0:14:03.56,0:14:09.52,Chinese,,0,0,0,,并在这个区间内添加所有的 i
Dialogue: 0,0:14:10.10,0:14:14.88,English,,0,0,0,,I'll lock that acquire a semaphore lock
Dialogue: 0,0:14:10.10,0:14:14.88,Chinese,,0,0,0,,我将得到一个信号量锁定
Dialogue: 0,0:14:15.64,0:14:19.08,English,,0,0,0,,I'll increment this global sum and then I'll release the lock
Dialogue: 0,0:14:15.64,0:14:19.08,Chinese,,0,0,0,,然后增加这个全局总和，然后释放锁定
Dialogue: 0,0:14:20.66,0:14:23.56,English,,0,0,0,,Okay so pretty much the style of code that you've been working with
Dialogue: 0,0:14:20.66,0:14:23.56,Chinese,,0,0,0,,这是我们很熟悉的代码风格
Dialogue: 0,0:14:25.10,0:14:27.92,English,,0,0,0,,And what you find is actually this is really a bad idea
Dialogue: 0,0:14:25.10,0:14:27.92,Chinese,,0,0,0,,这其实是个坏主意
Dialogue: 0,0:14:28.92,0:14:30.40,English,,0,0,0,,So running as a single thread
Dialogue: 0,0:14:28.92,0:14:30.40,Chinese,,0,0,0,,如果是单线程运行
Dialogue: 0,0:14:31.22,0:14:33.04,English,,0,0,0,,It takes 51 seconds to do that
Dialogue: 0,0:14:31.22,0:14:33.04,Chinese,,0,0,0,,需要 51 秒来完成
Dialogue: 0,0:14:33.04,0:14:37.04,English,,0,0,0,,It would be by the way if you didn't lock and unlock because it's only one thread
Dialogue: 0,0:14:33.04,0:14:37.04,Chinese,,0,0,0,,顺便说一句，如果你没有使用锁定和解锁，因为它只是一个线程
Dialogue: 0,0:14:37.04,0:14:40.60,English,,0,0,0,,You'd blow this away it would take just a couple seconds so
Dialogue: 0,0:14:37.04,0:14:40.60,Chinese,,0,0,0,,你会惊讶地发现这仅需要几秒钟
Dialogue: 0,0:14:41.30,0:14:44.02,English,,0,0,0,,And then you see as you add more threads it actually gets worse
Dialogue: 0,0:14:41.30,0:14:44.02,Chinese,,0,0,0,,当添加了更多地线程时，时间会越慢
Dialogue: 0,0:14:44.80,0:14:47.60,English,,0,0,0,,And especially if you jump from one to two
Dialogue: 0,0:14:44.80,0:14:47.60,Chinese,,0,0,0,,特别是如果你一个线程变成两个时
Dialogue: 0,0:14:48.12,0:14:51.32,English,,0,0,0,,You increase by a factor nine how much time  it takes
Dialogue: 0,0:14:48.12,0:14:51.32,Chinese,,0,0,0,,你增加了 9 倍的时间
Dialogue: 0,0:14:52.78,0:14:58.04,English,,0,0,0,,And it always starts to get better as you get up into eight threads and then it gets worse again
Dialogue: 0,0:14:52.78,0:14:58.04,Chinese,,0,0,0,,当你增加到第八个线程时，耗时会少一点，但继续增加，耗时仍会越来越多
Dialogue: 0,0:14:59.04,0:15:06.28,English,,0,0,0,,So the reason is that locking unlocking is a very time-consuming task
Dialogue: 0,0:14:59.04,0:15:06.28,Chinese,,0,0,0,,因为锁定解锁是一项非常耗时的任务
Dialogue: 0,0:15:06.30,0:15:07.88,English,,0,0,0,,And basically you can think of...
Dialogue: 0,0:15:06.30,0:15:07.88,Chinese,,0,0,0,,你可以这样设想 ......
Dialogue: 0,0:15:09.90,0:15:15.40,English,,0,0,0,,If you have that map of the multi-core processors with all their private caches in one shared cache
Dialogue: 0,0:15:09.90,0:15:15.40,Chinese,,0,0,0,,如果你有一个多核处理器，所有核地私有缓存都是一块共有的缓存区
Dialogue: 0,0:15:16.10,0:15:22.30,English,,0,0,0,,These threads are basically fighting with each other for control for that one memory address
Dialogue: 0,0:15:16.10,0:15:22.30,Chinese,,0,0,0,,这些线程会去互相争夺这块
Dialogue: 0,0:15:22.48,0:15:25.90,English,,0,0,0,,That they that they're incrementing
Dialogue: 0,0:15:22.48,0:15:25.90,Chinese,,0,0,0,,他们正在增加地址的内存区域
Dialogue: 0,0:15:26.48,0:15:31.14,English,,0,0,0,,And it has to grab the control away from one core to your the core
Dialogue: 0,0:15:26.48,0:15:31.14,Chinese,,0,0,0,,控制权从一个核心抢到了
Dialogue: 0,0:15:31.62,0:15:35.44,English,,0,0,0,,That's accessing it do the lock unlock
Dialogue: 0,0:15:31.62,0:15:35.44,Chinese,,0,0,0,,另一个正在锁定和解锁的核心
Dialogue: 0,0:15:35.98,0:15:39.60,English,,0,0,0,,And then it gets grabbed back for it so it's a miserable performance for cache
Dialogue: 0,0:15:35.98,0:15:39.60,Chinese,,0,0,0,,然后它又被被抢回去，这对于缓存来说是很糟糕的
Dialogue: 0,0:15:40.24,0:15:42.80,English,,0,0,0,,Huge overhead for the semaphore activities
Dialogue: 0,0:15:40.24,0:15:42.80,Chinese,,0,0,0,,信号量活动有巨大的开销
Dialogue: 0,0:15:43.36,0:15:45.42,English,,0,0,0,,And just really a bad thing all around
Dialogue: 0,0:15:43.36,0:15:45.42,Chinese,,0,0,0,,是一件非常糟糕的事
Dialogue: 0,0:15:45.44,0:15:51.31,English,,0,0,0,,And so lesson one is semaphores or mutexes are very expensive
Dialogue: 0,0:15:45.44,0:15:51.31,Chinese,,0,0,0,,这告诉我们信号量或者说互斥量是非常昂贵的
Dialogue: 0,0:15:52.06,0:15:54.90,English,,0,0,0,,And if you're trying to do low level parallelism
Dialogue: 0,0:15:52.06,0:15:54.90,Chinese,,0,0,0,,如果你正在尝试做一些低级的并发处理
Dialogue: 0,0:15:54.90,0:15:58.90,English,,0,0,0,,You don't want fine-grained locking at that level otherwise
Dialogue: 0,0:15:54.90,0:15:58.90,Chinese,,0,0,0,,你不想做一些很细分的锁定和解锁
Dialogue: 0,0:15:59.02,0:16:00.32,English,,0,0,0,,You're just completely sunk
Dialogue: 0,0:15:59.02,0:16:00.32,Chinese,,0,0,0,,不然你的程序很慢
Dialogue: 0,0:16:00.50,0:16:02.92,English,,0,0,0,,And so that's not the way to do it
Dialogue: 0,0:16:00.50,0:16:02.92,Chinese,,0,0,0,,这不是并发的正确使用方式
Dialogue: 0,0:16:03.34,0:16:08.78,English,,0,0,0,,I won't go into it but there's quite a bit of literature about what they call lock free synchronization
Dialogue: 0,0:16:03.34,0:16:08.78,Chinese,,0,0,0,,我不会详细展开，但有很多关于「无锁同步」的文献
Dialogue: 0,0:16:09.24,0:16:12.20,English,,0,0,0,,Which is a way to avoid semaphores but get the effect
Dialogue: 0,0:16:09.24,0:16:12.20,Chinese,,0,0,0,,这是一种避免信号量但获得想要效果的方法
Dialogue: 0,0:16:12.78,0:16:15.00,English,,0,0,0,,And they wouldn't work in this context either those
Dialogue: 0,0:16:12.78,0:16:15.00,Chinese,,0,0,0,,那种方法也不会在我们这种情况下使用
Dialogue: 0,0:16:15.54,0:16:17.36,English,,0,0,0,,Just if you've ever heard that term
Dialogue: 0,0:16:15.54,0:16:17.36,Chinese,,0,0,0,,如果你们听说过那个词
Dialogue: 0,0:16:17.74,0:16:19.54,English,,0,0,0,,Those are generally designed for
Dialogue: 0,0:16:17.74,0:16:19.54,Chinese,,0,0,0,,这些通常是为
Dialogue: 0,0:16:20.30,0:16:25.80,English,,0,0,0,,Examples where you expect relatively little contention between the threads
Dialogue: 0,0:16:20.30,0:16:25.80,Chinese,,0,0,0,,那些进程存在很少的冲突的情况设计
Dialogue: 0,0:16:25.80,0:16:30.30,English,,0,0,0,,And so you try and be optimistic and then roll back if something bad happens
Dialogue: 0,0:16:25.80,0:16:30.30,Chinese,,0,0,0,,所以你假设不会产生冲突，然后如果发生了不好的事情就返回
Dialogue: 0,0:16:31.90,0:16:33.52,English,,0,0,0,,This is a case where nope
Dialogue: 0,0:16:31.90,0:16:33.52,Chinese,,0,0,0,,我们这个案例是
Dialogue: 0,0:16:33.78,0:16:38.24,English,,0,0,0,,All those threads are going to be pounding that one memory location and they're really fighting for it
Dialogue: 0,0:16:33.78,0:16:38.24,Chinese,,0,0,0,,所有这些线程都将冲击一个内存位置，他们真的都在争夺它
Dialogue: 0,0:16:38.30,0:16:41.10,English,,0,0,0,,And so there is no good solution to that problem
Dialogue: 0,0:16:38.30,0:16:41.10,Chinese,,0,0,0,,所以这个问题没有很好的解决方案
Dialogue: 0,0:16:43.70,0:16:47.48,English,,0,0,0,,The other thing I'll point out is this jump here shows you that
Dialogue: 0,0:16:43.70,0:16:47.48,Chinese,,0,0,0,,我要指出的另一件事就是：从 8 线程变成 16 线程告诉了我们
Dialogue: 0,0:16:48.20,0:16:50.76,English,,0,0,0,,Hyper threading isn't really helping us here
Dialogue: 0,0:16:48.20,0:16:50.76,Chinese,,0,0,0,,超线程并不能真正帮助我们
Dialogue: 0,0:16:52.42,0:16:55.88,English,,0,0,0,,Going from the fact that we slowed down from 8 to 16
Dialogue: 0,0:16:52.42,0:16:55.88,Chinese,,0,0,0,, 8 线程变成 16 线程，速度更慢
Dialogue: 0,0:16:55.88,0:16:59.16,English,,0,0,0,,Means we can't really make use of 16 threads in this application
Dialogue: 0,0:16:55.88,0:16:59.16,Chinese,,0,0,0,,意味着我们无法在此应用程序中真正使用 16 个线程
Dialogue: 0,0:16:59.68,0:17:01.60,English,,0,0,0,,8 threads are better than 4
Dialogue: 0,0:16:59.68,0:17:01.60,Chinese,,0,0,0,, 8 个线程比 4 个好
Dialogue: 0,0:17:02.06,0:17:06.74,English,,0,0,0,,But obviously all that's kind of a waste of time because this is just really a bad idea all around
Dialogue: 0,0:17:02.06,0:17:06.74,Chinese,,0,0,0,,但显然所有这些都浪费时间，因为线程这样设计本身是个很糟糕的主意
Dialogue: 0,0:17:08.38,0:17:08.72,English,,0,0,0,,So
Dialogue: 0,0:17:08.38,0:17:08.72,Chinese,,0,0,0,,所以
Dialogue: 0,0:17:09.56,0:17:11.14,English,,0,0,0,,Let's do something different
Dialogue: 0,0:17:09.56,0:17:11.14,Chinese,,0,0,0,,让我们来尝试另一种方法
Dialogue: 0,0:17:11.18,0:17:17.06,English,,0,0,0,,Let's have each of them accumulate their own sum for their own sub range
Dialogue: 0,0:17:11.18,0:17:17.06,Chinese,,0,0,0,,让所有的线程在它们的子范围内累加自己的和
Dialogue: 0,0:17:18.60,0:17:22.16,English,,0,0,0,,And we'll give up so we'll have an array of accumulators
Dialogue: 0,0:17:18.60,0:17:22.16,Chinese,,0,0,0,,所以我们将一个累加器数组
Dialogue: 0,0:17:23.12,0:17:29.72,English,,0,0,0,,Where the each thread is incrementing only a one element of this array
Dialogue: 0,0:17:23.12,0:17:29.72,Chinese,,0,0,0,,每个线程只增加此数组的一个元素
Dialogue: 0,0:17:30.56,0:17:33.38,English,,0,0,0,,So they're not fighting with each other directly for it
Dialogue: 0,0:17:30.56,0:17:33.38,Chinese,,0,0,0,,所以他们不是直接在相互争斗数组的使用权
Dialogue: 0,0:17:33.58,0:17:38.96,English,,0,0,0,,But they are fighting for if you think about it for the same cache line
Dialogue: 0,0:17:33.58,0:17:38.96,Chinese,,0,0,0,,但是它们仍然在争夺这个缓存
Dialogue: 0,0:17:39.84,0:17:43.92,English,,0,0,0,,Because an array is typically stored and so it's not totally nice
Dialogue: 0,0:17:39.84,0:17:43.92,Chinese,,0,0,0,,因为数组通常是存储的存储的，所有它不是很好
Dialogue: 0,0:17:45.70,0:17:48.68,English,,0,0,0,,Ah but this it gives you a pointer to this idea
Dialogue: 0,0:17:45.70,0:17:48.68,Chinese,,0,0,0,,但这我们提供了一个思路
Dialogue: 0,0:17:48.80,0:17:52.14,English,,0,0,0,,If we could sort of move into a private state
Dialogue: 0,0:17:48.80,0:17:52.14,Chinese,,0,0,0,,如果我们可以进入私有状态
Dialogue: 0,0:17:52.88,0:17:55.86,English,,0,0,0,,The stuff that we're making the most direct access to
Dialogue: 0,0:17:52.88,0:17:55.86,Chinese,,0,0,0,,我们能够直接访问的东西
Dialogue: 0,0:17:56.68,0:17:58.40,English,,0,0,0,,Then we'll get better performance
Dialogue: 0,0:17:56.68,0:17:58.40,Chinese,,0,0,0,,我们会获得更好的表现
Dialogue: 0,0:17:59.68,0:18:01.44,English,,0,0,0,,So this is the thread routine
Dialogue: 0,0:17:59.68,0:18:01.44,Chinese,,0,0,0,,所以这是我们的线程例程
Dialogue: 0,0:18:01.96,0:18:05.12,English,,0,0,0,,And that the point is that there's some global array called psum
Dialogue: 0,0:18:01.96,0:18:05.12,Chinese,,0,0,0,,该程序的关键是有叫做 psum 的全局数组
Dialogue: 0,0:18:05.12,0:18:10.80,English,,0,0,0,,But it's only incrementing the part of it that sort of assigned to this particular thread
Dialogue: 0,0:18:05.12,0:18:10.80,Chinese,,0,0,0,,它只增加分配给某一特定线程的数组元素
Dialogue: 0,0:18:12.92,0:18:15.44,English,,0,0,0,,And here you do see a performance improvement right
Dialogue: 0,0:18:12.92,0:18:15.44,Chinese,,0,0,0,,在这里，你确实看到了正确的性能提升
Dialogue: 0,0:18:15.56,0:18:19.78,English,,0,0,0,,So one thread takes 5 seconds remember before it was 58
Dialogue: 0,0:18:15.56,0:18:19.78,Chinese,,0,0,0,,所以一个线程需要 5 秒而不是之前的 58 秒
Dialogue: 0,0:18:19.92,0:18:25.16,English,,0,0,0,,So that shows you just the advantage of the cost of semaphores
Dialogue: 0,0:18:19.92,0:18:25.16,Chinese,,0,0,0,,这样就向你展示了信号量成本的优势
Dialogue: 0,0:18:25.66,0:18:27.14,English,,0,0,0,,Right there is a factor of 10
Dialogue: 0,0:18:25.66,0:18:27.14,Chinese,,0,0,0,,对，有 10 倍
Dialogue: 0,0:18:27.74,0:18:33.12,English,,0,0,0,,And you see you are actually getting an improvement all across the line including up to 16 threads
Dialogue: 0,0:18:27.74,0:18:33.12,Chinese,,0,0,0,,观察整个线条，你会发现所有的情况都有改善，包括 16 线程的情况
Dialogue: 0,0:18:33.14,0:18:34.50,English,,0,0,0,,You're still getting an improvement
Dialogue: 0,0:18:33.14,0:18:34.50,Chinese,,0,0,0,,你还在改进
Dialogue: 0,0:18:35.02,0:18:38.14,English,,0,0,0,,It would flatten out should have just shown the number for 32
Dialogue: 0,0:18:35.02,0:18:38.14,Chinese,,0,0,0,,这里会变扁平（如果我展示 32 线程的情况）
Dialogue: 0,0:18:38.14,0:18:40.02,English,,0,0,0,,But it would flatten out at this point
Dialogue: 0,0:18:38.14,0:18:40.02,Chinese,,0,0,0,,线条会在之后变得扁平
Dialogue: 0,0:18:40.56,0:18:43.78,English,,0,0,0,,But it actually is getting some advantage out of hyper-threading as well
Dialogue: 0,0:18:40.56,0:18:43.78,Chinese,,0,0,0,,但它实际上也从超线程中获得了一些增速
Dialogue: 0,0:18:45.34,0:18:48.14,English,,0,0,0,,So that's good it's not an amazing speed up
Dialogue: 0,0:18:45.34,0:18:48.14,Chinese,,0,0,0,,这很好，但这也不是一个惊人的加速
Dialogue: 0,0:18:48.46,0:18:57.48,English,,0,0,0,,So you can think of what they call the speed up is the performance of it running on a single core versus the performance on n cores
Dialogue: 0,0:18:48.46,0:18:57.48,Chinese,,0,0,0,,所以你可以想到他们所谓的加速是它在单核上运行的性能与 n 核上的性能相比
Dialogue: 0,0:18:57.48,0:19:00.30,English,,0,0,0,,And in the ideal case it goes n times faster
Dialogue: 0,0:18:57.48,0:19:00.30,Chinese,,0,0,0,,在理想情况下，它的速度提高了 n 倍
Dialogue: 0,0:19:00.94,0:19:02.28,English,,0,0,0,,And we're not quite hitting that
Dialogue: 0,0:19:00.94,0:19:02.28,Chinese,,0,0,0,,我们并没有达到那种性能
Dialogue: 0,0:19:05.90,0:19:12.04,English,,0,0,0,,Well but here's if you've already learned that it's generally bad to be accumulating into a memory
Dialogue: 0,0:19:05.90,0:19:12.04,Chinese,,0,0,0,,但如果你知道了，直接在共享内存中累加是不好的
Dialogue: 0,0:19:12.58,0:19:15.50,English,,0,0,0,,And so why not do the thing we learned before
Dialogue: 0,0:19:12.58,0:19:15.50,Chinese,,0,0,0,,那么为什么试一下我们之前学到的东西呢
Dialogue: 0,0:19:15.90,0:19:20.50,English,,0,0,0,,Which is you accumulate in a register and you only update the memory when you're done with that
Dialogue: 0,0:19:15.90,0:19:20.50,Chinese,,0,0,0,,现在寄存器内累加，再将结果更新好内存中
Dialogue: 0,0:19:21.30,0:19:24.76,English,,0,0,0,,So let's just do that and I'll call that the local version
Dialogue: 0,0:19:21.30,0:19:24.76,Chinese,,0,0,0,,所以，让我们这样做，我会称之为本地版本
Dialogue: 0,0:19:25.20,0:19:28.60,English,,0,0,0,,I'll just increment a sum which is a local variable
Dialogue: 0,0:19:25.20,0:19:28.60,Chinese,,0,0,0,,我将增加一个本地变量 sum
Dialogue: 0,0:19:29.06,0:19:30.46,English,,0,0,0,,And only when I'm done
Dialogue: 0,0:19:29.06,0:19:30.46,Chinese,,0,0,0,,只有当我完成了
Dialogue: 0,0:19:31.24,0:19:35.30,English,,0,0,0,,Then I'll store it in the global array
Dialogue: 0,0:19:31.24,0:19:35.30,Chinese,,0,0,0,,我把它它存储在全局数组中
Dialogue: 0,0:19:37.14,0:19:40.52,English,,0,0,0,,Okay so it's functionally equivalent to the one we just showed
Dialogue: 0,0:19:37.14,0:19:40.52,Chinese,,0,0,0,,好的，它在功能上等同于我们刚刚展示的那个
Dialogue: 0,0:19:40.52,0:19:46.18,English,,0,0,0,,We're just moving instead of accumulating in a global array we're accumulating in a register
Dialogue: 0,0:19:40.52,0:19:46.18,Chinese,,0,0,0,,我们仅仅把现在寄存器中累加和移动到全局数组中
Dialogue: 0,0:19:47.30,0:19:49.92,English,,0,0,0,,And here you see a pretty big performance improvement
Dialogue: 0,0:19:47.30,0:19:49.92,Chinese,,0,0,0,,这样，你可以看到相当大的性能提升
Dialogue: 0,0:19:51.18,0:20:00.04,English,,0,0,0,,So blue is what we showed with the global array,red or orange is what's this local variable
Dialogue: 0,0:19:51.18,0:20:00.04,Chinese,,0,0,0,,所以蓝色是我们用全局数组的，红色或橙色是局部变量
Dialogue: 0,0:20:00.76,0:20:04.56,English,,0,0,0,,And so you see it's actually interesting we're getting a performance improvement
Dialogue: 0,0:20:00.76,0:20:04.56,Chinese,,0,0,0,,你会看到我们得到了很有趣的性能提升
Dialogue: 0,0:20:05.38,0:20:11.12,English,,0,0,0,,As well although it bottoms out at eight
Dialogue: 0,0:20:05.38,0:20:11.12,Chinese,,0,0,0,,它在 8 线程达到最低点
Dialogue: 0,0:20:11.28,0:20:13.89,English,,0,0,0,,And it actually gets worse when you go to sixteen
Dialogue: 0,0:20:11.28,0:20:13.89,Chinese,,0,0,0,,在 16 线程时，它实际上会变得更糟
Dialogue: 0,0:20:14.44,0:20:17.24,English,,0,0,0,,And this is showing that hyper-threading isn't really helping here
Dialogue: 0,0:20:14.44,0:20:17.24,Chinese,,0,0,0,,这表明超线程在这方面并没有真正帮助
Dialogue: 0,0:20:17.24,0:20:21.98,English,,0,0,0,,Because basically the single thread is just accumulating
Dialogue: 0,0:20:17.24,0:20:21.98,Chinese,,0,0,0,,因为基本上，单线程只是在累加
Dialogue: 0,0:20:22.68,0:20:27.22,English,,0,0,0,,As fast as it can and adding to a register
Dialogue: 0,0:20:22.68,0:20:27.22,Chinese,,0,0,0,,尽可能快地把数加到寄存器上
Dialogue: 0,0:20:27.64,0:20:32.54,English,,0,0,0,,And so it's making pretty good use of what functional units it uses and putting multiple threads
Dialogue: 0,0:20:27.64,0:20:32.54,Chinese,,0,0,0,,因此，它正在很好地利用它使用的功能单元并放置多个线程
Dialogue: 0,0:20:33.02,0:20:34.50,English,,0,0,0,,Sharing it isn't really helping
Dialogue: 0,0:20:33.02,0:20:34.50,Chinese,,0,0,0,,分享它并没有真正帮助
Dialogue: 0,0:20:34.96,0:20:39.30,English,,0,0,0,,At least not on the shark machines
Dialogue: 0,0:20:34.96,0:20:39.30,Chinese,,0,0,0,,至少不在鲨鱼机上
Dialogue: 0,0:20:39.48,0:20:42.24,English,,0,0,0,,This actually might be different on different machines
Dialogue: 0,0:20:39.48,0:20:42.24,Chinese,,0,0,0,,这实际上可能在不同的机器上有所不同
Dialogue: 0,0:20:43.48,0:20:49.34,English,,0,0,0,,And actually if you recall from the performance optimization we found that if you're just doing a bunch of additions
Dialogue: 0,0:20:43.48,0:20:49.34,Chinese,,0,0,0,,实际上，如果你从性能优化中回忆起来，我们发现如果你只是做了很多补充
Dialogue: 0,0:20:49.96,0:20:54.36,English,,0,0,0,,You can make use as associativity and get more accumulation in parallel
Dialogue: 0,0:20:49.96,0:20:54.36,Chinese,,0,0,0,,你可以将其用作关联性并获得更多并行累积
Dialogue: 0,0:20:54.86,0:20:59.66,English,,0,0,0,,So you could actually speed up this program just the single threaded version of this program pretty well
Dialogue: 0,0:20:54.86,0:20:59.66,Chinese,,0,0,0,,所以你实际上可以加速这个程序只是这个程序的单线程版本
Dialogue: 0,0:21:00.24,0:21:04.66,English,,0,0,0,,But anyways it shows it okay this is starting to look like
Dialogue: 0,0:21:00.24,0:21:04.66,Chinese,,0,0,0,,但无论如何它表明它可以开始看起来像
Dialogue: 0,0:21:05.14,0:21:09.76,English,,0,0,0,,Your a your single threaded performance is pretty good and b
Dialogue: 0,0:21:05.14,0:21:09.76,Chinese,,0,0,0,,你的单线程性能非常好 b
Dialogue: 0,0:21:10.08,0:21:13.44,English,,0,0,0,,You're getting some useful speed-up out of parallelism
Dialogue: 0,0:21:10.08,0:21:13.44,Chinese,,0,0,0,,你可以从并行性中获得一些有用的加速
Dialogue: 0,0:21:14.48,0:21:19.36,English,,0,0,0,,But as said this is like the easiest example in the world to parallelize so if you can't do it here
Dialogue: 0,0:21:14.48,0:21:19.36,Chinese,,0,0,0,,但正如所说的，这就像世界上最简单的并行化示例，如果你不能在这里做到这一点
Dialogue: 0,0:21:19.90,0:21:24.52,English,,0,0,0,,Then life is pretty hopeless as far as multi-threading
Dialogue: 0,0:21:19.90,0:21:24.52,Chinese,,0,0,0,,然后就多线程而言，生活是绝望的
Dialogue: 0,0:21:25.80,0:21:29.70,English,,0,0,0,,So let's talk about as mentioned this idea of speed-up
Dialogue: 0,0:21:25.80,0:21:29.70,Chinese,,0,0,0,,所以让我们谈谈提到加速这个想法
Dialogue: 0,0:21:30.70,0:21:35.14,English,,0,0,0,,So speed-up is just defined to be the time for a single-threaded program
Dialogue: 0,0:21:30.70,0:21:35.14,Chinese,,0,0,0,,因此，加速定义为单线程程序的时间
Dialogue: 0,0:21:35.82,0:21:40.86,English,,0,0,0,,Divided by the time for pthreads running
Dialogue: 0,0:21:35.82,0:21:40.86,Chinese,,0,0,0,,除以 pthreads 运行的时间
Dialogue: 0,0:21:41.47,0:21:45.66,English,,0,0,0,,Or actually will use it p cores instead of pthreads,question
Dialogue: 0,0:21:41.47,0:21:45.66,Chinese,,0,0,0,,或实际上将使用它 p 核而不是 pthreads ，请讲
Dialogue: 0,0:21:45.78,0:21:51.64,English,,0,0,0,,[student speaking]
Dialogue: 0,0:21:45.78,0:21:51.64,Chinese,,0,0,0,,[同学提问]
Dialogue: 0,0:21:51.64,0:21:57.72,English,,0,0,0,,Yes generally you know the scheduler has some kind of go balancing built into it
Dialogue: 0,0:21:51.64,0:21:57.72,Chinese,,0,0,0,,是的，通常调度程序有一些内置的平衡
Dialogue: 0,0:21:58.54,0:22:05.14,English,,0,0,0,,And it will tend to especially in a case like this where the threads are sort of grabbing and running
Dialogue: 0,0:21:58.54,0:22:05.14,Chinese,,0,0,0,,特别是在这样的情况下，线程会抢占式运行
Dialogue: 0,0:22:05.72,0:22:10.96,English,,0,0,0,,Making...They will generally get spread across the cores
Dialogue: 0,0:22:05.72,0:22:10.96,Chinese,,0,0,0,,通常它们会利用所有核心
Dialogue: 0,0:22:11.92,0:22:14.60,English,,0,0,0,,So that's a pretty...the linux scheduler is pretty good at
Dialogue: 0,0:22:11.92,0:22:14.60,Chinese,,0,0,0,,Linux 调度程序非常擅长（线程调度）
Dialogue: 0,0:22:15.24,0:22:19.32,English,,0,0,0,,That when you have more threads than there are cores
Dialogue: 0,0:22:15.24,0:22:19.32,Chinese,,0,0,0,,当你的线程数大于核心数
Dialogue: 0,0:22:19.98,0:22:27.56,English,,0,0,0,,Then it basically starts scheduling them in some cyclic order
Dialogue: 0,0:22:19.98,0:22:27.56,Chinese,,0,0,0,,然后它基本上开始以某种循环顺序调度它们
Dialogue: 0,0:22:27.58,0:22:29.84,English,,0,0,0,,And you won't...you'll...
Dialogue: 0,0:22:27.58,0:22:29.84,Chinese,,0,0,0,,你不会 ...... 你会 ......
Dialogue: 0,0:22:30.68,0:22:33.86,English,,0,0,0,,At best you will not get any advantage
Dialogue: 0,0:22:30.68,0:22:33.86,Chinese,,0,0,0,,最好的情况，你不会得到任何好处
Dialogue: 0,0:22:34.00,0:22:39.00,English,,0,0,0,,And in a worst case you actually start slowing down from having more threads than are
Dialogue: 0,0:22:34.00,0:22:39.00,Chinese,,0,0,0,,实际上最坏的情况是你开始因为线程数的增加而放慢速度
Dialogue: 0,0:22:39.94,0:22:40.80,English,,0,0,0,,There good question
Dialogue: 0,0:22:39.94,0:22:40.80,Chinese,,0,0,0,,有好问题
Dialogue: 0,0:22:41.24,0:22:43.00,English,,0,0,0,,So there's really two versions of speedup
Dialogue: 0,0:22:41.24,0:22:43.00,Chinese,,0,0,0,,所以有两种版本的「加速比」
Dialogue: 0,0:22:43.02,0:22:48.06,English,,0,0,0,,One is if I take my multi-threaded routine and run it with one thread
Dialogue: 0,0:22:43.02,0:22:48.06,Chinese,,0,0,0,,一个是我采用多线程例程并用一个线程（核心）运行它
Dialogue: 0,0:22:48.72,0:22:51.54,English,,0,0,0,,And then I met do it with p threads or cores
Dialogue: 0,0:22:48.72,0:22:51.54,Chinese,,0,0,0,,然后比上 P 个线程或者核心的运行时间
Dialogue: 0,0:22:52.16,0:22:53.18,English,,0,0,0,,I can get a speedup
Dialogue: 0,0:22:52.16,0:22:53.18,Chinese,,0,0,0,,我得到一个（相对）加速比
Dialogue: 0,0:22:53.18,0:22:54.84,English,,0,0,0,,But actually the true thing is
Dialogue: 0,0:22:53.18,0:22:54.84,Chinese,,0,0,0,,但更准确的做法是
Dialogue: 0,0:22:54.84,0:23:02.12,English,,0,0,0,,If I take the best-known sequential algorithm for performing this task with the best implementation of that
Dialogue: 0,0:22:54.84,0:23:02.12,Chinese,,0,0,0,,采用最好的顺序算法用最好的实践来执行此任务
Dialogue: 0,0:23:02.74,0:23:04.82,English,,0,0,0,,And then compare it against my parallel one
Dialogue: 0,0:23:02.74,0:23:04.82,Chinese,,0,0,0,,然后将它与我的并行比较
Dialogue: 0,0:23:04.84,0:23:10.22,English,,0,0,0,,And so that's referred to as absolute speedup which is the best measures
Dialogue: 0,0:23:04.84,0:23:10.22,Chinese,,0,0,0,,所以这被称为「绝对加速比」 ，也是更真实的指标
Dialogue: 0,0:23:10.22,0:23:17.14,English,,0,0,0,, You know you give both sides the opportunity to do the best implementation that they can  And then you compare it
Dialogue: 0,0:23:10.22,0:23:17.14,Chinese,,0,0,0,,因为让双方都有机会做到它们可以最好的实施，之后你比较它们
Dialogue: 0,0:23:18.08,0:23:24.12,English,,0,0,0,,And then what's referred to as the efficiency is how close to the speedup get to the ideal speedup？
Dialogue: 0,0:23:18.08,0:23:24.12,Chinese,,0,0,0,,另一个相关的指标是「效率（efficiency）」指的是靠近理想加速比的程度
Dialogue: 0,0:23:24.12,0:23:28.18,English,,0,0,0,,Which is if I'm running on p cores I should be p times faster
Dialogue: 0,0:23:24.12,0:23:28.18,Chinese,,0,0,0,,如果我在 P 核上运行，我应该快 P 倍
Dialogue: 0,0:23:28.88,0:23:30.14,English,,0,0,0,,And you'll see that we're
Dialogue: 0,0:23:28.88,0:23:30.14,Chinese,,0,0,0,,你会看到我们是......
Dialogue: 0,0:23:30.78,0:23:35.44,English,,0,0,0,,You know the question of hyper-threading versus not we're sort of here we're saying no you don't
Dialogue: 0,0:23:30.78,0:23:35.44,Chinese,,0,0,0,,你知道超线程的问题，而不是我们在这里说不
Dialogue: 0,0:23:36.38,0:23:39.42,English,,0,0,0,,We're not (trying to) gaining from hyper-threading
Dialogue: 0,0:23:36.38,0:23:39.42,Chinese,,0,0,0,,我们不会从超线程中获益
Dialogue: 0,0:23:40.08,0:23:46.54,English,,0,0,0,,You can play this game various ways and you can argue back and forth Whether hyper-threading should count
Dialogue: 0,0:23:40.08,0:23:46.54,Chinese,,0,0,0,,你可以通过多种方式玩此游戏，还可以反复验证是否应该考虑超线程
Dialogue: 0,0:23:46.64,0:23:53.02,English,,0,0,0,,So for p is p the total number of possible threads or the total number of cores
Dialogue: 0,0:23:46.64,0:23:53.02,Chinese,,0,0,0,,因此，p 是线程总数或核心总数
Dialogue: 0,0:23:53.14,0:23:58.40,English,,0,0,0,,It's really a something to argue back and forth about
Dialogue: 0,0:23:53.14,0:23:58.40,Chinese,,0,0,0,,这真的是一种反复验证的东西
Dialogue: 0,0:24:00.24,0:24:08.74,English,,0,0,0,,So the point is the efficiency though is is measured as how much do we do relative to ideal
Dialogue: 0,0:24:00.24,0:24:08.74,Chinese,,0,0,0,,所以关键在于「效率」是衡量我们相对于理想的程度
Dialogue: 0,0:24:08.82,0:24:13.16,English,,0,0,0,,And so this is what you get for this code the local version of psum
Dialogue: 0,0:24:08.82,0:24:13.16,Chinese,,0,0,0,,你可以通过这段代码 psum-local 获得这个表格
Dialogue: 0,0:24:13.86,0:24:19.22,English,,0,0,0,,You'll see that the efficiency numbers are somewhere in the high somebody range
Dialogue: 0,0:24:13.86,0:24:19.22,Chinese,,0,0,0,,你会发现「效率」在一定的范围内（0～100）
Dialogue: 0,0:24:21.08,0:24:22.26,English,,0,0,0,,Which is good but not great
Dialogue: 0,0:24:21.08,0:24:22.26,Chinese,,0,0,0,,这很好，但不够好
Dialogue: 0,0:24:22.98,0:24:26.32,English,,0,0,0,,It's pretty good actually if you can get 75 percent efficiency
Dialogue: 0,0:24:22.98,0:24:26.32,Chinese,,0,0,0,,如果你的效率是 75 ％，那真的很不错
Dialogue: 0,0:24:26.80,0:24:31.62,English,,0,0,0,,You're doing better than most but again that's because this should have been the world's easiest program to parallelize
Dialogue: 0,0:24:26.80,0:24:31.62,Chinese,,0,0,0,,你做得比大多数好，是因为这应该是世界上最简单的并行化程序
Dialogue: 0,0:24:33.94,0:24:40.84,English,,0,0,0,,So the best speedup we're getting is a factor of six out of 8 cores
Dialogue: 0,0:24:33.94,0:24:40.84,Chinese,,0,0,0,,我们在 8 核的情况下得到最好的加速比，值超过了 6
Dialogue: 0,0:24:41.32,0:24:45.58,English,,0,0,0,,Again that's pretty good but this really should be something you can do well
Dialogue: 0,0:24:41.32,0:24:45.58,Chinese,,0,0,0,,再次强调这是非常好的，但这应该是你可以做得很好的情况
Dialogue: 0,0:24:47.74,0:24:52.96,English,,0,0,0,,So that just gives you a flavor of what parallel computing can be
Dialogue: 0,0:24:47.74,0:24:52.96,Chinese,,0,0,0,,这样只是让你了解并行计算的特点
Dialogue: 0,0:24:54.08,0:24:59.44,English,,0,0,0,,So now it's sort of back off and talk some general principles just like the speed-up
Dialogue: 0,0:24:54.08,0:24:59.44,Chinese,,0,0,0,,现在回过头来谈论一些一般原则，比如加速比
Dialogue: 0,0:25:00.80,0:25:04.80,English,,0,0,0,,There's a fella named Gene Amdahl who coincidentally just died a few weeks ago
Dialogue: 0,0:25:00.80,0:25:04.80,Chinese,,0,0,0,,有一个名叫 Gene Amdahl 的工程师几个星期前刚刚去世（2015年）
Dialogue: 0,0:25:04.84,0:25:06.28,English,,0,0,0,,He might have seen it in the news
Dialogue: 0,0:25:04.84,0:25:06.28,Chinese,,0,0,0,,可能在新闻中看到他
Dialogue: 0,0:25:06.72,0:25:11.42,English,,0,0,0,,He was one of the original pioneers at IBM in their mainframe computers
Dialogue: 0,0:25:06.72,0:25:11.42,Chinese,,0,0,0,,他是 IBM 大型计算机领域最初的先驱之一
Dialogue: 0,0:25:12.36,0:25:16.48,English,,0,0,0,,Then then at some point he in the 60s
Dialogue: 0,0:25:12.36,0:25:16.48,Chinese,,0,0,0,,他在 60 年代
Dialogue: 0,0:25:16.88,0:25:19.48,English,,0,0,0,,He started his own company called Amdahl Computers
Dialogue: 0,0:25:16.88,0:25:19.48,Chinese,,0,0,0,,他创办了自己的公司 「阿姆达尔公司」
Dialogue: 0,0:25:19.48,0:25:27.36,English,,0,0,0,,And they were like they were the cool company in mainframe computers if that could ever be considered cool right
Dialogue: 0,0:25:19.48,0:25:27.36,Chinese,,0,0,0,,他们是大型计算机领域很酷的一家公司
Dialogue: 0,0:25:28.28,0:25:33.04,English,,0,0,0,,And he built a competitor's to IBM that absolutely drove them crazy
Dialogue: 0,0:25:28.28,0:25:33.04,Chinese,,0,0,0,,他成为 IBM 的一个竞争对手，并且让他们抓狂
Dialogue: 0,0:25:33.06,0:25:38.79,English,,0,0,0,,Because they had a virtual monopoly they actually were subject to antitrust suit
Dialogue: 0,0:25:33.06,0:25:38.79,Chinese,,0,0,0,,因为他们实际上是垄断的，所以他们受到了反垄断诉讼
Dialogue: 0,0:25:38.88,0:25:45.80,English,,0,0,0,,So Amdahl was a sort of the the rebel who broke away from the mother company and started a competitor
Dialogue: 0,0:25:38.88,0:25:45.80,Chinese,,0,0,0,,所以阿姆达尔是一个叛逆者，他脱离了母公司并成为母公司的竞争对手
Dialogue: 0,0:25:47.74,0:25:51.44,English,,0,0,0,,And he made this very simple observation that's called Amdahl law
Dialogue: 0,0:25:47.74,0:25:51.44,Chinese,,0,0,0,,他提出一个非常简单的量化标准，叫做「阿姆达尔定律」
Dialogue: 0,0:25:51.44,0:25:59.20,English,,0,0,0,,Which is...Basically junior high level algebra to think of this but it's actually a fairly perceptive point
Dialogue: 0,0:25:51.44,0:25:59.20,Chinese,,0,0,0,,基于初级高级代数，但实际上这是一个相当敏感的观点
Dialogue: 0,0:26:00.02,0:26:03.74,English,,0,0,0,,About what's the possible benefit of speeding up something
Dialogue: 0,0:26:00.02,0:26:03.74,Chinese,,0,0,0,,关于提升效率的能力
Dialogue: 0,0:26:04.14,0:26:05.72,English,,0,0,0,,And this is discussed in the book
Dialogue: 0,0:26:04.14,0:26:05.72,Chinese,,0,0,0,,这在书中有讨论
Dialogue: 0,0:26:06.16,0:26:09.78,English,,0,0,0,,You know this isn't just for computers it's any process that you want to speed up
Dialogue: 0,0:26:06.16,0:26:09.78,Chinese,,0,0,0,,这不仅仅适用于计算机，也适用与你希望加速的任何过程
Dialogue: 0,0:26:10.40,0:26:11.98,English,,0,0,0,,And it's a very simple observation
Dialogue: 0,0:26:10.40,0:26:11.98,Chinese,,0,0,0,,这是一个非常简单的量化标准
Dialogue: 0,0:26:11.98,0:26:19.90,English,,0,0,0,,Which is suppose there's some fraction of a system that I can make go faster and I'll call that fraction P
Dialogue: 0,0:26:11.98,0:26:19.90,Chinese,,0,0,0,,假设我为系统变快打分，并将这个分数称为 p
Dialogue: 0,0:26:20.44,0:26:26.72,English,,0,0,0,,P is some number between zero and one point zero right 100% 0%
Dialogue: 0,0:26:20.44,0:26:26.72,Chinese,,0,0,0,, P 的范围在 0 到 1 之间（0 <= p <= 1），100％，0％
Dialogue: 0,0:26:27.96,0:26:31.46,English,,0,0,0,,And let's suppose we take that part that we're going to make run faster
Dialogue: 0,0:26:27.96,0:26:31.46,Chinese,,0,0,0,,让我们假设我们采取那一部分，我们将更快地运行
Dialogue: 0,0:26:31.86,0:26:34.24,English,,0,0,0,,And improve its performance by a factor K
Dialogue: 0,0:26:31.86,0:26:34.24,Chinese,,0,0,0,,并通过 k 提高其性能
Dialogue: 0,0:26:37.08,0:26:44.10,English,,0,0,0,,Then we can just very simply talk about what will be the benefit of that performance so we'll call it T(k)
Dialogue: 0,0:26:37.08,0:26:44.10,Chinese,,0,0,0,,然后我们可以清楚的看到哪些对性能 T(k) 有好处
Dialogue: 0,0:26:44.74,0:26:52.00,English,,0,0,0,,And what it says is the fraction p of the time will be reduced by k
Dialogue: 0,0:26:44.74,0:26:52.00,Chinese,,0,0,0,,T(k) 和 p 成正比，和 k 成反比
Dialogue: 0,0:26:52.98,0:26:59.30,English,,0,0,0,,But the fraction that you can't change a 1-p will remain at its old time
Dialogue: 0,0:26:52.98,0:26:59.30,Chinese,,0,0,0,,但是你不能改变 p，所以 1 - p 也不会改变
Dialogue: 0,0:27:00.07,0:27:03.56,English,,0,0,0,,And that's Amdahl law that's it,that's the whole thing
Dialogue: 0,0:27:00.07,0:27:03.56,Chinese,,0,0,0,,这就是 Amdahl 法则就是这样，这就是整个事情
Dialogue: 0,0:27:03.98,0:27:05.46,English,,0,0,0,,And one interesting measure
Dialogue: 0,0:27:03.98,0:27:05.46,Chinese,,0,0,0,,还有一个有趣的措施
Dialogue: 0,0:27:05.94,0:27:11.00,English,,0,0,0,,What if k were infinity what if we had unbounded resources to speed things up
Dialogue: 0,0:27:05.94,0:27:11.00,Chinese,,0,0,0,,如果 k 是 ∞，如果我们有无限的资源加速的话会怎么样？
Dialogue: 0,0:27:11.86,0:27:18.92,English,,0,0,0,,And what the observation is the best feed up you'll get is a 1-p
Dialogue: 0,0:27:11.86,0:27:18.92,Chinese,,0,0,0,,而观察结果是你获得的最佳效果是 1 - p
Dialogue: 0,0:27:20.44,0:27:24.88,English,,0,0,0,,And so just think it this way if you have 10% of it that you can't change
Dialogue: 0,0:27:20.44,0:27:24.88,Chinese,,0,0,0,,因此，如果你有 10％ 的不可改变的话
Dialogue: 0,0:27:26.02,0:27:29.56,English,,0,0,0,,The other 90% you make infinitely fast
Dialogue: 0,0:27:26.02,0:27:29.56,Chinese,,0,0,0,,另外 90％ 你做得非常快
Dialogue: 0,0:27:31.24,0:27:33.76,English,,0,0,0,,Then your performance improvement will be a factor of 10
Dialogue: 0,0:27:31.24,0:27:33.76,Chinese,,0,0,0,,那么你的性能由这 10% 的因素决定
Dialogue: 0,0:27:34.16,0:27:37.32,English,,0,0,0,,That's really all it's saying right pretty straightforward idea
Dialogue: 0,0:27:34.16,0:27:37.32,Chinese,,0,0,0,,这就是非常直接的想法
Dialogue: 0,0:27:38.56,0:27:41.10,English,,0,0,0,,So this has sort of direct implications in
Dialogue: 0,0:27:38.56,0:27:41.10,Chinese,,0,0,0,,所以这有一些直接影响
Dialogue: 0,0:27:41.40,0:27:48.00,English,,0,0,0,,So the example is suppose that we can improve the performance of some system of 90% of it
Dialogue: 0,0:27:41.40,0:27:48.00,Chinese,,0,0,0,,举个例子，假设我们可以提高某些系统的 90％ 的性能
Dialogue: 0,0:27:49.04,0:27:53.22,English,,0,0,0,,And we can speed up by factor 9 and that number is chosen to make the numbers work out
Dialogue: 0,0:27:49.04,0:27:53.22,Chinese,,0,0,0,,并且我们假设加速比是 9
Dialogue: 0,0:27:53.72,0:27:57.22,English,,0,0,0,,Then we'll get it best at 2x performance improvement
Dialogue: 0,0:27:53.72,0:27:57.22,Chinese,,0,0,0,,那么我们能获得最好的情况是性能提升 2 倍
Dialogue: 0,0:27:57.66,0:28:02.64,English,,0,0,0,,Basically what it says is the part of the system that you can't speed up will become your bottleneck
Dialogue: 0,0:27:57.66,0:28:02.64,Chinese,,0,0,0,,基本上它说明了的系统中你无法加速的部分将成为你的瓶颈
Dialogue: 0,0:28:04.02,0:28:06.08,English,,0,0,0,,And that's just the way it is
Dialogue: 0,0:28:04.02,0:28:06.08,Chinese,,0,0,0,,这就是它的方式
Dialogue: 0,0:28:06.24,0:28:09.58,English,,0,0,0,,So the implications for this repair while programming are fairly obvious
Dialogue: 0,0:28:06.24,0:28:09.58,Chinese,,0,0,0,,因此编程时修复这些对性能提升相当明显
Dialogue: 0,0:28:09.74,0:28:14.00,English,,0,0,0,,That if we can take our application and chop off some fraction of it
Dialogue: 0,0:28:09.74,0:28:14.00,Chinese,,0,0,0,,如果我们可以让我们的应用程序去掉这部分
Dialogue: 0,0:28:14.60,0:28:18.18,English,,0,0,0,,And make it run k times faster by running it on k cores
Dialogue: 0,0:28:14.60,0:28:18.18,Chinese,,0,0,0,,那么可以在 K 核上性能提升 K 倍
Dialogue: 0,0:28:19.74,0:28:28.12,English,,0,0,0,,Then the part of it that's still running sequentially will come to will limit the ultimate performance
Dialogue: 0,0:28:19.74,0:28:28.12,Chinese,,0,0,0,,然后它按顺序运行的部分将限制最终性能
Dialogue: 0,0:28:30.18,0:28:33.62,English,,0,0,0,,We can get so that's not really an issue for this summation problem
Dialogue: 0,0:28:30.18,0:28:33.62,Chinese,,0,0,0,,我们可以看出这不单单是一个求和问题
Dialogue: 0,0:28:33.62,0:28:37.56,English,,0,0,0,,Because it really does divide into as many independent tasks
Dialogue: 0,0:28:33.62,0:28:37.56,Chinese,,0,0,0,,因为它被分成了许多独立的任务
Dialogue: 0,0:28:37.76,0:28:42.60,English,,0,0,0,,As you have numbers and as you can see you can make them run
Dialogue: 0,0:28:37.76,0:28:42.60,Chinese,,0,0,0,,就像你有数字，或者如你所见，你可以让它们运行
Dialogue: 0,0:28:42.60,0:28:46.64,English,,0,0,0,,But many other applications do some part of it that I can't really make know parallel
Dialogue: 0,0:28:42.60,0:28:46.64,Chinese,,0,0,0,,但是许多其他应用程序在其中做了一些我无法实现并行的部分
Dialogue: 0,0:28:49.42,0:28:54.10,English,,0,0,0,,So just as an example and just for the sake of this class
Dialogue: 0,0:28:49.42,0:28:54.10,Chinese,,0,0,0,,所以只是一个例子，也只是为了这们课
Dialogue: 0,0:28:54.28,0:28:59.70,English,,0,0,0,,You know an example of a little bit more involved a problem in parallel programming and multi-threading
Dialogue: 0,0:28:54.28,0:28:59.70,Chinese,,0,0,0,,你知道很多例子都涉及并行编程和多线程问题
Dialogue: 0,0:29:00.10,0:29:02.44,English,,0,0,0,,Let's think about sorting a bunch of numbers
Dialogue: 0,0:29:00.10,0:29:02.44,Chinese,,0,0,0,,我们来考虑排序一堆数字
Dialogue: 0,0:29:02.52,0:29:05.84,English,,0,0,0,,So we have n numbers and we want to sort them
Dialogue: 0,0:29:02.52,0:29:05.84,Chinese,,0,0,0,,我们有 n 个数字，要对它们进行排序
Dialogue: 0,0:29:08.86,0:29:14.74,English,,0,0,0,,And we have some number of threads that we can do this with
Dialogue: 0,0:29:08.86,0:29:14.74,Chinese,,0,0,0,,而且我们可以使用多线程来处理
Dialogue: 0,0:29:14.74,0:29:16.52,English,,0,0,0,,Is there way we can speed this up？
Dialogue: 0,0:29:14.74,0:29:16.52,Chinese,,0,0,0,,有什么办法可以加度吗？
Dialogue: 0,0:29:17.30,0:29:20.26,English,,0,0,0,,And you think about it's not that clear how you do it
Dialogue: 0,0:29:17.30,0:29:20.26,Chinese,,0,0,0,,你想想你该怎么做，并不是很容易搞清楚
Dialogue: 0,0:29:20.26,0:29:23.28,English,,0,0,0,,There's actually a vast literature in parallel sorting
Dialogue: 0,0:29:20.26,0:29:23.28,Chinese,,0,0,0,,实际上有大量并行排序的文献
Dialogue: 0,0:29:23.76,0:29:29.24,English,,0,0,0,,And those you've taken or will take the class 210 will be exposed to a lot of this
Dialogue: 0,0:29:23.76,0:29:29.24,Chinese,,0,0,0,,那些已经或将要参加课程 210 的同学会接触到很多这样的知识
Dialogue: 0,0:29:29.76,0:29:32.80,English,,0,0,0,,But I'm just going to do a very simple version which is quicksort
Dialogue: 0,0:29:29.76,0:29:32.80,Chinese,,0,0,0,,但我只是想做一个非常简单的「快排」版本
Dialogue: 0,0:29:34.16,0:29:36.68,English,,0,0,0,,So quicksort is for example the
Dialogue: 0,0:29:34.16,0:29:36.68,Chinese,,0,0,0,,快速排序是......
Dialogue: 0,0:29:40.78,0:29:43.70,English,,0,0,0,,The C library program qsort is quicksort
Dialogue: 0,0:29:40.78,0:29:43.70,Chinese,,0,0,0,,C 语言库函数 qsort 就是「快排」
Dialogue: 0,0:29:43.70,0:29:50.72,English,,0,0,0,, it was invented in the early 1960s or 1950s by a guy named Tony Hoare
Dialogue: 0,0:29:43.70,0:29:50.72,Chinese,,0,0,0,,它大概是在上世纪 50， 60 年代由「东尼・霍尔」发明的
Dialogue: 0,0:29:51.58,0:29:55.12,English,,0,0,0,,Who also founded a lot of the fundamental logic of program
Dialogue: 0,0:29:51.58,0:29:55.12,Chinese,,0,0,0,,他也发明了很多程序的基本逻辑
Dialogue: 0,0:29:55.24,0:30:00.96,English,,0,0,0,,So he's like an amazing person still alive today lives in Cambridge England
Dialogue: 0,0:29:55.24,0:30:00.96,Chinese,,0,0,0,,他是一个传奇人物，现在依然生活在英国剑桥
Dialogue: 0,0:30:01.56,0:30:07.42,English,,0,0,0,,But if you ever have a chance to go to a talk by him do so he's amazing person
Dialogue: 0,0:30:01.56,0:30:07.42,Chinese,,0,0,0,,如果你有机会去听他的演讲，你就会发现他是一个很棒的人
Dialogue: 0,0:30:08.14,0:30:13.82,English,,0,0,0,,Anyways the idea quicksort is very simple and this is sort of the basic sorting algorithm
Dialogue: 0,0:30:08.14,0:30:13.82,Chinese,,0,0,0,,无论如何，「快排」的思想非常简单，它一种基本的排序算法
Dialogue: 0,0:30:13.84,0:30:19.68,English,,0,0,0,,You grab some element from the array that you're trying to sort that's called the pivot
Dialogue: 0,0:30:13.84,0:30:19.68,Chinese,,0,0,0,,你要从需要排序数列中挑出一个元素，称为 「基准」（pivot）
Dialogue: 0,0:30:20.42,0:30:27.68,English,,0,0,0,,And then you split the data so that you look at the elements that are either greater or less than the pivot
Dialogue: 0,0:30:20.42,0:30:27.68,Chinese,,0,0,0,,然后把大于和小于「基准」的数分开
Dialogue: 0,0:30:28.10,0:30:32.02,English,,0,0,0,,And potentially also equal let's just assume all the elements are unique here
Dialogue: 0,0:30:28.10,0:30:32.02,Chinese,,0,0,0,,同事也存在等于（基准）元素，这里我们假设所有元素都是唯一的
Dialogue: 0,0:30:32.56,0:30:36.94,English,,0,0,0,,So you just split it into two piles one is the less, one is a greater
Dialogue: 0,0:30:32.56,0:30:36.94,Chinese,,0,0,0,,所以你需要把数组分成两堆，一个小于基准，一个大于基准
Dialogue: 0,0:30:37.42,0:30:41.12,English,,0,0,0,,Now you creatively you recursively you sort those two piles
Dialogue: 0,0:30:37.42,0:30:41.12,Chinese,,0,0,0,,现在你对这两堆元素进行递归排序
Dialogue: 0,0:30:42.50,0:30:46.42,English,,0,0,0,,By the same method and when it's all done you end up with everything sorted
Dialogue: 0,0:30:42.50,0:30:46.42,Chinese,,0,0,0,,用同样的方法，当它们全部完成时，你会得到已排好序的数组
Dialogue: 0,0:30:46.86,0:30:49.34,English,,0,0,0,,One nice thing about it is,it can be done in place
Dialogue: 0,0:30:46.86,0:30:49.34,Chinese,,0,0,0,,快排有一个好处是它可以在「原地」完成排序
Dialogue: 0,0:30:49.34,0:30:57.36,English,,0,0,0,,Meaning if you have an array of data you can do this all just by swapping elements around and not have to use any extra space
Dialogue: 0,0:30:49.34,0:30:57.36,Chinese,,0,0,0,,意思是如果你要对数组进行排序，你可以通过交换元素来完成，而不需要额外的空间
Dialogue: 0,0:30:57.36,0:30:59.44,English,,0,0,0,,Which you would for example with merge sort
Dialogue: 0,0:30:57.36,0:30:59.44,Chinese,,0,0,0,,「归并排序」需要额外的空间
Dialogue: 0,0:31:00.14,0:31:05.28,English,,0,0,0,,So this is a fairly simple algorithm and just to visualize it then
Dialogue: 0,0:31:00.14,0:31:05.28,Chinese,,0,0,0,,所以「快排」是一个相当简单的算法
Dialogue: 0,0:31:06.06,0:31:09.62,English,,0,0,0,,You have some block of data X array and you want to sort it
Dialogue: 0,0:31:06.06,0:31:09.62,Chinese,,0,0,0,,想象一下，你有一个数组 X ，想要对它进行排序
Dialogue: 0,0:31:09.70,0:31:13.70,English,,0,0,0,,So you pick an element called the pivot and there's various strategies for doing that
Dialogue: 0,0:31:09.70,0:31:13.70,Chinese,,0,0,0,,然后你选出一个基准元素 p，挑选基准元素有很多策略
Dialogue: 0,0:31:14.88,0:31:19.42,English,,0,0,0,,And now you just subdivide X into three parts
Dialogue: 0,0:31:14.88,0:31:19.42,Chinese,,0,0,0,,现在你只需将数组 X 分为三个部分
Dialogue: 0,0:31:19.56,0:31:24.52,English,,0,0,0,,L the left hand, other right hand meaning less and greater than p
Dialogue: 0,0:31:19.56,0:31:24.52,Chinese,,0,0,0,,p 左边的 L 小于 p，右边的 R 大于 p
Dialogue: 0,0:31:25.06,0:31:26.82,English,,0,0,0,,And then you place p in the middle
Dialogue: 0,0:31:25.06,0:31:26.82,Chinese,,0,0,0,,然后你把 p 放在中间
Dialogue: 0,0:31:27.78,0:31:33.48,English,,0,0,0,,And then you recursively when you're doing this for in a sequential code
Dialogue: 0,0:31:27.78,0:31:33.48,Chinese,,0,0,0,,然后，你可以在顺序执行代码中进行递归操作
Dialogue: 0,0:31:33.48,0:31:39.03,English,,0,0,0,,You'll pick one of these two usually leftmost or rightmost whatever doesn't really matter
Dialogue: 0,0:31:33.48,0:31:39.03,Chinese,,0,0,0,,然后你在 L 中选择一个基准，通常是最左边的或者最右边的元素，也可以是其中任意一个元素
Dialogue: 0,0:31:39.40,0:31:46.57,English,,0,0,0,,And you'll recursively you apply the same method to the left side and
Dialogue: 0,0:31:39.40,0:31:46.57,Chinese,,0,0,0,,并且使用同样的方法对左边的元素进行递归
Dialogue: 0,0:31:46.86,0:31:51.96,English,,0,0,0,,And ultimately after enough recursions you get to the point where L has been sorted
Dialogue: 0,0:31:46.86,0:31:51.96,Chinese,,0,0,0,,最终，递归完成后 ，L 就已排好序了
Dialogue: 0,0:31:52.24,0:31:57.04,English,,0,0,0,,And that's shown in this kind of a swishy color thing and call that L'
Dialogue: 0,0:31:52.24,0:31:57.04,Chinese,,0,0,0,,这里用这种闪闪发光的颜色表示并称之为 L'
Dialogue: 0,0:31:57.98,0:31:59.30,English,,0,0,0,,And same with
Dialogue: 0,0:31:57.98,0:31:59.30,Chinese,,0,0,0,,同样
Dialogue: 0,0:32:03.86,0:32:07.16,English,,0,0,0,,You'll do the same thing now with the right hand side
Dialogue: 0,0:32:03.86,0:32:07.16,Chinese,,0,0,0,,同样在右边也是如此
Dialogue: 0,0:32:07.62,0:32:10.14,English,,0,0,0,,And when you're done this is usually done in place
Dialogue: 0,0:32:07.62,0:32:10.14,Chinese,,0,0,0,,通常会在原地完成所有的事情
Dialogue: 0,0:32:10.28,0:32:16.52,English,,0,0,0,,So you just the L part works on one array part of the array and the are other part on another
Dialogue: 0,0:32:10.28,0:32:16.52,Chinese,,0,0,0,,L 就在原来的数组中完成了排序，另一边也是在原数组中完成
Dialogue: 0,0:32:16.94,0:32:18.38,English,,0,0,0,,And when you're done they're in sorted order
Dialogue: 0,0:32:16.94,0:32:18.38,Chinese,,0,0,0,,当你完成时，整个数组就是排好序的了
Dialogue: 0,0:32:20.26,0:32:23.18,English,,0,0,0,,The very simple sort and generally has very good performance
Dialogue: 0,0:32:20.26,0:32:23.18,Chinese,,0,0,0,,这是非常简单的排序算法，而且大多是情况性能非常好
Dialogue: 0,0:32:24.64,0:32:30.54,English,,0,0,0,,So this is what the code for it looks like which is usually you have is a special case
Dialogue: 0,0:32:24.64,0:32:30.54,Chinese,,0,0,0,,这是一个段「快排」的代码，其中有两个特殊情况
Dialogue: 0,0:32:30.54,0:32:31.94,English,,0,0,0,,If there's only one or two elements
Dialogue: 0,0:32:30.54,0:32:31.94,Chinese,,0,0,0,,就是在只有一两个元素的时候
Dialogue: 0,0:32:33.04,0:32:35.28,English,,0,0,0,,And then you do this partitioning
Dialogue: 0,0:32:33.04,0:32:35.28,Chinese,,0,0,0,,除此之外你要分区处理
Dialogue: 0,0:32:35.28,0:32:41.50,English,,0,0,0,,So this routine of splitting it between the left and the right hand part is handled by a function called partition
Dialogue: 0,0:32:35.28,0:32:41.50,Chinese,,0,0,0,,这里有一个函数 partition 会把它分成左右两部分
Dialogue: 0,0:32:42.36,0:32:48.10,English,,0,0,0,,And then if there's more than one element in the left side you sort that
Dialogue: 0,0:32:42.36,0:32:48.10,Chinese,,0,0,0,,如果左边的元素大于 1 的话，继续进行递归
Dialogue: 0,0:32:48.72,0:32:51.92,English,,0,0,0,,And if there's more than one element in the right hand side you sort that
Dialogue: 0,0:32:48.72,0:32:51.92,Chinese,,0,0,0,,同样，如果右边也大于 1 个元素的话，就继续对它进行排序
Dialogue: 0,0:32:53.68,0:32:58.66,English,,0,0,0,,And then when all these recursions are done then the array is sorted
Dialogue: 0,0:32:53.68,0:32:58.66,Chinese,,0,0,0,,当所有的递归完成之后，数组就排序好了
Dialogue: 0,0:32:59.30,0:33:04.04,English,,0,0,0,,So pretty typical code and we won't go in the trickiest part writing the code is
Dialogue: 0,0:32:59.30,0:33:04.04,Chinese,,0,0,0,,这是非常典型的快排代码，这里并没有写最难部分的代码
Dialogue: 0,0:33:04.12,0:33:10.18,English,,0,0,0,,How do you make this partitioning go fast But I won't go into that just imagine it happens
Dialogue: 0,0:33:04.12,0:33:10.18,Chinese,,0,0,0,,如何让 partition 变得更快？我这里不会深入，你们可以思考一下
Dialogue: 0,0:33:11.74,0:33:15.90,English,,0,0,0,,So this algorithm actually has a natural version of parallelism
Dialogue: 0,0:33:11.74,0:33:15.90,Chinese,,0,0,0,,实际上这个算法有一个自然版的并行化算法
Dialogue: 0,0:33:16.28,0:33:20.58,English,,0,0,0,,Which is in my sequential version I was sorting both first the left
Dialogue: 0,0:33:16.28,0:33:20.58,Chinese,,0,0,0,,在我的顺序版本中，我首先对左边排序
Dialogue: 0,0:33:20.72,0:33:24.98,English,,0,0,0,,And then the left,the left and the left,the left,the left and kind of working my way
Dialogue: 0,0:33:20.72,0:33:24.98,Chinese,,0,0,0,,然后向左，向左，向左，向左......就像这样
Dialogue: 0,0:33:25.40,0:33:27.50,English,,0,0,0,,Until I got that whole array sorted
Dialogue: 0,0:33:25.40,0:33:27.50,Chinese,,0,0,0,,直到整个数组排好序
Dialogue: 0,0:33:27.78,0:33:30.44,English,,0,0,0,,And then I was coming back and I was working on the right
Dialogue: 0,0:33:27.78,0:33:30.44,Chinese,,0,0,0,,然后我回来对右边进行排序
Dialogue: 0,0:33:30.44,0:33:33.82,English,,0,0,0,,And then the left part of the right and the left to the left to the right and blah blah blah
Dialogue: 0,0:33:30.44,0:33:33.82,Chinese,,0,0,0,,然后是右边的左边部分和左边的左边部分，等等等等等等
Dialogue: 0,0:33:34.44,0:33:37.54,English,,0,0,0,,And doing these recursions because the way the codes written
Dialogue: 0,0:33:34.44,0:33:37.54,Chinese,,0,0,0,,然后按照代码的方进行递归
Dialogue: 0,0:33:40.18,0:33:44.50,English,,0,0,0,,Right I am doing the full sort of the left-hand part
Dialogue: 0,0:33:40.18,0:33:44.50,Chinese,,0,0,0,,这里我正在排序左边的部分
Dialogue: 0,0:33:45.16,0:33:49.60,English,,0,0,0,,And only after that is sorted then I'm doing the complete sort of the right-hand part
Dialogue: 0,0:33:45.16,0:33:49.60,Chinese,,0,0,0,,只有在左边的部分排序好了之后，我才能进行右边部分
Dialogue: 0,0:33:49.78,0:33:56.94,English,,0,0,0,,So the point is it's an algorithm where I'm working just on one part of the array of the time
Dialogue: 0,0:33:49.78,0:33:56.94,Chinese,,0,0,0,,这个算法的重点是同一时间我只能对一部分进行排序
Dialogue: 0,0:33:58.10,0:34:01.86,English,,0,0,0,,But there's a very natural recursion of parallelism here that says
Dialogue: 0,0:33:58.10,0:34:01.86,Chinese,,0,0,0,,但是这里有一个非常自然想法就是并行递归
Dialogue: 0,0:34:02.30,0:34:05.84,English,,0,0,0,,Okay I've got two parts they each need to be sorted
Dialogue: 0,0:34:02.30,0:34:05.84,Chinese,,0,0,0,,好的，我有两个部分，他们每个都需要排序
Dialogue: 0,0:34:06.28,0:34:10.76,English,,0,0,0,,Let me just fire off two threads and let them do with that
Dialogue: 0,0:34:06.28,0:34:10.76,Chinese,,0,0,0,,让我开启两个线程来处理
Dialogue: 0,0:34:12.30,0:34:16.54,English,,0,0,0,,And that's the...So it's what you call divide and conquer parallelism
Dialogue: 0,0:34:12.30,0:34:16.54,Chinese,,0,0,0,,这称为并行「分治」
Dialogue: 0,0:34:16.60,0:34:20.38,English,,0,0,0,,It's a very natural kind of parallelism it shows up in this code
Dialogue: 0,0:34:16.60,0:34:20.38,Chinese,,0,0,0,,想这里展示的的一样，这是一种非常自然的并行性
Dialogue: 0,0:34:23.40,0:34:26.68,English,,0,0,0,,So basically I'll do the same thing as before all at
Dialogue: 0,0:34:23.40,0:34:26.68,Chinese,,0,0,0,,所以一开始我会做同样的事情
Dialogue: 0,0:34:26.90,0:34:31.44,English,,0,0,0,,The top level will be a purely sequential process of partitioning
Dialogue: 0,0:34:26.90,0:34:31.44,Chinese,,0,0,0,,最开始是纯粹顺序的分区
Dialogue: 0,0:34:32.60,0:34:38.50,English,,0,0,0,,And but then assuming a partition comes up with some non-trivial split
Dialogue: 0,0:34:32.60,0:34:38.50,Chinese,,0,0,0,,然而，假设一个分区出现了一些非平凡的分裂
Dialogue: 0,0:34:39.08,0:34:44.28,English,,0,0,0,,Then I will recursively begin fork of two threads
Dialogue: 0,0:34:39.08,0:34:44.28,Chinese,,0,0,0,,我会开启两个线程进行递归
Dialogue: 0,0:34:44.94,0:34:47.40,English,,0,0,0,,Each of which will be responsible for the other and
Dialogue: 0,0:34:44.94,0:34:47.40,Chinese,,0,0,0,,每一个线程负责一部分
Dialogue: 0,0:34:47.40,0:34:51.44,English,,0,0,0,,So we'll sort of look like I'm working on the two parts in parallel
Dialogue: 0,0:34:47.40,0:34:51.44,Chinese,,0,0,0,,看起来我在并行地处理两个部分
Dialogue: 0,0:34:52.26,0:34:54.68,English,,0,0,0,,And eventually both sides will end up
Dialogue: 0,0:34:52.26,0:34:54.68,Chinese,,0,0,0,,最终双方都会结束
Dialogue: 0,0:34:55.18,0:34:59.08,English,,0,0,0,,Now this picture isn't really quite true and that it looked makes it look like
Dialogue: 0,0:34:55.18,0:34:59.08,Chinese,,0,0,0,,这张图片不太真实，而且看起来很像
Dialogue: 0,0:34:59.52,0:35:05.44,English,,0,0,0,,They're all kind of synchronized together and I'm doing a you know kaboom down like this
Dialogue: 0,0:34:59.52,0:35:05.44,Chinese,,0,0,0,,它们像是一起同步进行，就像我做的这样
Dialogue: 0,0:35:05.66,0:35:09.02,English,,0,0,0,,In a strict way but in fact they're not,it's very asynchronous
Dialogue: 0,0:35:05.66,0:35:09.02,Chinese,,0,0,0,,严格地说，它们不是同步而是异步的
Dialogue: 0,0:35:09.66,0:35:12.50,English,,0,0,0,,The left part is one thread the right is another
Dialogue: 0,0:35:09.66,0:35:12.50,Chinese,,0,0,0,,左边是一个线程，右边是另一个
Dialogue: 0,0:35:13.06,0:35:19.30,English,,0,0,0,,They just go at their own pace and at the end I'm just going to wait for it all to complete
Dialogue: 0,0:35:13.06,0:35:19.30,Chinese,,0,0,0,,它们按照自己的节奏前进，而我只是等待一切都结束
Dialogue: 0,0:35:19.74,0:35:23.70,English,,0,0,0,,But there's no strict temporal ordering on how that all occurs
Dialogue: 0,0:35:19.74,0:35:23.70,Chinese,,0,0,0,,但是这一切并没有严格的时间顺序
Dialogue: 0,0:35:28.28,0:35:33.60,English,,0,0,0,,So the way I'll write this in the code is available on the course website
Dialogue: 0,0:35:28.28,0:35:33.60,Chinese,,0,0,0,,因此，我将在课程网站上提供我写的这部分的代码
Dialogue: 0,0:35:33.60,0:35:35.36,English,,0,0,0,,I'm only going to show you a glimpse of it
Dialogue: 0,0:35:33.60,0:35:35.36,Chinese,,0,0,0,,我只会向你展示一下它
Dialogue: 0,0:35:36.02,0:35:38.40,English,,0,0,0,,It's a non-trivial amount of code it takes to do it
Dialogue: 0,0:35:36.02,0:35:38.40,Chinese,,0,0,0,,这是一个不需要大量的代码就能完成的事情
Dialogue: 0,0:35:38.88,0:35:43.36,English,,0,0,0,,But basically what I'm going to do is have a bunch of a pool of threads
Dialogue: 0,0:35:38.88,0:35:43.36,Chinese,,0,0,0,,基本上我要用一堆线程来做这件事情
Dialogue: 0,0:35:43.98,0:35:48.86,English,,0,0,0,,That are ready to work and that's a pretty typical way you write threaded code
Dialogue: 0,0:35:43.98,0:35:48.86,Chinese,,0,0,0,,这已经准备好了，这是一种典型编写线程代码的方式
Dialogue: 0,0:35:49.60,0:35:56.82,English,,0,0,0,,Because actually the initiation of a thread is a non-trivial amount of computation
Dialogue: 0,0:35:49.60,0:35:56.82,Chinese,,0,0,0,,因为实际上一个线程的启动是一个非微不足道的计算量
Dialogue: 0,0:35:56.88,0:35:58.16,English,,0,0,0,,So usually what you do is
Dialogue: 0,0:35:56.88,0:35:58.16,Chinese,,0,0,0,,通常你所做的就是
Dialogue: 0,0:35:58.56,0:36:01.18,English,,0,0,0,,You say I've got this many cores
Dialogue: 0,0:35:58.56,0:36:01.18,Chinese,,0,0,0,,你说我有这么多核心
Dialogue: 0,0:36:01.68,0:36:05.76,English,,0,0,0,,I'm going to create a set of that many threads
Dialogue: 0,0:36:01.68,0:36:05.76,Chinese,,0,0,0,,我要创建一组多线程
Dialogue: 0,0:36:06.58,0:36:10.95,English,,0,0,0,,And they will each work by sharing a task queue
Dialogue: 0,0:36:06.58,0:36:10.95,Chinese,,0,0,0,,他们将通过共享任务队列的方式来工作
Dialogue: 0,0:36:11.52,0:36:19.34,English,,0,0,0,,So some agent that is a forking of work for the different threads to do
Dialogue: 0,0:36:11.52,0:36:19.34,Chinese,,0,0,0,,所以一些代理正在创建不同的线程来工作
Dialogue: 0,0:36:19.70,0:36:25.38,English,,0,0,0,,They will do the work assigned to them when that's complete they'll come back and say ok I'm ready for something new
Dialogue: 0,0:36:19.70,0:36:25.38,Chinese,,0,0,0,,他们将完成分配给他们的工作，当他们完成后会回来说好，我已准备好接受新的事情了
Dialogue: 0,0:36:25.68,0:36:27.02,English,,0,0,0,,And it will give them something new
Dialogue: 0,0:36:25.68,0:36:27.02,Chinese,,0,0,0,,它会给他们一些新的东西
Dialogue: 0,0:36:27.16,0:36:34.54,English,,0,0,0,,So I've there's a little bit of code a very rudimentary code there of creating this task model and task scheduling
Dialogue: 0,0:36:27.16,0:36:34.54,Chinese,,0,0,0,,所以我有一点点代码......一个非常简单的代码......创建这个任务模型和任务调度的代码
Dialogue: 0,0:36:35.52,0:36:38.08,English,,0,0,0,,So the basic rule will be any given task
Dialogue: 0,0:36:35.52,0:36:38.08,Chinese,,0,0,0,,因此，基本规则将是任何给定的任务
Dialogue: 0,0:36:39.02,0:36:46.68,English,,0,0,0,,Any given thread then at any given time has been assigned sub range of this array to be a sorting
Dialogue: 0,0:36:39.02,0:36:46.68,Chinese,,0,0,0,,任何给定的线程，那么在任何给定的时间，这个数组的子范围都被分配给了一个排序任务
Dialogue: 0,0:36:47.28,0:36:55.66,English,,0,0,0,,And it will be specified by the base meaning the starting point of this particular range
Dialogue: 0,0:36:47.28,0:36:55.66,Chinese,,0,0,0,,它将称为基准，意思是按照基准进行分割
Dialogue: 0,0:36:56.26,0:37:01.26,English,,0,0,0,,And then the number of elements that it's a told it's sort
Dialogue: 0,0:36:56.26,0:37:01.26,Chinese,,0,0,0,,然后对这些元素进行排序
Dialogue: 0,0:37:03.74,0:37:05.70,English,,0,0,0,,And one other thing I'll do is
Dialogue: 0,0:37:03.74,0:37:05.70,Chinese,,0,0,0,,我要做的另一件事是
Dialogue: 0,0:37:06.04,0:37:10.32,English,,0,0,0,,Once get down to this array being small enough
Dialogue: 0,0:37:06.04,0:37:10.32,Chinese,,0,0,0,,一旦这个数组足够小
Dialogue: 0,0:37:10.82,0:37:12.90,English,,0,0,0,,I'll just sort it sequentially
Dialogue: 0,0:37:10.82,0:37:12.90,Chinese,,0,0,0,,我就只能顺序排序
Dialogue: 0,0:37:13.60,0:37:20.96,English,,0,0,0,,And and we'll see how big that block is or not is actually performance parameter that you can use for tuning the program
Dialogue: 0,0:37:13.60,0:37:20.96,Chinese,,0,0,0,,并且我们将看到该块的大小，可用于调整程序的性能参数
Dialogue: 0,0:37:21.82,0:37:25.32,English,,0,0,0,,So the point is that you don't want to take this down too far
Dialogue: 0,0:37:21.82,0:37:25.32,Chinese,,0,0,0,,所以重点是你不想把块分的太小
Dialogue: 0,0:37:25.34,0:37:29.60,English,,0,0,0,,Because the sort of overhead of threads is enough that
Dialogue: 0,0:37:25.34,0:37:29.60,Chinese,,0,0,0,,因为线程的开销的问题
Dialogue: 0,0:37:29.98,0:37:33.00,English,,0,0,0,,When you get to fine-grained you're actually going to start losing performance
Dialogue: 0,0:37:29.98,0:37:33.00,Chinese,,0,0,0,,当你得到细粒度时，你实际上会开始失去性能
Dialogue: 0,0:37:35.38,0:37:39.48,English,,0,0,0,,So assume that it's bigger than that I've been given some block there
Dialogue: 0,0:37:35.38,0:37:39.48,Chinese,,0,0,0,,因此，假设这里块比我设定的参数要大
Dialogue: 0,0:37:40.04,0:37:43.78,English,,0,0,0,,What I'll do then is I'll run the partition step
Dialogue: 0,0:37:40.04,0:37:43.78,Chinese,,0,0,0,,那我要做的是进行分区
Dialogue: 0,0:37:44.12,0:37:50.50,English,,0,0,0,,This thread will run it a partition step just using the exact function showed you or didn't show you
Dialogue: 0,0:37:44.12,0:37:50.50,Chinese,,0,0,0,,这个线程将运行分区操作，这里我没有该处代码
Dialogue: 0,0:37:52.74,0:38:00.00,English,,0,0,0,,And then as long as and then I will create and add to the task queue two new tasks
Dialogue: 0,0:37:52.74,0:38:00.00,Chinese,,0,0,0,,然后我再创建两个任务并添加到任务队列当中
Dialogue: 0,0:38:00.84,0:38:05.06,English,,0,0,0,,A one de for the left part and one for the right part
Dialogue: 0,0:38:00.84,0:38:05.06,Chinese,,0,0,0,,左侧部分为一个，右侧部分为一个
Dialogue: 0,0:38:05.78,0:38:13.50,English,,0,0,0,,And then the scheduler that will assign two threads to handle those two parts
Dialogue: 0,0:38:05.78,0:38:13.50,Chinese,,0,0,0,,然后调度程序将分配两个线程来处理这两部分
Dialogue: 0,0:38:13.68,0:38:16.52,English,,0,0,0,,And so that code will that's exactly how the code is going to work
Dialogue: 0,0:38:13.68,0:38:16.52,Chinese,,0,0,0,,因此，代码将是......这就是代码的工作方式
Dialogue: 0,0:38:16.66,0:38:21.78,English,,0,0,0,,It's going to keep reusing the same threads over and over again
Dialogue: 0,0:38:16.66,0:38:21.78,Chinese,,0,0,0,,它会一遍又一遍地重复使用相同的线程
Dialogue: 0,0:38:22.56,0:38:27.02,English,,0,0,0,,To but at any given time they'll be given a range of places
Dialogue: 0,0:38:22.56,0:38:27.02,Chinese,,0,0,0,,但在任何时候，他们都会得到一系列的名额
Dialogue: 0,0:38:27.86,0:38:30.88,English,,0,0,0,,What typically will happen is they'll run their partitioning step
Dialogue: 0,0:38:27.86,0:38:30.88,Chinese,,0,0,0,,通常会发生的是他们将运行分区操作
Dialogue: 0,0:38:32.42,0:38:39.98,English,,0,0,0,,And then say okay I've done my job now assigned to new threads to do this and that's the general scheme of it
Dialogue: 0,0:38:32.42,0:38:39.98,Chinese,,0,0,0,,然后说好，我已经完成了我的工作，现在分配到新线程来做这个，这是它的通常做法
Dialogue: 0,0:38:40.12,0:38:42.40,English,,0,0,0,,Or they'll say this is a small enough block
Dialogue: 0,0:38:40.12,0:38:42.40,Chinese,,0,0,0,,或者他们会说这是一个足够小的块
Dialogue: 0,0:38:43.26,0:38:45.72,English,,0,0,0,,I'm just going to sort the darn thing
Dialogue: 0,0:38:43.26,0:38:45.72,Chinese,,0,0,0,,我只想解决这个问题
Dialogue: 0,0:38:45.76,0:38:48.16,English,,0,0,0,,Okay so that's really all the code does it's online
Dialogue: 0,0:38:45.76,0:38:48.16,Chinese,,0,0,0,,这就是所有的代码，都在课程网站上
Dialogue: 0,0:38:48.68,0:38:54.94,English,,0,0,0,,If you're interested in this kind of stuff it's... I think it's pretty well written code because I wrote it
Dialogue: 0,0:38:48.68,0:38:54.94,Chinese,,0,0,0,,如果你对它感兴趣的话 ...... 我认为这是写得很好的代码
Dialogue: 0,0:38:57.62,0:39:00.52,English,,0,0,0,,It so this is sort of that the
Dialogue: 0,0:38:57.62,0:39:00.52,Chinese,,0,0,0,,它就是这样的
Dialogue: 0,0:39:01.50,0:39:04.66,English,,0,0,0,,Somewhat simplified version of the code say
Dialogue: 0,0:39:01.50,0:39:04.66,Chinese,,0,0,0,,这是一个稍微简化的版本
Dialogue: 0,0:39:05.20,0:39:09.42,English,,0,0,0,,Initialize my task queue scheduling system
Dialogue: 0,0:39:05.20,0:39:09.42,Chinese,,0,0,0,,初始化我的任务队列调度系统
Dialogue: 0,0:39:10.88,0:39:20.30,English,,0,0,0,,Create global variables of describing the beginning and end of this array to be sorted create a new task queue
Dialogue: 0,0:39:10.88,0:39:20.30,Chinese,,0,0,0,,新建全局变量保存要排序的数组的开头和结尾，创建一个新的任务队列
Dialogue: 0,0:39:20.82,0:39:24.14,English,,0,0,0,,And then this is the main function the tqsort_helper
Dialogue: 0,0:39:20.82,0:39:24.14,Chinese,,0,0,0,,然后是主函数 tqsort_helper
Dialogue: 0,0:39:25.00,0:39:31.68,English,,0,0,0,,Is given some range of addresses and a pointer to the task queue
Dialogue: 0,0:39:25.00,0:39:31.68,Chinese,,0,0,0,,它接受一个地址范围和一个队列指针作为参数
Dialogue: 0,0:39:31.86,0:39:34.72,English,,0,0,0,,That's used to manage these tasks
Dialogue: 0,0:39:31.86,0:39:34.72,Chinese,,0,0,0,,那用于管理这些任务
Dialogue: 0,0:39:35.64,0:39:36.82,English,,0,0,0,,And then uh
Dialogue: 0,0:39:35.64,0:39:36.82,Chinese,,0,0,0,,然后
Dialogue: 0,0:39:40.38,0:39:43.84,English,,0,0,0,,When it's all done. We'll just wait till all the tasks have completed
Dialogue: 0,0:39:40.38,0:39:43.84,Chinese,,0,0,0,,当它完成时......我们要等待所有的任务完成
Dialogue: 0,0:39:43.84,0:39:49.70,English,,0,0,0,, This is at the top level, this isn't part of any recursion this is the top level code
Dialogue: 0,0:39:43.84,0:39:49.70,Chinese,,0,0,0,,这不是任何递归的一部分，这是上层代码
Dialogue: 0,0:39:50.08,0:39:51.84,English,,0,0,0,,And then it will free up the data structures
Dialogue: 0,0:39:50.08,0:39:51.84,Chinese,,0,0,0,,然后它将释放数据结构
Dialogue: 0,0:39:54.24,0:39:58.06,English,,0,0,0,,And then this is the part of it that actually does the real work
Dialogue: 0,0:39:54.24,0:39:58.06,Chinese,,0,0,0,,这是实际完成工作的部分代码
Dialogue: 0,0:39:59.00,0:40:04.82,English,,0,0,0,,It will say so now the tqsort_helper is the part
Dialogue: 0,0:39:59.00,0:40:04.82,Chinese,,0,0,0,,现在可以说 tqsort_helper 是
Dialogue: 0,0:40:04.94,0:40:17.16,English,,0,0,0,,That's a scientists to sort some particulars poises from the starting address the base and some number of elements
Dialogue: 0,0:40:04.94,0:40:17.16,Chinese,,0,0,0,,这是一个科学方法从数组的起始地址和一些元素中整理出的一些特殊的元素
Dialogue: 0,0:40:19.06,0:40:22.12,English,,0,0,0,,And so this is what each task will do
Dialogue: 0,0:40:19.06,0:40:22.12,Chinese,,0,0,0,,所以这就是每项任务都需要
Dialogue: 0,0:40:22.46,0:40:26.68,English,,0,0,0,,And it says okay if this is a small enough block of elements
Dialogue: 0,0:40:22.46,0:40:26.68,Chinese,,0,0,0,,如果这是一个足够小的元素块
Dialogue: 0,0:40:27.16,0:40:30.42,English,,0,0,0,,I'm just going to call my serial quicksort to do it
Dialogue: 0,0:40:27.16,0:40:30.42,Chinese,,0,0,0,,我就调用排序函数（qsort_serial）来处理
Dialogue: 0,0:40:31.66,0:40:34.90,English,,0,0,0,,Otherwise I'm going to
Dialogue: 0,0:40:31.66,0:40:34.90,Chinese,,0,0,0,,否则
Dialogue: 0,0:40:45.44,0:40:47.24,English,,0,0,0,,Oh it's a little bit messier this okay
Dialogue: 0,0:40:45.44,0:40:47.24,Chinese,,0,0,0,,这下可就麻烦了
Dialogue: 0,0:40:47.86,0:40:53.56,English,,0,0,0,,Now otherwise it's going to spawn a task to do the sorting
Dialogue: 0,0:40:47.86,0:40:53.56,Chinese,,0,0,0,,否则会创建一个任务来进行排序
Dialogue: 0,0:40:54.04,0:40:54.80,English,,0,0,0,,Let's see
Dialogue: 0,0:40:54.04,0:40:54.80,Chinese,,0,0,0,,让我们来康康
Dialogue: 0,0:40:55.32,0:40:57.90,English,,0,0,0,,I was a little mixed up,this is a high level
Dialogue: 0,0:40:55.32,0:40:57.90,Chinese,,0,0,0,,我有点混了，这个水平很高
Dialogue: 0,0:40:57.90,0:41:04.22,English,,0,0,0,,So the actual splitting occurs in this thing which is where it
Dialogue: 0,0:40:57.90,0:41:04.22,Chinese,,0,0,0,,所以实际的分割在这里发生
Dialogue: 0,0:41:06.42,0:41:08.28,English,,0,0,0,,So this is the actual thread routine
Dialogue: 0,0:41:06.42,0:41:08.28,Chinese,,0,0,0,,所以这是实际的线程例程
Dialogue: 0,0:41:09.68,0:41:14.20,English,,0,0,0,,And what it's saying is run the partition here
Dialogue: 0,0:41:09.68,0:41:14.20,Chinese,,0,0,0,,这里运行 partition
Dialogue: 0,0:41:15.36,0:41:20.98,English,,0,0,0,,And then call this tqsort_helper which you just saw on the left and the right parts
Dialogue: 0,0:41:15.36,0:41:20.98,Chinese,,0,0,0,,然后在左右两边调用 tqsort_helper
Dialogue: 0,0:41:25.00,0:41:31.36,English,,0,0,0,,So just to review then the actual spawning of a task is done by this helper routine
Dialogue: 0,0:41:25.00,0:41:31.36,Chinese,,0,0,0,,回顾一下，任务的实际产生是由这个辅助程序完成的
Dialogue: 0,0:41:32.10,0:41:37.02,English,,0,0,0,,But then that what it calls is the thread routine is
Dialogue: 0,0:41:32.10,0:41:37.02,Chinese,,0,0,0,,那就是所谓的线程例程
Dialogue: 0,0:41:38.18,0:41:40.70,English,,0,0,0,,What does the work here and what it will do is
Dialogue: 0,0:41:38.18,0:41:40.70,Chinese,,0,0,0,,在这里发生作用，它将做什么？
Dialogue: 0,0:41:41.00,0:41:43.16,English,,0,0,0,,It will do the partitioning within that thread
Dialogue: 0,0:41:41.00,0:41:43.16,Chinese,,0,0,0,,它将在该线程内进行分区
Dialogue: 0,0:41:43.60,0:41:52.06,English,,0,0,0,,And then it will just throw back and add to the task queue two calls to this helper
Dialogue: 0,0:41:43.60,0:41:52.06,Chinese,,0,0,0,,然后它向任务队列添加两个任务，并调用这函数
Dialogue: 0,0:41:53.82,0:42:00.16,English,,0,0,0,,But as that kind of...So between these two routines you can see it's doing this idea of a divide and conquer parallelism
Dialogue: 0,0:41:53.82,0:42:00.16,Chinese,,0,0,0,,所以在这两个例程之间，你可以看到它在做这种分而治之的想法
Dialogue: 0,0:42:02.00,0:42:06.12,English,,0,0,0,,So this is a performance running on the shark machines
Dialogue: 0,0:42:02.00,0:42:06.12,Chinese,,0,0,0,,这是在鲨鱼机器上运行的表现
Dialogue: 0,0:42:07.42,0:42:18.24,English,,0,0,0,,And this is a fairly straightforward,I'm just taking some number of random value 2^37
Dialogue: 0,0:42:07.42,0:42:18.24,Chinese,,0,0,0,,而这是一个相当直接的方法，我取了 2^37 个随机数
Dialogue: 0,0:42:22.52,0:42:23.42,English,,0,0,0,,That can't be right
Dialogue: 0,0:42:22.52,0:42:23.42,Chinese,,0,0,0,,好像哪里不对
Dialogue: 0,0:42:25.56,0:42:29.56,English,,0,0,0,,Finish this is numbers not 2^37 right you agree with me
Dialogue: 0,0:42:25.56,0:42:29.56,Chinese,,0,0,0,,这是数字（134,217,728）肯定不等于 2^37。你们同意吗？
Dialogue: 0,0:42:31.04,0:42:34.28,English,,0,0,0,,2^37 is 128 billion roughly
Dialogue: 0,0:42:31.04,0:42:34.28,Chinese,,0,0,0,, 2^37 大约是 1280 亿
Dialogue: 0,0:42:34.52,0:42:37.46,English,,0,0,0,,So this number is not right I'll have to check it out
Dialogue: 0,0:42:34.52,0:42:37.46,Chinese,,0,0,0,,这个数字不对，我得去查一下
Dialogue: 0,0:42:39.40,0:42:43.94,English,,0,0,0,,And now what this x axis
Dialogue: 0,0:42:39.40,0:42:43.94,Chinese,,0,0,0,,这个 x 轴表示什么
Dialogue: 0,0:42:44.00,0:42:47.20,English,,0,0,0,,So the y axis just denotes how long does it take to complete
Dialogue: 0,0:42:44.00,0:42:47.20,Chinese,,0,0,0,,y 轴表示完成所需的时间
Dialogue: 0,0:42:47.82,0:42:52.26,English,,0,0,0,,By the way one thing if you're used to measuring performance based on CPU time
Dialogue: 0,0:42:47.82,0:42:52.26,Chinese,,0,0,0,,顺便提一下，如果你习惯根据 CPU 时间测量性能
Dialogue: 0,0:42:52.92,0:42:57.92,English,,0,0,0,,That's not useful when you're talking a parallel computing you really want to talk a elapsed time
Dialogue: 0,0:42:52.92,0:42:57.92,Chinese,,0,0,0,,而当你真的要谈一个并行计算的时间的时候，那是没有用的，你真正关心的是真实经过的时间
Dialogue: 0,0:42:58.44,0:43:04.52,English,,0,0,0,,The time that you'd get from looking at a clock  and measuring it and dealing with whatever inefficiency occurs
Dialogue: 0,0:42:58.44,0:43:04.52,Chinese,,0,0,0,,你需要通过时钟来观测，特别是在处理低效任务的时候
Dialogue: 0,0:43:04.98,0:43:08.66,English,,0,0,0,,These are actually the elapsed run time of the entire program
Dialogue: 0,0:43:04.98,0:43:08.66,Chinese,,0,0,0,,这实际上是整个程序的运行时间
Dialogue: 0,0:43:11.04,0:43:15.20,English,,0,0,0,,And you'll see that it varies according to this thing called the serial fraction
Dialogue: 0,0:43:11.04,0:43:15.20,Chinese,,0,0,0,,你会发现，它的变化是根据「serial fraction」而变化的
Dialogue: 0,0:43:15.54,0:43:24.64,English,,0,0,0,,The serial fraction is just at what point do I slide between a serial quicksort or keep dividing
Dialogue: 0,0:43:15.54,0:43:24.64,Chinese,,0,0,0,,「serial fraction」是快排和分割之间的滑动点
Dialogue: 0,0:43:24.80,0:43:26.80,English,,0,0,0,,So how big does the array need to be
Dialogue: 0,0:43:24.80,0:43:26.80,Chinese,,0,0,0,,那么我们需要多大的数组？
Dialogue: 0,0:43:27.20,0:43:30.22,English,,0,0,0,,As a fraction expressed as a fraction of the original array
Dialogue: 0,0:43:27.20,0:43:30.22,Chinese,,0,0,0,,作为表示原始数组大小的分数
Dialogue: 0,0:43:31.52,0:43:36.04,English,,0,0,0,,Before I will go into recursion
Dialogue: 0,0:43:31.52,0:43:36.04,Chinese,,0,0,0,,在我进入递归之前
Dialogue: 0,0:43:36.14,0:43:40.06,English,,0,0,0,,If I were actually to write this a real application I wouldn't do it based on a fraction
Dialogue: 0,0:43:36.14,0:43:40.06,Chinese,,0,0,0,,如果我真的要把这个写成应用程序，我不会根据一小部分来做的
Dialogue: 0,0:43:40.14,0:43:47.00,English,,0,0,0,,I'd do it based on a block size to say anything smaller than a thousand elements or some number like that
Dialogue: 0,0:43:40.14,0:43:47.00,Chinese,,0,0,0,,我会根据块的大小来做，可以说任何小于 1000 个元素或类似的数字
Dialogue: 0,0:43:47.18,0:43:51.08,English,,0,0,0,,But this code just happens to be expressed this way
Dialogue: 0,0:43:47.18,0:43:51.08,Chinese,,0,0,0,,但是这个代码恰好以这种方式表示
Dialogue: 0,0:43:51.32,0:43:54.64,English,,0,0,0,,But the thing to notice that's interesting is you'll see here
Dialogue: 0,0:43:51.32,0:43:54.64,Chinese,,0,0,0,,但要注意，这里有个有趣的事情
Dialogue: 0,0:43:57.08,0:44:01.14,English,,0,0,0,,If the fraction is 1 it basically says I won't split this at all
Dialogue: 0,0:43:57.08,0:44:01.14,Chinese,,0,0,0,,如果分数是 1 ，它根本不会拆分
Dialogue: 0,0:44:01.14,0:44:04.10,English,,0,0,0,,I'm just going to call a sequential quicksort
Dialogue: 0,0:44:01.14,0:44:04.10,Chinese,,0,0,0,,我仅仅是进行了顺序执行的快排
Dialogue: 0,0:44:04.24,0:44:07.00,English,,0,0,0,,So this is a purely sequential version of it
Dialogue: 0,0:44:04.24,0:44:07.00,Chinese,,0,0,0,,所以这是纯粹顺序执行的版本
Dialogue: 0,0:44:07.56,0:44:10.80,English,,0,0,0,,And what it shows is if I once I start 2
Dialogue: 0,0:44:07.56,0:44:10.80,Chinese,,0,0,0,,一旦我们从 2 开始就能看到
Dialogue: 0,0:44:11.48,0:44:15.43,English,,0,0,0,,I'll be willing to sort of split this up and do parallelism
Dialogue: 0,0:44:11.48,0:44:15.43,Chinese,,0,0,0,,我把这个拆开来做并行计算
Dialogue: 0,0:44:15.92,0:44:18.92,English,,0,0,0,,I start making run faster and faster and faster
Dialogue: 0,0:44:15.92,0:44:18.92,Chinese,,0,0,0,,我运行的越来越快了
Dialogue: 0,0:44:20.14,0:44:22.24,English,,0,0,0,,And then I get into this trough
Dialogue: 0,0:44:20.14,0:44:22.24,Chinese,,0,0,0,,然后我进入这个低谷
Dialogue: 0,0:44:22.94,0:44:27.76,English,,0,0,0,,And now if I start going finer and finer grain then I'm running into the problem
Dialogue: 0,0:44:22.94,0:44:27.76,Chinese,,0,0,0,,现在，如果我拆分的越来越细，我就会遇到这个问题了
Dialogue: 0,0:44:27.76,0:44:34.12,English,,0,0,0,,Where the thread overhead is more than the advantage I'm getting by doing the parallelism
Dialogue: 0,0:44:27.76,0:44:34.12,Chinese,,0,0,0,,线程开销掩盖了我通过并行计算获得的优势
Dialogue: 0,0:44:34.26,0:44:41.54,English,,0,0,0,,And I'm faster to run that block bigger sort just use a sequential algorithm rather than parallel
Dialogue: 0,0:44:34.26,0:44:41.54,Chinese,,0,0,0,,而我更快的是，运行那个大块的排序，只是使用顺序算法，而不是并行算法
Dialogue: 0,0:44:43.96,0:44:47.40,English,,0,0,0,,But the good news here is this is a pretty long trough here
Dialogue: 0,0:44:43.96,0:44:47.40,Chinese,,0,0,0,,但这里的好消息是，这是一个相当长的低谷
Dialogue: 0,0:44:47.64,0:44:50.72,English,,0,0,0,,So it means is if you're trying to tune this program
Dialogue: 0,0:44:47.64,0:44:50.72,Chinese,,0,0,0,,这意味着，如果你正打算调整这个程序的话
Dialogue: 0,0:44:51.74,0:44:57.40,English,,0,0,0,,It's not that hard you're not going to pay a huge penalty if you don't know a parameter exactly
Dialogue: 0,0:44:51.74,0:44:57.40,Chinese,,0,0,0,,如果你不完全知道参数，那么你就不知道要付出多大代价
Dialogue: 0,0:44:58.04,0:45:04.26,English,,0,0,0,,So as long as this is a huge range right 30 from a 32 to 4096
Dialogue: 0,0:44:58.04,0:45:04.26,Chinese,,0,0,0,,这个范围巨大从 32 到 4096
Dialogue: 0,0:45:04.28,0:45:15.34,English,,0,0,0,,It's a factor of a lot...2^15 and 2^12,2^7 fact 128
Dialogue: 0,0:45:04.28,0:45:15.34,Chinese,,0,0,0,,这是一个很大的变量 ... 2^15 和 2^12 , 2^7 就是 128
Dialogue: 0,0:45:16.12,0:45:19.04,English,,0,0,0,,See how I do my arithmetic and powers at 2
Dialogue: 0,0:45:16.12,0:45:19.04,Chinese,,0,0,0,,看看我如何做 2 的幂运算
Dialogue: 0,0:45:19.42,0:45:23.66,English,,0,0,0,,Anyways it's roughly at you know 128 so
Dialogue: 0,0:45:19.42,0:45:23.66,Chinese,,0,0,0,,不管怎么说，大概是想你知道的 128，所以......
Dialogue: 0,0:45:23.82,0:45:29.38,English,,0,0,0,, Several orders of magnitude,decimal orders of magnitude over which you get pretty comparable performance
Dialogue: 0,0:45:23.82,0:45:29.38,Chinese,,0,0,0,, 几个数量级，小数个数量级，在此基础上，你可以获得相当的性能
Dialogue: 0,0:45:29.54,0:45:33.88,English,,0,0,0,,So that means from a performance tuning point of view it's not that hard to do
Dialogue: 0,0:45:29.54,0:45:33.88,Chinese,,0,0,0,,所以，这意味着从性能调优的角度来看，这并不难
Dialogue: 0,0:45:34.62,0:45:41.74,English,,0,0,0,,And you also see we're getting a pretty decent speed up on our eight core to a hyper-threaded machine
Dialogue: 0,0:45:34.62,0:45:41.74,Chinese,,0,0,0,,而且你也看到我们的速度在我们的八核到超线程机器上表现的相当不错
Dialogue: 0,0:45:41.80,0:45:44.80,English,,0,0,0,,We're getting up basically out 7x performance
Dialogue: 0,0:45:41.80,0:45:44.80,Chinese,,0,0,0,,基本上我们的性能可以提升 7 倍
Dialogue: 0,0:45:45.62,0:45:50.60,English,,0,0,0,,And hyper-threading really isn't helping us at all is part of the lesson here
Dialogue: 0,0:45:45.62,0:45:50.60,Chinese,,0,0,0,,在这里超线程真的对我们一点帮助都没有
Dialogue: 0,0:45:51.24,0:45:53.86,English,,0,0,0,,But if you just think of it as eight cores then that's pretty good
Dialogue: 0,0:45:51.24,0:45:53.86,Chinese,,0,0,0,,但如果你只考虑八个核心，那就非常好了
Dialogue: 0,0:45:59.28,0:46:05.78,English,,0,0,0,,So there is an obvious place here where there's Amdahl law issue going on
Dialogue: 0,0:45:59.28,0:46:05.78,Chinese,,0,0,0,,很明显，这就是「阿姆达尔定律」所要表达的
Dialogue: 0,0:46:05.80,0:46:08.26,English,,0,0,0,,If you think at that first top-level split
Dialogue: 0,0:46:05.80,0:46:08.26,Chinese,,0,0,0,,考虑第一个顶级分裂
Dialogue: 0,0:46:09.32,0:46:16.50,English,,0,0,0,,The first call to partition is being done over the entire ray by a sequential process,right
Dialogue: 0,0:46:09.32,0:46:16.50,Chinese,,0,0,0,,第一次调用 partition 是通过顺序执行的程序完成的
Dialogue: 0,0:46:16.82,0:46:24.38,English,,0,0,0,,So at the very least that is not going parallel at all,there's going exactly one thread is doing the initial partition
Dialogue: 0,0:46:16.82,0:46:24.38,Chinese,,0,0,0,,因此，这里根本没有并行，只有一个线程正在进行初始分区
Dialogue: 0,0:46:25.72,0:46:30.64,English,,0,0,0,,And then that splits into two so at most you have two threads worth of parallelism
Dialogue: 0,0:46:25.72,0:46:30.64,Chinese,,0,0,0,,然后分成两个，所以最多你有两个并行的线程
Dialogue: 0,0:46:31.24,0:46:33.38,English,,0,0,0,,And then the next level down at most four
Dialogue: 0,0:46:31.24,0:46:33.38,Chinese,,0,0,0,,然后再往下有 4 个线程
Dialogue: 0,0:46:33.42,0:46:34.72,English,,0,0,0,,And so you really don't...
Dialogue: 0,0:46:33.42,0:46:34.72,Chinese,,0,0,0,,所以你不必......
Dialogue: 0,0:46:34.72,0:46:41.42,English,,0,0,0,,You have to get several levels of recursion down before you're really running on all the cores that you have available
Dialogue: 0,0:46:34.72,0:46:41.42,Chinese,,0,0,0,,你必须进行几次递归之后才能在所有可用的内核上运行
Dialogue: 0,0:46:41.70,0:46:46.04,English,,0,0,0,,So you'd think that that's limiting your speedup，it does
Dialogue: 0,0:46:41.70,0:46:46.04,Chinese,,0,0,0,,所以你想想这限制了你的加速比？是的
Dialogue: 0,0:46:46.04,0:46:53.32,English,,0,0,0,,That's part of the reason why our best performance is a factor of seven and not a factor of eight or more
Dialogue: 0,0:46:46.04,0:46:53.32,Chinese,,0,0,0,,这也是我们最好的成绩是 7 分，而不是 8 分以上的部分原因
Dialogue: 0,0:46:59.10,0:47:09.30,English,,0,0,0,,So there's quite a bit of work as mentioned on how to speed up performance,including how to make quicksort go faster
Dialogue: 0,0:46:59.10,0:47:09.30,Chinese,,0,0,0,,因此，在如何提高性能方面有很多工作要做，包括如何让「快排」速度更快
Dialogue: 0,0:47:12.00,0:47:15.62,English,,0,0,0,,So there's a vast body of literature on parallel sort
Dialogue: 0,0:47:12.00,0:47:15.62,Chinese,,0,0,0,,因此，有大量关于并行排序的文献
Dialogue: 0,0:47:19.92,0:47:21.38,English,,0,0,0,,So one thing I tried
Dialogue: 0,0:47:19.92,0:47:21.38,Chinese,,0,0,0,,我还试过
Dialogue: 0,0:47:21.72,0:47:27.04,English,,0,0,0,,was to say okay well let's try and do this partitioning step
Dialogue: 0,0:47:21.72,0:47:27.04,Chinese,,0,0,0,,就是将分区并行化
Dialogue: 0,0:47:27.94,0:47:32.70,English,,0,0,0,,They least the top couple levels let's try and do a parallel version of that and
Dialogue: 0,0:47:27.94,0:47:32.70,Chinese,,0,0,0,,至少是最层的几步，我试过并行处理
Dialogue: 0,0:47:33.34,0:47:36.16,English,,0,0,0,,So the idea is you pick one pivot element
Dialogue: 0,0:47:33.34,0:47:36.16,Chinese,,0,0,0,,现在你要选择一个基准元素
Dialogue: 0,0:47:36.38,0:47:39.24,English,,0,0,0,,But now you fire in this example for threads
Dialogue: 0,0:47:36.38,0:47:39.24,Chinese,,0,0,0,,但这里你要用多个线程
Dialogue: 0,0:47:40.42,0:47:47.18,English,,0,0,0,,And each of those four threads runs a partition step on one-fourth of the range
Dialogue: 0,0:47:40.42,0:47:47.18,Chinese,,0,0,0,,这四个线程中的每一个都在各自的四分之一上执行分区步骤
Dialogue: 0,0:47:48.26,0:47:51.12,English,,0,0,0,,And it don't generate their own versions of left and right
Dialogue: 0,0:47:48.26,0:47:51.12,Chinese,,0,0,0,,并且它不会生成自己的左右部分
Dialogue: 0,0:47:52.26,0:47:59.12,English,,0,0,0,,And then you globally figure out how many are in each of these sub ranges
Dialogue: 0,0:47:52.26,0:47:59.12,Chinese,,0,0,0,,然后你全局计算有多少的子分区
Dialogue: 0,0:48:00.46,0:48:07.00,English,,0,0,0,,And then you tell each thread okay now you copy your part of it over to the relevant section of the array
Dialogue: 0,0:48:00.46,0:48:07.00,Chinese,,0,0,0,,然后你告诉每个线程，复制对应的部分到数组的相关位置
Dialogue: 0,0:48:09.60,0:48:13.78,English,,0,0,0,,But the good news so there's some amount of synchronization that goes on there
Dialogue: 0,0:48:09.60,0:48:13.78,Chinese,,0,0,0,,但好消息是，那里是同步操作
Dialogue: 0,0:48:14.48,0:48:18.14,English,,0,0,0,,But you can imagine that this partitioning step
Dialogue: 0,0:48:14.48,0:48:18.14,Chinese,,0,0,0,,但你可以想象这个分区步骤
Dialogue: 0,0:48:18.44,0:48:23.78,English,,0,0,0,,Once when you're running it is completely independent of across the different threads
Dialogue: 0,0:48:18.44,0:48:23.78,Chinese,,0,0,0,,一旦你运行它就完全由不同的独立线程来处理
Dialogue: 0,0:48:23.82,0:48:26.52,English,,0,0,0,,So it's getting a almost ideal speed-up
Dialogue: 0,0:48:23.82,0:48:26.52,Chinese,,0,0,0,,所以能获得了几乎理想的加速比
Dialogue: 0,0:48:27.62,0:48:32.90,English,,0,0,0,,So I implemented this and tried and I couldn't make it run faster than the original code
Dialogue: 0,0:48:27.62,0:48:32.90,Chinese,,0,0,0,,所以我实现了这个并尝试了，我无法让它比原始代码运行得更快
Dialogue: 0,0:48:33.72,0:48:39.68,English,,0,0,0,,And I think the the problem with this was the copying the cost of copying data
Dialogue: 0,0:48:33.72,0:48:39.68,Chinese,,0,0,0,,我认为问题是出在复制数据的开销上
Dialogue: 0,0:48:41.96,0:48:47.80,English,,0,0,0,,Here was even though it's being done by multiple threads
Dialogue: 0,0:48:41.96,0:48:47.80,Chinese,,0,0,0,,这里是由多个线程完成的
Dialogue: 0,0:48:48.30,0:48:51.24,English,,0,0,0,,And getting pretty good performance out of the memory system
Dialogue: 0,0:48:48.30,0:48:51.24,Chinese,,0,0,0,,并从内存系统中获得相当不错的性能
Dialogue: 0,0:48:51.26,0:48:56.12,English,,0,0,0,,Because you're doing sequential you know all the cache issues are pretty good here
Dialogue: 0,0:48:51.26,0:48:56.12,Chinese,,0,0,0,,因为你在做顺序复制，而这里的缓存都是相当不错的
Dialogue: 0,0:48:56.80,0:48:58.94,English,,0,0,0,,But that's just enough extra work
Dialogue: 0,0:48:56.80,0:48:58.94,Chinese,,0,0,0,,但这只是额外的工作
Dialogue: 0,0:48:59.52,0:49:04.88,English,,0,0,0,,That has to be done for this parallel code that doesn't have to be done the sequential code is totally in place
Dialogue: 0,0:48:59.52,0:49:04.88,Chinese,,0,0,0,,那必须要这样做，不需要做的并行代码，顺序代码完全到位了
Dialogue: 0,0:49:05.82,0:49:08.96,English,,0,0,0,,Meaning not using any additional storage not copying
Dialogue: 0,0:49:05.82,0:49:08.96,Chinese,,0,0,0,,意思是不使用任何其他存储空间，不用复制
Dialogue: 0,0:49:09.34,0:49:13.12,English,,0,0,0,,And so that's just enough of a penalty on the parallel part
Dialogue: 0,0:49:09.34,0:49:13.12,Chinese,,0,0,0,,这部分已经足够了
Dialogue: 0,0:49:13.56,0:49:16.04,English,,0,0,0,,That it didn't really improve performance at all
Dialogue: 0,0:49:13.56,0:49:16.04,Chinese,,0,0,0,,它根本没有真正提高性能
Dialogue: 0,0:49:16.56,0:49:20.54,English,,0,0,0,,So that code is shown as part of the code on the course website
Dialogue: 0,0:49:16.56,0:49:20.54,Chinese,,0,0,0,,这部分代码在课程网站上可以找到
Dialogue: 0,0:49:20.68,0:49:27.90,English,,0,0,0,,But like I said I banged on it quite a bit and trying to tune it And squeak it in various ways and could never make it
Dialogue: 0,0:49:20.68,0:49:27.90,Chinese,,0,0,0,,但就像我说的，我经常打磨它，并试图用各种方法来调整它，但始终无法让它变得更完美
Dialogue: 0,0:49:28.46,0:49:31.54,English,,0,0,0,,So I got better overall performance out of this program
Dialogue: 0,0:49:28.46,0:49:31.54,Chinese,,0,0,0,,所以我从这个项目中获得了更好的整体表现
Dialogue: 0,0:49:33.34,0:49:38.70,English,,0,0,0,,And so that's again a lesson and that's one of the unfortunate lessons is you can spend a lot of time
Dialogue: 0,0:49:33.34,0:49:38.70,Chinese,,0,0,0,,所以这又是一个教训，这是一个不幸的教训，你可以花很多时间
Dialogue: 0,0:49:40.16,0:49:43.64,English,,0,0,0,,Trying to make a program run faster and get absolutely nowhere
Dialogue: 0,0:49:40.16,0:49:43.64,Chinese,,0,0,0,,试图让程序运行得更快，绝对无处可去
Dialogue: 0,0:49:44.72,0:49:47.34,English,,0,0,0,,And it's frustrating because you put in a lot of work
Dialogue: 0,0:49:44.72,0:49:47.34,Chinese,,0,0,0,,这令人沮丧，你投入了大量的工作
Dialogue: 0,0:49:47.90,0:49:52.72,English,,0,0,0,,And you know it's a pretty cool idea and you'd love to publish a paper about it or tell your friends about it
Dialogue: 0,0:49:47.90,0:49:52.72,Chinese,,0,0,0,,而且你知道这是一个非常酷的想法，你打算发表一篇关于它的论文或者告诉你的朋友
Dialogue: 0,0:49:53.02,0:49:55.64,English,,0,0,0,,And it just goes nowhere and it just sits there
Dialogue: 0,0:49:53.02,0:49:55.64,Chinese,,0,0,0,,它只是无处可去，只是坐在那里
Dialogue: 0,0:49:55.98,0:50:02.20,English,,0,0,0,,There's nothing...unfortunately there's not...an accumulated repository of the bad ideas of computer science
Dialogue: 0,0:49:55.98,0:50:02.20,Chinese,,0,0,0,,这也没什么，积少成多的计算机科学思想宝库
Dialogue: 0,0:50:02.30,0:50:03.70,English,,0,0,0,,Don't waste your time trying this
Dialogue: 0,0:50:02.30,0:50:03.70,Chinese,,0,0,0,,不要浪费你的时间尝试这个
Dialogue: 0,0:50:04.30,0:50:06.30,English,,0,0,0,,That people can talk about so
Dialogue: 0,0:50:04.30,0:50:06.30,Chinese,,0,0,0,,但我们可以谈论这个事情
Dialogue: 0,0:50:06.88,0:50:09.18,English,,0,0,0,,This is just a lesson to learn
Dialogue: 0,0:50:06.88,0:50:09.18,Chinese,,0,0,0,,这是你必须吸取的教训
Dialogue: 0,0:50:11.90,0:50:15.34,English,,0,0,0,,So anyways that was my experience with that
Dialogue: 0,0:50:11.90,0:50:15.34,Chinese,,0,0,0,,就我的经验
Dialogue: 0,0:50:15.64,0:50:21.78,English,,0,0,0,,Again other people have spent a lot more time this is one of the most common applications
Dialogue: 0,0:50:15.64,0:50:21.78,Chinese,,0,0,0,,其他人花了很多时间，其中并行计算就是
Dialogue: 0,0:50:22.10,0:50:24.52,English,,0,0,0,,That people try to do parallel programming for
Dialogue: 0,0:50:22.10,0:50:24.52,Chinese,,0,0,0,,最常见的应用程序之一
Dialogue: 0,0:50:26.68,0:50:30.78,English,,0,0,0,,So some of the lessons from this is you need a good strategy
Dialogue: 0,0:50:26.68,0:50:30.78,Chinese,,0,0,0,,因此，一些教训是你需要一个好的策略
Dialogue: 0,0:50:30.80,0:50:33.42,English,,0,0,0,,For how you're going to get parallelism out of your application
Dialogue: 0,0:50:30.80,0:50:33.42,Chinese,,0,0,0,,了解如何从应用程序中获得并行性
Dialogue: 0,0:50:34.10,0:50:38.94,English,,0,0,0,,And I showed you two basic versions one is partitioned into k parts
Dialogue: 0,0:50:34.10,0:50:38.94,Chinese,,0,0,0,,我向你展示了两个基本版本，一个被划分为 k 个部分
Dialogue: 0,0:50:39.00,0:50:42.26,English,,0,0,0,,They're more or less completely independent of each other
Dialogue: 0,0:50:39.00,0:50:42.26,Chinese,,0,0,0,,它们或多或少完全相互独立
Dialogue: 0,0:50:42.78,0:50:46.78,English,,0,0,0,,Or something like a divide and conquer strategy where you can keep splitting it
Dialogue: 0,0:50:42.78,0:50:46.78,Chinese,,0,0,0,,或者类似于分治的策略，你可以继续分裂它
Dialogue: 0,0:50:46.90,0:50:50.92,English,,0,0,0,,But the two splits that you create out of that can go concurrently
Dialogue: 0,0:50:46.90,0:50:50.92,Chinese,,0,0,0,,但是你创建的两个分裂可以同时进行
Dialogue: 0,0:50:51.78,0:50:54.98,English,,0,0,0,,These other different types of parallelism to
Dialogue: 0,0:50:51.78,0:50:54.98,Chinese,,0,0,0,,这些其他不同类型的并行性
Dialogue: 0,0:50:55.60,0:50:57.74,English,,0,0,0,,In general you want to make the inner loops
Dialogue: 0,0:50:55.60,0:50:57.74,Chinese,,0,0,0,,通常，你在进行内部循环时
Dialogue: 0,0:50:57.74,0:51:02.56,English,,0,0,0,,You can't have any synchronization primitives in there it will just run too slow
Dialogue: 0,0:50:57.74,0:51:02.56,Chinese,,0,0,0,,你不能在里面写任何同步原语，因为这样会导致运行得很慢
Dialogue: 0,0:51:03.28,0:51:07.90,English,,0,0,0,,Amdahl as I mentioned is always sort of lurking in the background of
Dialogue: 0,0:51:03.28,0:51:07.90,Chinese,,0,0,0,,我提到的「阿姆达尔定律」总是起到潜在的作用
Dialogue: 0,0:51:08.00,0:51:13.36,English,,0,0,0,,If you can always speedup a part of your program then the other part will become the bottleneck
Dialogue: 0,0:51:08.00,0:51:13.36,Chinese,,0,0,0,,你经常会在提升程序某部分的速度时，那么另一些部分就将成为瓶颈
Dialogue: 0,0:51:14.26,0:51:17.81,English,,0,0,0,,But the other thing is like I said you can do it
Dialogue: 0,0:51:14.26,0:51:17.81,Chinese,,0,0,0,,但是还有写事情你们可以尝试
Dialogue: 0,0:51:17.81,0:51:22.50,English,,0,0,0,,You've got the tools you've learned with pthreads
Dialogue: 0,0:51:17.81,0:51:22.50,Chinese,,0,0,0,,你已经掌握了线程
Dialogue: 0,0:51:22.92,0:51:27.22,English,,0,0,0,,And your knowledge of programming and your understanding of cache memories and things like that
Dialogue: 0,0:51:22.92,0:51:27.22,Chinese,,0,0,0,,还有编程知识，缓存和内存之类的知识
Dialogue: 0,0:51:27.74,0:51:32.80,English,,0,0,0,,You've got the tools you need to be an effective programmer of this kind of thing
Dialogue: 0,0:51:27.74,0:51:32.80,Chinese,,0,0,0,,你已经掌握了成为一名高效程序员所需的工具
Dialogue: 0,0:51:33.94,0:51:41.36,English,,0,0,0,,But you have to and there's nothing that beats sort of trial and error and testing and tuning experimenting
Dialogue: 0,0:51:33.94,0:51:41.36,Chinese,,0,0,0,,但你最好是测试，没有什么能比试错和测试还有图灵测试更重要了
Dialogue: 0,0:51:41.78,0:51:44.16,English,,0,0,0,,If there's some parameters that need to be set
Dialogue: 0,0:51:41.78,0:51:44.16,Chinese,,0,0,0,,如果需要设置一些参数
Dialogue: 0,0:51:44.32,0:51:48.28,English,,0,0,0,,Then you want to run experiments through the parameters to try and figure out
Dialogue: 0,0:51:44.32,0:51:48.28,Chinese,,0,0,0,,之后你通过提供的参数运行程序来试图弄清楚
Dialogue: 0,0:51:48.88,0:51:50.14,English,,0,0,0,,What the setting should be
Dialogue: 0,0:51:48.88,0:51:50.14,Chinese,,0,0,0,,到底应该设置什么
Dialogue: 0,0:51:52.08,0:51:54.76,English,,0,0,0,,So that's sort of a little bit about parallel programming
Dialogue: 0,0:51:52.08,0:51:54.76,Chinese,,0,0,0,,以上是并行编程的一点介绍
Dialogue: 0,0:51:55.16,0:52:01.50,English,,0,0,0,,Let me just finish this lecture with a little bit of sort of classic issues about concurrency
Dialogue: 0,0:51:55.16,0:52:01.50,Chinese,,0,0,0,,我会讲一些有关并发的经典问题来结束本次课
Dialogue: 0,0:52:01.62,0:52:05.32,English,,0,0,0,,That are critical when you're dealing with
Dialogue: 0,0:52:01.62,0:52:05.32,Chinese,,0,0,0,,这些问题很重要，特别是在
Dialogue: 0,0:52:06.50,0:52:11.14,English,,0,0,0,,These systems based on what you call a shared memory model of computation
Dialogue: 0,0:52:06.50,0:52:11.14,Chinese,,0,0,0,,基于共享内存计算模型的系统
Dialogue: 0,0:52:11.76,0:52:17.62,English,,0,0,0,,So multi-core is an example of conceptually multi-threaded computation
Dialogue: 0,0:52:11.76,0:52:17.62,Chinese,,0,0,0,,因此，多核是多线程计算的一个例子
Dialogue: 0,0:52:17.62,0:52:21.38,English,,0,0,0,,Remember you're working within a single virtual address space
Dialogue: 0,0:52:17.62,0:52:21.38,Chinese,,0,0,0,,还记得，你是在单个虚拟地址内工作的
Dialogue: 0,0:52:22.48,0:52:24.68,English,,0,0,0,,And you have private stacks
Dialogue: 0,0:52:22.48,0:52:24.68,Chinese,,0,0,0,,你有私有堆栈
Dialogue: 0,0:52:25.18,0:52:30.26,English,,0,0,0,,But the more global the heap memory is completely shared across threads
Dialogue: 0,0:52:25.18,0:52:30.26,Chinese,,0,0,0,,但更多全局性的堆内存完全是跨线程共享的
Dialogue: 0,0:52:31.04,0:52:35.06,English,,0,0,0,,And so that's what you call the shared memory programming model
Dialogue: 0,0:52:31.04,0:52:35.06,Chinese,,0,0,0,,这就是共享内存编程模型
Dialogue: 0,0:52:35.18,0:52:36.88,English,,0,0,0,,What we've really been looking at this course
Dialogue: 0,0:52:35.18,0:52:36.88,Chinese,,0,0,0,,这就是我们这次课真正关注的
Dialogue: 0,0:52:38.76,0:52:42.97,English,,0,0,0,,So there's a certain interesting question about called memory consistency models
Dialogue: 0,0:52:38.76,0:52:42.97,Chinese,,0,0,0,,关于内存一致性模型，有一个很有意思的问题
Dialogue: 0,0:52:43.94,0:52:46.58,English,,0,0,0,,And here I'll illustrate it with a very simple example
Dialogue: 0,0:52:43.94,0:52:46.58,Chinese,,0,0,0,,这里，我将用一个非常简单的例子来说明它
Dialogue: 0,0:52:47.12,0:52:50.78,English,,0,0,0,,Imagine we have two global variables a and b
Dialogue: 0,0:52:47.12,0:52:50.78,Chinese,,0,0,0,,想象一下，我们有两个全局变量 a 和 b
Dialogue: 0,0:52:51.02,0:52:52.22,English,,0,0,0,,And we have two different threads
Dialogue: 0,0:52:51.02,0:52:52.22,Chinese,,0,0,0,,我们有两个不同的线程
Dialogue: 0,0:52:53.08,0:52:58.66,English,,0,0,0,,And so the first thread is going to write meaning assign a value to a
Dialogue: 0,0:52:53.08,0:52:58.66,Chinese,,0,0,0,,第一个线程将会进行写操作，给 a 赋值
Dialogue: 0,0:52:59.12,0:53:02.02,English,,0,0,0,,And it's going to read meaning print the value of b
Dialogue: 0,0:52:59.12,0:53:02.02,Chinese,,0,0,0,,并且它将进行读操作，打印 b 的值
Dialogue: 0,0:53:02.72,0:53:08.84,English,,0,0,0,,And the other thread is going to do the opposite it's going to write assigned a value to b and print the value of a
Dialogue: 0,0:53:02.72,0:53:08.84,Chinese,,0,0,0,,另一个线程将执行相反的操作，它将为 b 赋值，并打印 a 的值
Dialogue: 0,0:53:09.40,0:53:14.20,English,,0,0,0,,And so now the question is what are the possible outputs for this program
Dialogue: 0,0:53:09.40,0:53:14.20,Chinese,,0,0,0,,现在问题来了，这个程序输出的结果可能是什么
Dialogue: 0,0:53:15.52,0:53:21.12,English,,0,0,0,,And so there's a model that sort of the accepted standard called sequential consistency
Dialogue: 0,0:53:15.52,0:53:21.12,Chinese,,0,0,0,,有一个模型，像公认的标准一样，叫做「顺序一致性」
Dialogue: 0,0:53:21.64,0:53:24.22,English,,0,0,0,,Which means that these events can occur
Dialogue: 0,0:53:21.64,0:53:24.22,Chinese,,0,0,0,,这意味着可以发生这些事件
Dialogue: 0,0:53:24.68,0:53:33.56,English,,0,0,0,,these that within a single thread things have to occur in the sequential order of that thread
Dialogue: 0,0:53:24.68,0:53:33.56,Chinese,,0,0,0,,单个线程中的东西肯定按照该线程的顺序来进行的
Dialogue: 0,0:53:34.52,0:53:40.98,English,,0,0,0,,But across threads whether write a write b occurs first is completely arbitrary
Dialogue: 0,0:53:34.52,0:53:40.98,Chinese,,0,0,0,,但是对于跨线程先写 a 还是先写入 b 是完全随意的
Dialogue: 0,0:53:41.30,0:53:43.80,English,,0,0,0,,And similarly whether writing of b occurs
Dialogue: 0,0:53:41.30,0:53:43.80,Chinese,,0,0,0,,并且类似地 b 的写入会发生在
Dialogue: 0,0:53:44.56,0:53:52.20,English,,0,0,0,,Between these two actions or before is all too arbitrary
Dialogue: 0,0:53:44.56,0:53:52.20,Chinese,,0,0,0,,这两个行动之间或以前都有可能，这都太随意了
Dialogue: 0,0:53:52.28,0:54:01.56,English,,0,0,0,,So what it means is you can take two different threads and you can interleave their events in anyway
Dialogue: 0,0:53:52.28,0:54:01.56,Chinese,,0,0,0,,这意味着你可以创建两种不同的线程，而且你可以任意交错它们俩事件
Dialogue: 0,0:54:02.26,0:54:10.98,English,,0,0,0,,But you should be able to pull out of that interleaving the sequential order of either of both of the two threads
Dialogue: 0,0:54:02.26,0:54:10.98,Chinese,,0,0,0,,但是，你应该可以从这两个线程中的任何一个穿插顺序中抽出这两个线程的顺序
Dialogue: 0,0:54:12.48,0:54:16.54,English,,0,0,0,,So when you do that you end up you can enumerate in the example like this
Dialogue: 0,0:54:12.48,0:54:16.54,Chinese,,0,0,0,,所以，当你这样做的时候，你可以像这样列出所有情况
Dialogue: 0,0:54:17.00,0:54:19.26,English,,0,0,0,,All the possibilities you can say well look it
Dialogue: 0,0:54:17.00,0:54:19.26,Chinese,,0,0,0,,你们看到的就是所有的情况
Dialogue: 0,0:54:20.12,0:54:22.48,English,,0,0,0,,First is either going to be write a or write b
Dialogue: 0,0:54:20.12,0:54:22.48,Chinese,,0,0,0,,第一步，先写 a还是先写 b，两种情况选一个
Dialogue: 0,0:54:23.40,0:54:24.60,English,,0,0,0,,Let's pick write a
Dialogue: 0,0:54:23.40,0:54:24.60,Chinese,,0,0,0,,我们选择先写 a
Dialogue: 0,0:54:25.42,0:54:30.04,English,,0,0,0,,So now the next event will be either read of b or write of b
Dialogue: 0,0:54:25.42,0:54:30.04,Chinese,,0,0,0,,所以接下来事件就是要么读取 b 要么写入 b
Dialogue: 0,0:54:31.86,0:54:36.10,English,,0,0,0,,And then if I do write a read b
Dialogue: 0,0:54:31.86,0:54:36.10,Chinese,,0,0,0,,如果我选择写入 a 读取 b
Dialogue: 0,0:54:36.78,0:54:38.42,English,,0,0,0,,Then I've completed this thread
Dialogue: 0,0:54:36.78,0:54:38.42,Chinese,,0,0,0,,我就在这个线程中完成了
Dialogue: 0,0:54:39.04,0:54:44.44,English,,0,0,0,,And so now the only possibility is to write to b and read a, and so forth
Dialogue: 0,0:54:39.04,0:54:44.44,Chinese,,0,0,0,,所以现在唯一的可能是写入 b 并读取 a，等等其他情况
Dialogue: 0,0:54:44.52,0:54:48.74,English,,0,0,0,,You work out all the possible things you get six different event orderings
Dialogue: 0,0:54:44.52,0:54:48.74,Chinese,,0,0,0,,如果你列出所有的可能性，你会得到 6 种不同的事件顺序
Dialogue: 0,0:54:49.52,0:54:53.08,English,,0,0,0,,And then what will be printed is well first of all
Dialogue: 0,0:54:49.52,0:54:53.08,Chinese,,0,0,0,,然后首先要打印的是什么
Dialogue: 0,0:54:53.22,0:54:59.42,English,,0,0,0,,Whether you print b before a would depend on the relative ordering of those two threads
Dialogue: 0,0:54:53.22,0:54:59.42,Chinese,,0,0,0,,是否在a之前打印b，取决于这两个线程的相对顺序
Dialogue: 0,0:54:59.42,0:55:02.34,English,,0,0,0,,So that's shown I'm showing the b value in blue
Dialogue: 0,0:54:59.42,0:55:02.34,Chinese,,0,0,0,,所以，这里我用蓝色显示 b 的值
Dialogue: 0,0:55:03.06,0:55:07.54,English,,0,0,0,,And the red value in red I'm sorry the a value in red
Dialogue: 0,0:55:03.06,0:55:07.54,Chinese,,0,0,0,,红色的是 a 的值
Dialogue: 0,0:55:09.02,0:55:14.88,English,,0,0,0,,And you'll get these different possibilities,these are all the six possible outputs of this program
Dialogue: 0,0:55:09.02,0:55:14.88,Chinese,,0,0,0,,你会得到这个程序的六种不同可能的输出
Dialogue: 0,0:55:15.54,0:55:22.88,English,,0,0,0,,But you'll see that there are two other outputs one could imagine that won't arise
Dialogue: 0,0:55:15.54,0:55:22.88,Chinese,,0,0,0,,但是你会发现有两个可能的输出不会出现
Dialogue: 0,0:55:23.78,0:55:28.52,English,,0,0,0,,One is to print 100 and 1
Dialogue: 0,0:55:23.78,0:55:28.52,Chinese,,0,0,0,,一种是打印 100， 1
Dialogue: 0,0:55:28.58,0:55:34.28,English,,0,0,0,,In other words to have them both print the original values of these two variables
Dialogue: 0,0:55:28.58,0:55:34.28,Chinese,,0,0,0,,换句话说就是打印这两个变量的原始值
Dialogue: 0,0:55:34.88,0:55:36.62,English,,0,0,0,,And that's impossible because
Dialogue: 0,0:55:34.88,0:55:36.62,Chinese,,0,0,0,,这是不可能的
Dialogue: 0,0:55:37.74,0:55:39.86,English,,0,0,0,,I have to have done at least one write
Dialogue: 0,0:55:37.74,0:55:39.86,Chinese,,0,0,0,,因为我必须至少完成一次写操作
Dialogue: 0,0:55:42.26,0:55:45.84,English,,0,0,0,,Before I can reach either of these two print statements right
Dialogue: 0,0:55:42.26,0:55:45.84,Chinese,,0,0,0,,之后才能执行两条打印语句的其中一条
Dialogue: 0,0:55:46.28,0:55:53.62,English,,0,0,0,,So it's not possible for these to still be in their original values of When I hit these print statements
Dialogue: 0,0:55:46.28,0:55:53.62,Chinese,,0,0,0,,所以在我执行打印语句时，它们不可能仍然是原来的值
Dialogue: 0,0:55:56.14,0:56:01.06,English,,0,0,0,,And whichever order I hit these two,so those two are impossible
Dialogue: 0,0:55:56.14,0:56:01.06,Chinese,,0,0,0,,无论是这两种情况中的哪一种都是不可能的
Dialogue: 0,0:56:01.36,0:56:04.48,English,,0,0,0,,So that's the idea of sequential consistency that there's
Dialogue: 0,0:56:01.36,0:56:04.48,Chinese,,0,0,0,,所以这就是顺序一致性
Dialogue: 0,0:56:05.16,0:56:10.96,English,,0,0,0,,Some very large number but of possible outputs of a program
Dialogue: 0,0:56:05.16,0:56:10.96,Chinese,,0,0,0,,即使这个程序会输出很大的值
Dialogue: 0,0:56:11.42,0:56:17.26,English,,0,0,0,,But in any case they can't violate The ordering implied by the individual threads
Dialogue: 0,0:56:11.42,0:56:17.26,Chinese,,0,0,0,,但无论如何，他们都不能违反线程隐含顺序
Dialogue: 0,0:56:19.44,0:56:23.36,English,,0,0,0,,So you'd say okay that seems like pretty obvious thing
Dialogue: 0,0:56:19.44,0:56:23.36,Chinese,,0,0,0,,所以你说那好吧，这本来看起来就很明显
Dialogue: 0,0:56:24.66,0:56:29.16,English,,0,0,0,,But actually if you think from a hardware perspective it's not that trivial to make that happen
Dialogue: 0,0:56:24.66,0:56:29.16,Chinese,,0,0,0,,但实际上，如果你从硬件的角度思考，实现这一目标并非易事
Dialogue: 0,0:56:30.04,0:56:36.04,English,,0,0,0,,So let me just throw a show you a scenario of multi-core hardware
Dialogue: 0,0:56:30.04,0:56:36.04,Chinese,,0,0,0,,接下来我会展示一个多核的场景
Dialogue: 0,0:56:36.58,0:56:38.70,English,,0,0,0,,That would violate sequential consistency
Dialogue: 0,0:56:36.58,0:56:38.70,Chinese,,0,0,0,,这会违反顺序一致性
Dialogue: 0,0:56:39.72,0:56:42.98,English,,0,0,0,,Assume that each of our threads has its own private cache
Dialogue: 0,0:56:39.72,0:56:42.98,Chinese,,0,0,0,,假设我们的每个线程都有自己的私有缓存
Dialogue: 0,0:56:44.68,0:56:49.74,English,,0,0,0,,And so if I execute this statement
Dialogue: 0,0:56:44.68,0:56:49.74,Chinese,,0,0,0,,所以如果我执行这条语句
Dialogue: 0,0:56:50.14,0:56:57.26,English,,0,0,0,,What I'll do is I will grab a copy of a from the main memory and bring it into my cache
Dialogue: 0,0:56:50.14,0:56:57.26,Chinese,,0,0,0,,我要做的是从内存中复制 a 到线程的缓存中
Dialogue: 0,0:56:57.82,0:56:59.92,English,,0,0,0,,And I will assign this new value to it
Dialogue: 0,0:56:57.82,0:56:59.92,Chinese,,0,0,0,,然后我给 a 赋一个新值
Dialogue: 0,0:57:00.96,0:57:08.20,English,,0,0,0,,And similarly a thread to will grab a copy of its of b and update that
Dialogue: 0,0:57:00.96,0:57:08.20,Chinese,,0,0,0,,类似地，线程 2 也将获得 b 的副本并更新它
Dialogue: 0,0:57:09.68,0:57:13.98,English,,0,0,0,,And now if I do my two print statements
Dialogue: 0,0:57:09.68,0:57:13.98,Chinese,,0,0,0,,如果我限制执行这两条打印语句
Dialogue: 0,0:57:14.54,0:57:18.02,English,,0,0,0,,If thread two picks up the value from the memory
Dialogue: 0,0:57:14.54,0:57:18.02,Chinese,,0,0,0,,如果线程 2 从内存中获取 a 的值
Dialogue: 0,0:57:18.54,0:57:24.10,English,,0,0,0,,Not knowing that thread 1 as a modified copy of that value  then it would naturally print one
Dialogue: 0,0:57:18.54,0:57:24.10,Chinese,,0,0,0,,但它不知道线程 1 已经修改了 a 的副本的值，所以这里很自然输出 1
Dialogue: 0,0:57:24.96,0:57:30.44,English,,0,0,0,,And similarly if thread one picked up a copy of b from main memory it would print 100
Dialogue: 0,0:57:24.96,0:57:30.44,Chinese,,0,0,0,,类似地，如果线程 1 从内存中获取 b 的副本，那么这里会输出 100
Dialogue: 0,0:57:30.54,0:57:36.90,English,,0,0,0,,So we'd see exactly this unallowable execution and the reason is
Dialogue: 0,0:57:30.54,0:57:36.90,Chinese,,0,0,0,,所以我们确实看到了出现了不可能的情况，原因是
Dialogue: 0,0:57:37.48,0:57:42.36,English,,0,0,0,,Because each of these threads have their own private copies of these variables
Dialogue: 0,0:57:37.48,0:57:42.36,Chinese,,0,0,0,,因为这些线程中的每一个都有这些变量的私有副本
Dialogue: 0,0:57:42.84,0:57:45.40,English,,0,0,0,,And they're not properly synchronized
Dialogue: 0,0:57:42.84,0:57:45.40,Chinese,,0,0,0,,而且它们没有正确同步
Dialogue: 0,0:57:46.18,0:57:50.90,English,,0,0,0,,But you could see in a hardware scenario it would be easy to build this hardware and make that mistake
Dialogue: 0,0:57:46.18,0:57:50.90,Chinese,,0,0,0,,但你可以看到，在硬件场景中，你很容易打造这种硬件并犯这样的错误
Dialogue: 0,0:57:52.30,0:57:55.92,English,,0,0,0,,So how does it work in a multi-core processor well
Dialogue: 0,0:57:52.30,0:57:55.92,Chinese,,0,0,0,,那么如何在多核处理器中处理这种情况呢
Dialogue: 0,0:57:56.46,0:57:59.26,English,,0,0,0,,They have a trick they call it snoopy caches
Dialogue: 0,0:57:56.46,0:57:59.26,Chinese,,0,0,0,,这里会运用一个技巧，称之为「snoopy caches」
Dialogue: 0,0:58:00.34,0:58:05.72,English,,0,0,0,,And it's a little bit like the readers writers of synchronization that
Dialogue: 0,0:58:00.34,0:58:05.72,Chinese,,0,0,0,,它有点像读操作，写操作同步进行
Dialogue: 0,0:58:05.72,0:58:07.94,English,,0,0,0,,You're working on for your proxies
Dialogue: 0,0:58:05.72,0:58:07.94,Chinese,,0,0,0,,这些是由代理还完成的
Dialogue: 0,0:58:08.56,0:58:13.28,English,,0,0,0,,That you want to make it so that if everyone's just reading some shared value
Dialogue: 0,0:58:08.56,0:58:13.28,Chinese,,0,0,0,,要想到每个人都会读取一些共享的值
Dialogue: 0,0:58:13.64,0:58:19.44,English,,0,0,0,,They should be able to get copies into their own caches  to optimize the performance of it
Dialogue: 0,0:58:13.64,0:58:19.44,Chinese,,0,0,0,,并且他们会复制一份副本保存在自己的缓存中来提升性能
Dialogue: 0,0:58:20.26,0:58:24.96,English,,0,0,0,,But if one of them wants to write to it,it needs to get an exclusive copy of it
Dialogue: 0,0:58:20.26,0:58:24.96,Chinese,,0,0,0,,但如果其中一个人想要对它进行写操作，他需要获得一份独有的副本
Dialogue: 0,0:58:25.62,0:58:27.58,English,,0,0,0,,And lock out any other thread
Dialogue: 0,0:58:25.62,0:58:27.58,Chinese,,0,0,0,,并且要对它进行上锁
Dialogue: 0,0:58:28.06,0:58:35.46,English,,0,0,0,,From accessing that either to read it or to write it from long enough to make the update
Dialogue: 0,0:58:28.06,0:58:35.46,Chinese,,0,0,0,,阻止其他线程对它进行读操作或者写操作，以便获取足够的时间来对它进行更新
Dialogue: 0,0:58:36.42,0:58:37.56,English,,0,0,0,,And so
Dialogue: 0,0:58:36.42,0:58:37.56,Chinese,,0,0,0,,所以
Dialogue: 0,0:58:40.12,0:58:48.16,English,,0,0,0,,They have a protocol where they tag actually and these tags are at the level of cache lines typically
Dialogue: 0,0:58:40.12,0:58:48.16,Chinese,,0,0,0,,他们遵循一个协议，实际是一种标签，这些标签通常位于缓存行这个级别
Dialogue: 0,0:58:48.78,0:58:55.28,English,,0,0,0,,So the tagged cache line in main memory with its state and the typical state would be invalid
Dialogue: 0,0:58:48.78,0:58:55.28,Chinese,,0,0,0,,因此，如果内存中有缓存行被标记了，就意味着缓存行的状态为「无效」\n（不能被其他线程进行读写）
Dialogue: 0,0:58:56.12,0:58:59.52,English,,0,0,0,,It's shared or it's exclusive
Dialogue: 0,0:58:56.12,0:58:59.52,Chinese,,0,0,0,,它要么是共享的，要么是排他的
Dialogue: 0,0:59:00.14,0:59:06.74,English,,0,0,0,,So shared means that there can be a copies of it but they can only be read-only copies
Dialogue: 0,0:59:00.14,0:59:06.74,Chinese,,0,0,0,,所以「共享」意味着他们可以复制只读副本
Dialogue: 0,0:59:07.34,0:59:14.08,English,,0,0,0,,And exclusive meaning that it's exclusively available to a single thread
Dialogue: 0,0:59:07.34,0:59:14.08,Chinese,,0,0,0,,「排他」意味着它仅供单个线程使用
Dialogue: 0,0:59:15.84,0:59:19.36,English,,0,0,0,,So this is built into them the hardware of a multi-core processor
Dialogue: 0,0:59:15.84,0:59:19.36,Chinese,,0,0,0,,它内置于多核处理器的硬件中
Dialogue: 0,0:59:20.08,0:59:21.44,English,,0,0,0,,So what will happen that is 
Dialogue: 0,0:59:20.08,0:59:21.44,Chinese,,0,0,0,,那么，会发生什么事呢？
Dialogue: 0,0:59:22.76,0:59:30.18,English,,0,0,0,,In order to do a write to a thread 1 will acquire an exclusive copy of this element
Dialogue: 0,0:59:22.76,0:59:30.18,Chinese,,0,0,0,,为了对 a 进行写操作， 线程 1 会获得这个元素独有的拷贝
Dialogue: 0,0:59:30.18,0:59:34.88,English,,0,0,0,,And that actually tagging happens down here at the main memory and in the cache both
Dialogue: 0,0:59:30.18,0:59:34.88,Chinese,,0,0,0,,实际上，内存和缓存都会被标记
Dialogue: 0,0:59:37.86,0:59:44.22,English,,0,0,0,,Oh and similarly if thread 2 wants a to write to b
Dialogue: 0,0:59:37.86,0:59:44.22,Chinese,,0,0,0,,类似的，如果线程 2 想要对 b 进行写操作
Dialogue: 0,0:59:44.52,0:59:46.72,English,,0,0,0,,It must get an exclusive copy of that
Dialogue: 0,0:59:44.52,0:59:46.72,Chinese,,0,0,0,,它必须得到它的独家副本
Dialogue: 0,0:59:48.44,0:59:54.46,English,,0,0,0,,And then when the read occurs what happens is actually this cache miss
Dialogue: 0,0:59:48.44,0:59:54.46,Chinese,,0,0,0,,然后进行读操作时，如果缓存没有命中会发生什么
Dialogue: 0,0:59:54.68,1:00:01.34,English,,0,0,0,,Will send out a signal on a bus a shared communication medium saying I want to read a
Dialogue: 0,0:59:54.68,1:00:01.34,Chinese,,0,0,0,,将会给共享通信总线发送一个信号，说我想要读取 a
Dialogue: 0,1:00:02.50,1:00:06.32,English,,0,0,0,,And instead of the main memory responding to it actually it will
Dialogue: 0,1:00:02.50,1:00:06.32,Chinese,,0,0,0,,但这次不会从内存中直接读取
Dialogue: 0,1:00:07.84,1:00:11.54,English,,0,0,0,,That result will be supplied by the other cache
Dialogue: 0,1:00:07.84,1:00:11.54,Chinese,,0,0,0,,而是由其他的缓存来提供对应的值
Dialogue: 0,1:00:12.42,1:00:16.54,English,,0,0,0,,And it will convert the state of this element to being a shared element
Dialogue: 0,1:00:12.42,1:00:16.54,Chinese,,0,0,0,,它会将该元素的状态设置为「共享」
Dialogue: 0,1:00:18.74,1:00:23.20,English,,0,0,0,,Locally but you'll see that the main memory element isn't updated yet it
Dialogue: 0,1:00:18.74,1:00:23.20,Chinese,,0,0,0,,但是你会看到内存中的元素尚未更新
Dialogue: 0,1:00:23.20,1:00:26.30,English,,0,0,0,,Goes through the whole write back protocol you've already seen
Dialogue: 0,1:00:23.20,1:00:26.30,Chinese,,0,0,0,,通过这个你已经看到了整个写入过程
Dialogue: 0,1:00:26.82,1:00:29.50,English,,0,0,0,,And sometimes it will update that there's different implementations
Dialogue: 0,1:00:26.82,1:00:29.50,Chinese,,0,0,0,,有时它会更新有不同的实现
Dialogue: 0,1:00:30.16,1:00:31.88,English,,0,0,0,,But this is why it's called a snoopy cache is
Dialogue: 0,1:00:30.16,1:00:31.88,Chinese,,0,0,0,,但它被称为 snoopy cache 的原因是
Dialogue: 0,1:00:32.04,1:00:40.70,English,,0,0,0,,That it basically thread 2 is peeking into or getting it access to information That's available in thread 1 cache
Dialogue: 0,1:00:32.04,1:00:40.70,Chinese,,0,0,0,,基本上是线程 2 想要读取线程 1 中已经缓存的信息
Dialogue: 0,1:00:43.10,1:00:48.96,English,,0,0,0,,And so now thread 2 will correctly get a copy of a
Dialogue: 0,1:00:43.10,1:00:48.96,Chinese,,0,0,0,,所以现在线程 2 获得了正确的 a 的拷贝
Dialogue: 0,1:00:49.46,1:00:50.98,English,,0,0,0,,That's in this shared state
Dialogue: 0,1:00:49.46,1:00:50.98,Chinese,,0,0,0,,这个是共享状态
Dialogue: 0,1:00:51.62,1:00:57.30,English,,0,0,0,,And the same goes would be it will snoop over and thread two will one will get a readable copy
Dialogue: 0,1:00:51.62,1:00:57.30,Chinese,,0,0,0,,同样，线程 1 也获得了一个可读的副本
Dialogue: 0,1:00:57.88,1:00:59.92,English,,0,0,0,,These are now all marked as shared state
Dialogue: 0,1:00:57.88,1:00:59.92,Chinese,,0,0,0,,现在这些都标记为共享状态
Dialogue: 0,1:01:00.52,1:01:04.68,English,,0,0,0,,And so if either of them want to write
Dialogue: 0,1:01:00.52,1:01:04.68,Chinese,,0,0,0,,所以如果其中一个想要进行写操作
Dialogue: 0,1:01:04.68,1:01:08.74,English,,0,0,0,,They'd have to now basically get exclusive access to it
Dialogue: 0,1:01:04.68,1:01:08.74,Chinese,,0,0,0,,现在他们必须获得独占权限
Dialogue: 0,1:01:09.06,1:01:16.04,English,,0,0,0,,And that would have to then disable the copy in the other location
Dialogue: 0,1:01:09.06,1:01:16.04,Chinese,,0,0,0,,这样以来就会禁用其它地方的复制操作
Dialogue: 0,1:01:16.16,1:01:20.48,English,,0,0,0,,So you can imagine this protocol being non-trivial actually to get right and to implement
Dialogue: 0,1:01:16.16,1:01:20.48,Chinese,,0,0,0,,所以你可以想象，这个协议实现起来有一定的难度
Dialogue: 0,1:01:20.90,1:01:24.80,English,,0,0,0,,And it gets way more complicated than this with all the variations on it
Dialogue: 0,1:01:20.90,1:01:24.80,Chinese,,0,0,0,,因为它比较复杂，而且有很多的变化
Dialogue: 0,1:01:26.10,1:01:31.10,English,,0,0,0,,So but it's become the norm in multi-core hardware design
Dialogue: 0,1:01:26.10,1:01:31.10,Chinese,,0,0,0,,但是它已成为多核硬件设计的常态
Dialogue: 0,1:01:31.86,1:01:36.36,English,,0,0,0,,But it's actually part of the factor that limits the core count on a processor
Dialogue: 0,1:01:31.86,1:01:36.36,Chinese,,0,0,0,,实际上这也是限制处理器核心数量的因素之一
Dialogue: 0,1:01:37.08,1:01:43.32,English,,0,0,0,,Because just the hardware involved in keeping the consistency across the caches is non-trivial
Dialogue: 0,1:01:37.08,1:01:43.32,Chinese,,0,0,0,,因为从硬件上保持高速缓存之间一致性及并非易事
Dialogue: 0,1:01:43.32,1:01:49.12,English,,0,0,0,,It has to work very fast we're talking at the cache rate access speeds
Dialogue: 0,1:01:43.32,1:01:49.12,Chinese,,0,0,0,,它的工作速度必须非常快，这里我们说的是缓存的访问速度
Dialogue: 0,1:01:49.88,1:01:52.30,English,,0,0,0,,So there's not a lot of time involved in there
Dialogue: 0,1:01:49.88,1:01:52.30,Chinese,,0,0,0,,所以在那里面的时间并不多
Dialogue: 0,1:01:52.42,1:01:54.96,English,,0,0,0,,So actually implementing this stuff making it run
Dialogue: 0,1:01:52.42,1:01:54.96,Chinese,,0,0,0,,所以实际上实现这个东西让它运行
Dialogue: 0,1:01:55.42,1:02:01.70,English,,0,0,0,,Making it scale across say 8 cores,10 cores,16 cores is not a not a trivial thing
Dialogue: 0,1:01:55.42,1:02:01.70,Chinese,,0,0,0,,将其扩展为 8 核， 10 核， 16 核并不是一件容易的事
Dialogue: 0,1:02:02.20,1:02:07.72,English,,0,0,0,,But that that goes on in the background and so you can for most systems nowadays you can assume that
Dialogue: 0,1:02:02.20,1:02:07.72,Chinese,,0,0,0,,但是这种情况在后台发生，所以你假设现代大多数系统
Dialogue: 0,1:02:09.88,1:02:15.84,English,,0,0,0,,There's some memory consistency model that you can program to that's supported by the hardware of the system
Dialogue: 0,1:02:09.88,1:02:15.84,Chinese,,0,0,0,,是内存一致性模型，你可以根据系统的硬件支持的内存一致性模型来编程
Dialogue: 0,1:02:17.30,1:02:24.22,English,,0,0,0,,And that this serial serializability that's referred to as sort of the easiest to understand
Dialogue: 0,1:02:17.30,1:02:24.22,Chinese,,0,0,0,,而这种被称为最容易理解的序列化的序列化能力
Dialogue: 0,1:02:24.34,1:02:26.28,English,,0,0,0,,There's others at a little bit more nuanced
Dialogue: 0,1:02:24.34,1:02:26.28,Chinese,,0,0,0,,还有其他一些细微差别
Dialogue: 0,1:02:29.04,1:02:33.40,English,,0,0,0,,Well guess that fell off the bottom here and doesn't seem right
Dialogue: 0,1:02:29.04,1:02:33.40,Chinese,,0,0,0,,好吧，落到底部，好像不对
Dialogue: 0,1:02:42.30,1:02:42.98,English,,0,0,0,,That's it
Dialogue: 0,1:02:42.30,1:02:42.98,Chinese,,0,0,0,,而已
Dialogue: 0,1:02:43.88,1:02:46.80,English,,0,0,0,,Okay so just to wrap that up then
Dialogue: 0,1:02:43.88,1:02:46.80,Chinese,,0,0,0,,好的，那就是把它包起来
Dialogue: 0,1:02:48.56,1:02:50.82,English,,0,0,0,,It gives you a flavor of and
Dialogue: 0,1:02:48.56,1:02:50.82,Chinese,,0,0,0,,它给你一种体会
Dialogue: 0,1:02:52.10,1:02:57.62,English,,0,0,0,,You can see that getting programs to run fast through multi-threading is not easy
Dialogue: 0,1:02:52.10,1:02:57.62,Chinese,,0,0,0,,你可以看到想要通过多线程让加速程序的运行并不容易
Dialogue: 0,1:02:58.16,1:03:02.98,English,,0,0,0,,You often have to rewrite your application,you have to think about the algorithm,you have to worry about debugging
Dialogue: 0,1:02:58.16,1:03:02.98,Chinese,,0,0,0,,你经常需要重写你的应用程序，设计算法，调试代码
Dialogue: 0,1:03:03.52,1:03:06.52,English,,0,0,0,,It as you've already discovered at both the
Dialogue: 0,1:03:03.52,1:03:06.52,Chinese,,0,0,0,,或许你已经发现
Dialogue: 0,1:03:07.28,1:03:12.28,English,,0,0,0,,The shell lab and the proxy lab that concurrency where you can't predict the order of events
Dialogue: 0,1:03:07.28,1:03:12.28,Chinese,,0,0,0,,「shell lab」 和「proxy lab」并发时你无法预测事件的顺序
Dialogue: 0,1:03:12.88,1:03:16.30,English,,0,0,0,,Makes it much more difficult to debug code
Dialogue: 0,1:03:12.88,1:03:16.30,Chinese,,0,0,0,,而且让调试代码变得更加困难
Dialogue: 0,1:03:16.80,1:03:18.62,English,,0,0,0,,So all these factors come in
Dialogue: 0,1:03:16.80,1:03:18.62,Chinese,,0,0,0,,当这些出现时
Dialogue: 0,1:03:20.18,1:03:24.30,English,,0,0,0,,And you have to have some understanding of the underlying mechanisms that are used
Dialogue: 0,1:03:20.18,1:03:24.30,Chinese,,0,0,0,,你必须对所使用的基本机制有一定的了解
Dialogue: 0,1:03:24.98,1:03:27.02,English,,0,0,0,,And what their performance implications are
Dialogue: 0,1:03:24.98,1:03:27.02,Chinese,,0,0,0,,以及它们的性能影响是什么
Dialogue: 0,1:03:27.66,1:03:30.12,English,,0,0,0,,So in particular let me just observe here that
Dialogue: 0,1:03:27.66,1:03:30.12,Chinese,,0,0,0,,因此，我要在此特别指出
Dialogue: 0,1:03:32.58,1:03:34.98,English,,0,0,0,,If I'm like doing synchronization
Dialogue: 0,1:03:32.58,1:03:34.98,Chinese,,0,0,0,,如果我喜欢做同步
Dialogue: 0,1:03:37.36,1:03:43.06,English,,0,0,0,,Across threads like you saw that original one where they are fighting over this global variable
Dialogue: 0,1:03:37.36,1:03:43.06,Chinese,,0,0,0,,像之前的那个版本，他们正在争夺这个全局变量
Dialogue: 0,1:03:43.58,1:03:44.98,English,,0,0,0,, psum whatever it was called
Dialogue: 0,1:03:43.58,1:03:44.98,Chinese,,0,0,0,, psum 无论它叫什么
Dialogue: 0,1:03:46.12,1:03:48.24,English,,0,0,0,,You can imagine these the caches
Dialogue: 0,1:03:46.12,1:03:48.24,Chinese,,0,0,0,,你可以想象这些缓存......
Dialogue: 0,1:03:48.66,1:03:57.48,English,,0,0,0,,In this battle with each other to try and get exclusive access to this single memory of value
Dialogue: 0,1:03:48.66,1:03:57.48,Chinese,,0,0,0,,在这场与对方的战斗中，都试图去抢占单个内存值的独占访问权限
Dialogue: 0,1:03:58.34,1:04:04.04,English,,0,0,0,,And because each one is running as fast as it possibly can
Dialogue: 0,1:03:58.34,1:04:04.04,Chinese,,0,0,0,,因为越快越有机会
Dialogue: 0,1:04:04.20,1:04:11.20,English,,0,0,0,,But each one requires getting exclusive copy writing to it and releasing it
Dialogue: 0,1:04:04.20,1:04:11.20,Chinese,,0,0,0,,但是每个线程必须获得独占权限之后才能进行复制，写入，释放
Dialogue: 0,1:04:11.32,1:04:15.98,English,,0,0,0,,So that locking mechanism is flying back and forth between these caches
Dialogue: 0,1:04:11.32,1:04:15.98,Chinese,,0,0,0,,所以锁定机制在这些缓存之间来回飞舞着
Dialogue: 0,1:04:16.68,1:04:18.72,English,,0,0,0,,And it's really not very fast so
Dialogue: 0,1:04:16.68,1:04:18.72,Chinese,,0,0,0,,它真的不是很快
Dialogue: 0,1:04:19.16,1:04:22.52,English,,0,0,0,,That's the kind of thing is why
Dialogue: 0,1:04:19.16,1:04:22.52,Chinese,,0,0,0,,这就是为什么......
Dialogue: 0,1:04:24.02,1:04:29.18,English,,0,0,0,,And also you know as an application programmer you're making calls
Dialogue: 0,1:04:24.02,1:04:29.18,Chinese,,0,0,0,,而且你知道作为应用程序
Dialogue: 0,1:04:30.18,1:04:35.50,English,,0,0,0,,Semaphore call bounces you up into the OS kernel which is a cost involved
Dialogue: 0,1:04:30.18,1:04:35.50,Chinese,,0,0,0,,发送信号让操作系统内核来调用代价很高
Dialogue: 0,1:04:36.20,1:04:43.04,English,,0,0,0,,So this thing has all the bad all the things that make programs not run the way you really like them to
Dialogue: 0,1:04:36.20,1:04:43.04,Chinese,,0,0,0,,所以这东西各有优缺点，所有的东西都会让程序不能按照你喜欢的方式运行
Dialogue: 0,1:04:43.52,1:04:48.48,English,,0,0,0,,So that's one of the challenges in parallel programming is how do you actually
Dialogue: 0,1:04:43.52,1:04:48.48,Chinese,,0,0,0,,因此，并行编程的挑战之一就是
Dialogue: 0,1:04:49.16,1:04:57.24,English,,0,0,0,,Make use of the parallelism that's there Without getting bogged down by the cost of the various mechanisms of control
Dialogue: 0,1:04:49.16,1:04:57.24,Chinese,,0,0,0,,你如何实际利用存在的并行性，而不被各种控制机制的成本所困住 
Dialogue: 0,1:04:58.86,1:05:03.54,English,,0,0,0,,Oh so anyways this is part of what you have to appreciate and understand as a programmer
Dialogue: 0,1:04:58.86,1:05:03.54,Chinese,,0,0,0,,所以无论如何，这是作为一个程序员，你必须接受和理解的这部分
Dialogue: 0,1:05:04.00,1:05:08.56,English,,0,0,0,,Is how these things work at a level deep enough that you'll have some sense of
Dialogue: 0,1:05:04.00,1:05:08.56,Chinese,,0,0,0,,这些东西是如何运作的，是否有足够深的层次，让你有了一定的感悟
Dialogue: 0,1:05:08.56,1:05:13.28,English,,0,0,0,,What makes programs run faster or slower where the mistakes could want
Dialogue: 0,1:05:08.56,1:05:13.28,Chinese,,0,0,0,,什么情况会让程序运行的更快或者更慢，什么情况会出错
Dialogue: 0,1:05:14.98,1:05:18.62,English,,0,0,0,,So that's just a little flavor of a much bigger topic
Dialogue: 0,1:05:14.98,1:05:18.62,Chinese,,0,0,0,,所以，这只是一个更大的话题了
Dialogue: 0,1:05:19.48,1:05:20.48,English,,0,0,0,,So that's it for today
Dialogue: 0,1:05:19.48,1:05:20.48,Chinese,,0,0,0,,今天的课就到这里
