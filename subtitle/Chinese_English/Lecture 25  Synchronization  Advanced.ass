[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 25  Synchronization  Advanced.mp4
Video File: ../../../../Desktop/csapp/Lecture 25  Synchronization  Advanced.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.125000
Scroll Position: 1759
Active Line: 1763
Video Position: 144883

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,34,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,46,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:01.70,English,,0,0,0,,Well good afternoon everybody
Dialogue: 0,0:00:00.03,0:00:01.70,Chinese,,0,0,0,,大家下午好
Dialogue: 0,0:00:02.68,0:00:07.94,English,,0,0,0,,Welcome good to see you and welcome to our viewers on video as well
Dialogue: 0,0:00:02.68,0:00:07.94,Chinese,,0,0,0,,很高兴见到你们，也欢迎观看我们视频录像的观众
Dialogue: 0,0:00:09.54,0:00:15.96,English,,0,0,0,,Okay so today we're going to look at some additional issues around the problem of synchronizing threaded programs
Dialogue: 0,0:00:09.54,0:00:15.96,Chinese,,0,0,0,,今天我们将讨论有关同步线程程序的一些额外问题
Dialogue: 0,0:00:17.72,0:00:21.44,English,,0,0,0,,First so let's review from last time of a few of the concepts
Dialogue: 0,0:00:17.72,0:00:21.44,Chinese,,0,0,0,,首先让我们回顾一下上次课中的概念
Dialogue: 0,0:00:22.32,0:00:29.56,English,,0,0,0,,So recall that a semaphore is a non-negative global synchronization variable
Dialogue: 0,0:00:22.32,0:00:29.56,Chinese,,0,0,0,,所以请记住，信号量是一个非负全局同步变量
Dialogue: 0,0:00:29.56,0:00:31.36,English,,0,0,0,,It's manipulated by P and V operations
Dialogue: 0,0:00:29.56,0:00:31.36,Chinese,,0,0,0,,它由 P 和 V 操作维护
Dialogue: 0,0:00:32.28,0:00:36.92,English,,0,0,0,,And the P operation takes as an argument a semaphore
Dialogue: 0,0:00:32.28,0:00:36.92,Chinese,,0,0,0,,并且 P 操作将信号量作为参数
Dialogue: 0,0:00:38.70,0:00:44.96,English,,0,0,0,,If the semaphore values nonzero it decrements the semaphore and then continues
Dialogue: 0,0:00:38.70,0:00:44.96,Chinese,,0,0,0,,如果信号量值大于 0，P 操作会将信号量减 1 然后继续
Dialogue: 0,0:00:45.74,0:00:48.08,English,,0,0,0,,If the semaphore values zero
Dialogue: 0,0:00:45.74,0:00:48.08,Chinese,,0,0,0,,如果信号量值为 0
Dialogue: 0,0:00:49.58,0:00:55.98,English,,0,0,0,,Then it blocks waiting for that semaphore value to be incremented by a V operation
Dialogue: 0,0:00:49.58,0:00:55.98,Chinese,,0,0,0,,就会阻塞，等待信号量被 V 操作增加
Dialogue: 0,0:00:56.86,0:01:01.82,English,,0,0,0,,After the V operation increments after some V operation increments the semaphore
Dialogue: 0,0:00:56.86,0:01:01.82,Chinese,,0,0,0,,在一些 V 操作增加信号量之后
Dialogue: 0,0:01:03.24,0:01:08.92,English,,0,0,0,,The P operation continues by decrementing s and then returning control to the caller
Dialogue: 0,0:01:03.24,0:01:08.92,Chinese,,0,0,0,, 接着 P 操作会递减 s 然后将控制权交给调用者
Dialogue: 0,0:01:10.06,0:01:12.46,English,,0,0,0,,The V operation never blocks
Dialogue: 0,0:01:10.06,0:01:12.46,Chinese,,0,0,0,, V 操作永远不会阻塞
Dialogue: 0,0:01:14.00,0:01:17.66,English,,0,0,0,,It first it increments the semaphore value s
Dialogue: 0,0:01:14.00,0:01:17.66,Chinese,,0,0,0,,首先它将信号量值增加 s
Dialogue: 0,0:01:18.42,0:01:21.18,English,,0,0,0,,And then it looks in the queue of four to see
Dialogue: 0,0:01:18.42,0:01:21.18,Chinese,,0,0,0,,然后它在队列中查找
Dialogue: 0,0:01:21.18,0:01:25.96,English,,0,0,0,,If there's any processes that are blocked waiting for that some afford to be nonzero
Dialogue: 0,0:01:21.18,0:01:25.96,Chinese,,0,0,0,,那些被阻塞的进程，等待其他操作将信号量变成非零
Dialogue: 0,0:01:27.66,0:01:33.52,English,,0,0,0,,If there are then it selects one of those using some unspecified criteria
Dialogue: 0,0:01:27.66,0:01:33.52,Chinese,,0,0,0,,如果有，就从它们中间随意挑选一个
Dialogue: 0,0:01:34.08,0:01:43.96,English,,0,0,0,,And then it restarts that...it restarts that thread that's or that P operation that's waiting on the semaphore
Dialogue: 0,0:01:34.08,0:01:43.96,Chinese,,0,0,0,,然后重启等待 P 操作信号量的那个线程
Dialogue: 0,0:01:47.72,0:01:51.38,English,,0,0,0,,Okay and then this the semantics of the P and V
Dialogue: 0,0:01:47.72,0:01:51.38,Chinese,,0,0,0,,这就是 P 和 V 原语
Dialogue: 0,0:01:51.94,0:01:55.70,English,,0,0,0,,Ensure that semaphore values are always greater than or equal to zero
Dialogue: 0,0:01:51.94,0:01:55.70,Chinese,,0,0,0,,确保信号量值始终大于或等于零
Dialogue: 0,0:01:57.62,0:02:05.10,English,,0,0,0,,Now the first thing we saw how to protect shared variables by using a semaphore called the mutex
Dialogue: 0,0:01:57.62,0:02:05.10,Chinese,,0,0,0,,现在我们先来学习如何通过使用互斥锁的信号量来保护共享变量
Dialogue: 0,0:02:05.72,0:02:14.62,English,,0,0,0,,That guarantees mutually exclusive access to the critical sections that are updating that those variables are structures
Dialogue: 0,0:02:05.72,0:02:14.62,Chinese,,0,0,0,,确保对临界资源的互斥访问
Dialogue: 0,0:02:15.64,0:02:18.84,English,,0,0,0,,And and the way that we do this is very simple
Dialogue: 0,0:02:15.64,0:02:18.84,Chinese,,0,0,0,,我们很简单就能做到
Dialogue: 0,0:02:18.84,0:02:25.58,English,,0,0,0,,We initialize the mutex to one and then surround the critical section with a P and V
Dialogue: 0,0:02:18.84,0:02:25.58,Chinese,,0,0,0,,我们设置互斥锁的初始值为 1 ，然后用 P 和 V 操作包围临界区
Dialogue: 0,0:02:27.74,0:02:30.06,English,,0,0,0,,Now there's other ways that we can
Dialogue: 0,0:02:27.74,0:02:30.06,Chinese,,0,0,0,,还有其他方法可以做到
Dialogue: 0,0:02:30.06,0:02:34.64,English,,0,0,0,,So here's an example where we're using semaphore is to provide mutual exclusion
Dialogue: 0,0:02:30.06,0:02:34.64,Chinese,,0,0,0,,这里例子是一个使用信号量实现互斥的例子
Dialogue: 0,0:02:35.76,0:02:43.32,English,,0,0,0,,But we can also use semaphores to coordinate access to shared data structures in different ways
Dialogue: 0,0:02:35.76,0:02:43.32,Chinese,,0,0,0,,但我们也可以使用信号量以不同方式协调对共享数据结构的访问
Dialogue: 0,0:02:44.16,0:02:49.82,English,,0,0,0,,And so the idea here before we were using the semaphore just to protect the access to a shared variable
Dialogue: 0,0:02:44.16,0:02:49.82,Chinese,,0,0,0,,所以我们在使用信号量之前的想法只是为了保护对共享变量的访问
Dialogue: 0,0:02:50.36,0:02:58.24,English,,0,0,0,,But we can also coordinate access in different ways by keep and in these kind of scenarios
Dialogue: 0,0:02:50.36,0:02:58.24,Chinese,,0,0,0,,但我们也可以通过不同的方式来协调访问，保持和在这种场景中
Dialogue: 0,0:02:58.28,0:03:01.18,English,,0,0,0,,We're using the semaphore to keep track of state to
Dialogue: 0,0:02:58.28,0:03:01.18,Chinese,,0,0,0,,我们正在使用信号量来跟踪状态
Dialogue: 0,0:03:01.98,0:03:07.56,English,,0,0,0,,The count things to keep track of state and to notify other other threads of changes in state
Dialogue: 0,0:03:01.98,0:03:07.56,Chinese,,0,0,0,,通过计算了跟踪状态变更并通知其他线程状态的变更
Dialogue: 0,0:03:07.68,0:03:10.16,English,,0,0,0,,Okay so it's a very different usage model
Dialogue: 0,0:03:07.68,0:03:10.16,Chinese,,0,0,0,,这是一个非常不同的使用模型
Dialogue: 0,0:03:11.02,0:03:17.86,English,,0,0,0,,And two classic examples that we're going to look at are the Producer-Consumer problem and a Readers-Writers problem
Dialogue: 0,0:03:11.02,0:03:17.86,Chinese,,0,0,0,,关于这个有两个经典的例子，「生产者-消费者问题」，「读写问题」
Dialogue: 0,0:03:18.82,0:03:20.44,English,,0,0,0,,So let's look at producer consumer first
Dialogue: 0,0:03:18.82,0:03:20.44,Chinese,,0,0,0,,那么让我们先看「生产者-消费者问题」
Dialogue: 0,0:03:21.62,0:03:24.90,English,,0,0,0,,So the idea in the producer consumer problem is that
Dialogue: 0,0:03:21.62,0:03:24.90,Chinese,,0,0,0,,「生产者-消费者问题」的核心思想是
Dialogue: 0,0:03:25.42,0:03:28.94,English,,0,0,0,,You have a resource in the form of a buffer
Dialogue: 0,0:03:25.42,0:03:28.94,Chinese,,0,0,0,,你有一个缓冲区形式的资源
Dialogue: 0,0:03:29.66,0:03:32.44,English,,0,0,0,,The buffer has a bounded size
Dialogue: 0,0:03:29.66,0:03:32.44,Chinese,,0,0,0,,缓冲区的大小有限
Dialogue: 0,0:03:32.50,0:03:36.60,English,,0,0,0,,So it consists of n slots and each slot can hold an item
Dialogue: 0,0:03:32.50,0:03:36.60,Chinese,,0,0,0,,它由 n 个槽位组成，每个槽位可以容纳一个物品
Dialogue: 0,0:03:39.08,0:03:42.70,English,,0,0,0,,Okay the there's a producer thread which produces items
Dialogue: 0,0:03:39.08,0:03:42.70,Chinese,,0,0,0,,这里有一个生产者线程来生产物品
Dialogue: 0,0:03:44.52,0:03:46.48,English,,0,0,0,,And then inserts them into the buffer
Dialogue: 0,0:03:44.52,0:03:46.48,Chinese,,0,0,0,,然后将它们放入缓冲区
Dialogue: 0,0:03:47.50,0:03:52.82,English,,0,0,0,,And there's a consumer thread that retrieves removes items from the buffer
Dialogue: 0,0:03:47.50,0:03:52.82,Chinese,,0,0,0,,这是一个消费者线程，从缓冲区中拿取物品
Dialogue: 0,0:03:52.90,0:03:57.74,English,,0,0,0,,And then consumes them by acting on them in some way processing on them in some way
Dialogue: 0,0:03:52.90,0:03:57.74,Chinese,,0,0,0,,然后通过以某种方式对它们进行处理
Dialogue: 0,0:03:59.02,0:04:04.12,English,,0,0,0,,So the synchronization variable the synchronization pattern is that
Dialogue: 0,0:03:59.02,0:04:04.12,Chinese,,0,0,0,,所以同步模式就是
Dialogue: 0,0:04:04.84,0:04:07.02,English,,0,0,0,,The producer waits for an empty slot right
Dialogue: 0,0:04:04.84,0:04:07.02,Chinese,,0,0,0,,生产者等待一个空位
Dialogue: 0,0:04:07.02,0:04:12.76,English,,0,0,0,,So if there's,if the buffer is full the producer can't insert an item into the buffer
Dialogue: 0,0:04:07.02,0:04:12.76,Chinese,,0,0,0,,如果缓冲区已满，则生产者无法将物品放入缓冲区
Dialogue: 0,0:04:13.52,0:04:15.08,English,,0,0,0,,So it waits for an empty slot
Dialogue: 0,0:04:13.52,0:04:15.08,Chinese,,0,0,0,,所以它等待一个空位
Dialogue: 0,0:04:16.10,0:04:20.18,English,,0,0,0,,And then when it finds an empty slot when an empty slot becomes available
Dialogue: 0,0:04:16.10,0:04:20.18,Chinese,,0,0,0,,当出现一个空位时
Dialogue: 0,0:04:20.48,0:04:22.56,English,,0,0,0,,It inserts the item into the buffer
Dialogue: 0,0:04:20.48,0:04:22.56,Chinese,,0,0,0,,生产者就能将物品放入缓冲区了
Dialogue: 0,0:04:23.24,0:04:29.66,English,,0,0,0,,And then it notifies the consumer that there's now a new item in the buffer
Dialogue: 0,0:04:23.24,0:04:29.66,Chinese,,0,0,0,,然后通知消费者，现在缓冲区中有一个新物品
Dialogue: 0,0:04:31.20,0:04:37.42,English,,0,0,0,,The consumer of course that has to wait for an item to show up in the buffer right
Dialogue: 0,0:04:31.20,0:04:37.42,Chinese,,0,0,0,,消费者肯定也在等待缓冲区填满物品
Dialogue: 0,0:04:37.64,0:04:41.44,English,,0,0,0,,Otherwise I mean you can't remove an item from an empty buffer
Dialogue: 0,0:04:37.64,0:04:41.44,Chinese,,0,0,0,,否则......我的意思是你不能从一个空的缓冲区中获取物品
Dialogue: 0,0:04:41.80,0:04:46.36,English,,0,0,0,,So it has to wait for an item to be available in the buffer
Dialogue: 0,0:04:41.80,0:04:46.36,Chinese,,0,0,0,,所以它必须等待缓冲区中的可用物品
Dialogue: 0,0:04:46.84,0:04:51.24,English,,0,0,0,,And when an item becomes available it removes it from the buffer
Dialogue: 0,0:04:46.84,0:04:51.24,Chinese,,0,0,0,,当一个物品可用时，它将其从缓冲区中删除
Dialogue: 0,0:04:51.64,0:04:55.54,English,,0,0,0,,And then notifies the producer that there's now an available slot
Dialogue: 0,0:04:51.64,0:04:55.54,Chinese,,0,0,0,,然后通知生产者现在有一个空位了
Dialogue: 0,0:04:58.80,0:05:06.18,English,,0,0,0,,Okay so this actually this very simple pattern is actually really useful and shows up in a lot of applications
Dialogue: 0,0:04:58.80,0:05:06.18,Chinese,,0,0,0,,这是一个简单且实用的模型在很多应用程序中都有使用
Dialogue: 0,0:05:06.70,0:05:08.64,English,,0,0,0,,So for example a multimedia application
Dialogue: 0,0:05:06.70,0:05:08.64,Chinese,,0,0,0,,例如，多媒体应用程序
Dialogue: 0,0:05:09.14,0:05:17.82,English,,0,0,0,,In a multimedia application the producer might be producing say MPEG frames in a video
Dialogue: 0,0:05:09.14,0:05:17.82,Chinese,,0,0,0,,在多媒体应用中，生产者可能会提供视频的 MPEG 帧
Dialogue: 0,0:05:18.22,0:05:24.28,English,,0,0,0,,And a consumer would be consuming those MPEG frames and then painting the screen appropriately
Dialogue: 0,0:05:18.22,0:05:24.28,Chinese,,0,0,0,,并且消费者将消费那些 MPEG 帧，然后绘制在屏幕上
Dialogue: 0,0:05:24.90,0:05:29.08,English,,0,0,0,,Another important application is in graphical user interfaces
Dialogue: 0,0:05:24.90,0:05:29.08,Chinese,,0,0,0,,另一个重要的应用是图形用户界面
Dialogue: 0,0:05:29.92,0:05:34.52,English,,0,0,0,,So graphical user interfaces are typically implemented using this producer-consumer model
Dialogue: 0,0:05:29.92,0:05:34.52,Chinese,,0,0,0,,图形用户界面通常使用「生产者-消费者」模型来实现
Dialogue: 0,0:05:35.26,0:05:44.86,English,,0,0,0,,Where the mouse clicks,motions and the in the of the mouse,keyboard clicks
Dialogue: 0,0:05:35.26,0:05:44.86,Chinese,,0,0,0,,比如点击鼠标，敲击键盘
Dialogue: 0,0:05:45.30,0:05:46.88,English,,0,0,0,,Those are all recorded as events
Dialogue: 0,0:05:45.30,0:05:46.88,Chinese,,0,0,0,,这些都被记录为事件
Dialogue: 0,0:05:47.26,0:05:52.74,English,,0,0,0,,They're detected by the system recorded as events and placed into a some kind of a queue
Dialogue: 0,0:05:47.26,0:05:52.74,Chinese,,0,0,0,,系统将它们记录为事件并将其置于事件队列中
Dialogue: 0,0:05:53.70,0:05:58.94,English,,0,0,0,,And then...there is other parts of the system retrieve items from the queue and react to them
Dialogue: 0,0:05:53.70,0:05:58.94,Chinese,,0,0,0,,然后 ...... 系统的其他部分会从队列中读取事件并对它们作出反应
Dialogue: 0,0:05:58.96,0:06:07.26,English,,0,0,0,,So for example the graphic system will retrieve events like mouse events and mouse movements mouse clicks
Dialogue: 0,0:05:58.96,0:06:07.26,Chinese,,0,0,0,,因此，例如图形系统将会处理鼠标移动，鼠标点击之类的事件
Dialogue: 0,0:06:07.72,0:06:09.70,English,,0,0,0,,And it will paint the screen accordingly right
Dialogue: 0,0:06:07.72,0:06:09.70,Chinese,,0,0,0,,并将它们绘制在屏幕上面
Dialogue: 0,0:06:09.72,0:06:17.22,English,,0,0,0,,So that it will reflect it will repaint the screen ,so that to show you that the cursor is moving
Dialogue: 0,0:06:09.72,0:06:17.22,Chinese,,0,0,0,,这些事件绘制在屏幕上就呈现出光标移动的效果
Dialogue: 0,0:06:17.80,0:06:21.20,English,,0,0,0,,Right or if you change the focus it will repaint it
Dialogue: 0,0:06:17.80,0:06:21.20,Chinese,,0,0,0,,如果你更改焦点，又将重新绘制
Dialogue: 0,0:06:21.90,0:06:25.68,English,,0,0,0,,So it's a very common model
Dialogue: 0,0:06:21.90,0:06:25.68,Chinese,,0,0,0,,所以这是一个常用模型
Dialogue: 0,0:06:25.68,0:06:31.70,English,,0,0,0,,And as we'll see later multi-threaded we can build multi-threaded concurrent servers using this model
Dialogue: 0,0:06:25.68,0:06:31.70,Chinese,,0,0,0,,稍后将看到，我们可以使用这种模型构建多线程并发服务器
Dialogue: 0,0:06:34.48,0:06:38.56,English,,0,0,0,,So let's see how we would implement producer-consumer on an n-element buffer
Dialogue: 0,0:06:34.48,0:06:38.56,Chinese,,0,0,0,,那么让先我们看看 n 元素缓冲区上实现「生产者-消费者」模型会怎样
Dialogue: 0,0:06:39.52,0:06:47.16,English,,0,0,0,,So this the implementation requires a mutex to guarantee mutually exclusive access to the resource of course
Dialogue: 0,0:06:39.52,0:06:47.16,Chinese,,0,0,0,,因此，实现需要一个互斥锁来保证对资源的互斥访问
Dialogue: 0,0:06:47.84,0:06:52.06,English,,0,0,0,,And then it requires then two other semaphores counting semaphores
Dialogue: 0,0:06:47.84,0:06:52.06,Chinese,,0,0,0,,然后它需要另外两个信号量来计数
Dialogue: 0,0:06:53.74,0:06:58.48,English,,0,0,0,,Slots is a semaphore that counts the available slots in the buffer
Dialogue: 0,0:06:53.74,0:06:58.48,Chinese,,0,0,0,, Slots 是一个信号量，用于计算缓冲区中的空位数量
Dialogue: 0,0:06:59.10,0:07:02.61,English,,0,0,0,,And items is counts the available items okay
Dialogue: 0,0:06:59.10,0:07:02.61,Chinese,,0,0,0,,items 是一个用了计算可用物品数量的信号量
Dialogue: 0,0:07:03.38,0:07:07.90,English,,0,0,0,,And we've can implement it with this package called sbuf
Dialogue: 0,0:07:03.38,0:07:07.90,Chinese,,0,0,0,,我们可以使用名为 sbuf 的这个包实现它
Dialogue: 0,0:07:10.98,0:07:17.92,English,,0,0,0,,So sbuf the sbuf package defines a type called sbuf_t
Dialogue: 0,0:07:10.98,0:07:17.92,Chinese,,0,0,0,,所以 sbuf 包定义了一个名为 sbuf_t 的类型
Dialogue: 0,0:07:17.92,0:07:24.12,English,,0,0,0,,That packages up all of the data structures that are needed to implement the shared buffer
Dialogue: 0,0:07:17.92,0:07:24.12,Chinese,,0,0,0,,这个包包含了实现共享缓冲区所需的所有数据结构
Dialogue: 0,0:07:24.80,0:07:30.12,English,,0,0,0,,So there's a pointer to the buffer which we were going to implement as an array and
Dialogue: 0,0:07:24.80,0:07:30.12,Chinese,,0,0,0,,这里有一个指向缓冲区的指针，我们可以用一个数组来实现
Dialogue: 0,0:07:30.62,0:07:34.52,English,,0,0,0,,And we'll implement a circular buffer on this array
Dialogue: 0,0:07:30.62,0:07:34.52,Chinese,,0,0,0,,我们将在这个数组上实现一个循环缓冲区
Dialogue: 0,0:07:36.26,0:07:39.59,English,,0,0,0,,The maximum number of slots n,so the size of the buffer
Dialogue: 0,0:07:36.26,0:07:39.59,Chinese,,0,0,0,,最大空位数是 n ，所以缓冲区的大小也是 n
Dialogue: 0,0:07:40.14,0:07:47.50,English,,0,0,0,,And then two pointers front and rear to keep track of the front and rear of the of the buffer
Dialogue: 0,0:07:40.14,0:07:47.50,Chinese,,0,0,0,,然后是 front，rear 两个指针来记录缓冲区前后的位置
Dialogue: 0,0:07:47.50,0:07:50.57,English,,0,0,0,,So to keep track of the first and last items in the buffer
Dialogue: 0,0:07:47.50,0:07:50.57,Chinese,,0,0,0,,就是跟踪缓冲区中的第一个和最后一个元素
Dialogue: 0,0:07:51.26,0:07:55.56,English,,0,0,0,,And then the three semaphores the mutex and in the two counting semaphores
Dialogue: 0,0:07:51.26,0:07:55.56,Chinese,,0,0,0,,然后是三个信号量，一个互斥量和两个计数信号量
Dialogue: 0,0:07:56.48,0:07:59.84,English,,0,0,0,,And then the package consists of these four public functions
Dialogue: 0,0:07:56.48,0:07:59.84,Chinese,,0,0,0,,这个包还包含 4 个公有方法
Dialogue: 0,0:08:00.36,0:08:11.96,English,,0,0,0,,sbuf_init which creates the is called once to create the buffer and initialize everything allocate the space and initialize things
Dialogue: 0,0:08:00.36,0:08:11.96,Chinese,,0,0,0,,sbuf_init 在初始化时调用一次，创建缓冲区，分配空间
Dialogue: 0,0:08:11.96,0:08:14.44,English,,0,0,0,,And the (sbuf_)deinit which frees up the space
Dialogue: 0,0:08:11.96,0:08:14.44,Chinese,,0,0,0,,sbuf_deinit 用来释放空间
Dialogue: 0,0:08:15.38,0:08:20.38,English,,0,0,0,,And then a function to insert an item into the queue
Dialogue: 0,0:08:15.38,0:08:20.38,Chinese,,0,0,0,,然后是插入函数（sbuf_insert）将元素放入队列
Dialogue: 0,0:08:20.64,0:08:24.14,English,,0,0,0,,And a function to remove an item from a queue and return that item
Dialogue: 0,0:08:20.64,0:08:24.14,Chinese,,0,0,0,,然后是移除函数（sbuf_remove）将元素从队列中移除
Dialogue: 0,0:08:24.88,0:08:26.42,English,,0,0,0,,So in this case items are just int
Dialogue: 0,0:08:24.88,0:08:26.42,Chinese,,0,0,0,,所以在这种情况下，元素是整数
Dialogue: 0,0:08:31.30,0:08:40.06,English,,0,0,0,,So to create the...to initialize the this buffer with n slots
Dialogue: 0,0:08:31.30,0:08:40.06,Chinese,,0,0,0,,创建一个大小为 n 的缓冲区
Dialogue: 0,0:08:40.06,0:08:44.58,English,,0,0,0,,We first allocate the space for the buffer and n ints
Dialogue: 0,0:08:40.06,0:08:44.58,Chinese,,0,0,0,,我们首先要分配 n 个 int 类型的空间作为缓冲区
Dialogue: 0,0:08:45.38,0:08:50.80,English,,0,0,0,,We set the size to be the value n that was passed in
Dialogue: 0,0:08:45.38,0:08:50.80,Chinese,,0,0,0,,我们通过参数 n 来设置缓冲区的大小
Dialogue: 0,0:08:52.72,0:08:58.02,English,,0,0,0,,We indicate the empty buffer by setting front-and-rear to be zero
Dialogue: 0,0:08:52.72,0:08:58.02,Chinese,,0,0,0,,我们设置 front 和 rear 参数为 0 来表示缓冲区为空
Dialogue: 0,0:08:58.78,0:09:03.20,English,,0,0,0,,Okay and so whenever front and rear are zero that's we have an empty buffer
Dialogue: 0,0:08:58.78,0:09:03.20,Chinese,,0,0,0,,只要 front 和 rear 是 0，我们都有一个空的缓冲区
Dialogue: 0,0:09:04.34,0:09:06.70,English,,0,0,0,,And then we initialize the three semaphore
Dialogue: 0,0:09:04.34,0:09:06.70,Chinese,,0,0,0,,然后我们初始化三个信号量
Dialogue: 0,0:09:06.70,0:09:11.30,English,,0,0,0,,So the mutex like all mutex is initialized to 1
Dialogue: 0,0:09:06.70,0:09:11.30,Chinese,,0,0,0,,所有互斥信号量初始值为 1
Dialogue: 0,0:09:13.32,0:09:19.48,English,,0,0,0,,The slots semaphore which keeps track of the number of available slots is initialized to n
Dialogue: 0,0:09:13.32,0:09:19.48,Chinese,,0,0,0,,slots 信号量是用来记录可用的空位的，初始值是 n
Dialogue: 0,0:09:20.38,0:09:23.20,English,,0,0,0,,And the item semaphore is initialized to zero
Dialogue: 0,0:09:20.38,0:09:23.20,Chinese,,0,0,0,,items 信号量初始值是 0
Dialogue: 0,0:09:25.18,0:09:31.20,English,,0,0,0,,Okay and deinit is really simple it just frees up the heap space that we allocated
Dialogue: 0,0:09:25.18,0:09:31.20,Chinese,,0,0,0,,sub_deinit 方法非常简单，只是释放我们分配的空间
Dialogue: 0,0:09:33.10,0:09:36.74,English,,0,0,0,,Okay so now let's look at how we insert an item into the buffer
Dialogue: 0,0:09:33.10,0:09:36.74,Chinese,,0,0,0,,现在让我们看看如何将元素放入缓冲区
Dialogue: 0,0:09:36.94,0:09:43.18,English,,0,0,0,,So we call...we want to insert this integer item into this buffer pointed at by sp
Dialogue: 0,0:09:36.94,0:09:43.18,Chinese,,0,0,0,,所以我们调用 ... 我们想要将这个整数项放入 sp 指向的缓冲区
Dialogue: 0,0:09:44.74,0:09:49.70,English,,0,0,0,,So first the thread waits for an available slot
Dialogue: 0,0:09:44.74,0:09:49.70,Chinese,,0,0,0,,首先需要一个空位
Dialogue: 0,0:09:50.12,0:09:53.56,English,,0,0,0,,Okay by doing a p on the slots semaphore before alright
Dialogue: 0,0:09:50.12,0:09:53.56,Chinese,,0,0,0,,先在 slots 信号量是进行 P 操作
Dialogue: 0,0:09:53.56,0:09:59.44,English,,0,0,0,,So P will block until the slots is greater than or equal to one
Dialogue: 0,0:09:53.56,0:09:59.44,Chinese,,0,0,0,,如果 slots 小于 1，P 操作就会阻塞
Dialogue: 0,0:10:01.14,0:10:02.82,English,,0,0,0,,Okay once there's an available slot
Dialogue: 0,0:10:01.14,0:10:02.82,Chinese,,0,0,0,,一旦有了空位
Dialogue: 0,0:10:03.76,0:10:13.76,English,,0,0,0,,Then it if then it's going to update the rear of the buffer
Dialogue: 0,0:10:03.76,0:10:13.76,Chinese,,0,0,0,,然后，更新缓存区的尾部参数 rear
Dialogue: 0,0:10:14.26,0:10:16.74,English,,0,0,0,,Okay so we're going to put this item on to the rear of the buffer
Dialogue: 0,0:10:14.26,0:10:16.74,Chinese,,0,0,0,,所以我们把这个元素放到了缓存区的 rear 位置上了
Dialogue: 0,0:10:17.08,0:10:21.56,English,,0,0,0,,And so it needs to protect that access to that shared buffer with the mutex
Dialogue: 0,0:10:17.08,0:10:21.56,Chinese,,0,0,0,,因此，它需要使用互斥锁保护对该共享缓冲区的访问
Dialogue: 0,0:10:22.76,0:10:29.92,English,,0,0,0,,Then it does the by doing a p on the mutex updating updating our rear pointer
Dialogue: 0,0:10:22.76,0:10:29.92,Chinese,,0,0,0,,需要通过 P 操作来获取互斥锁，从而更新 rear 指针
Dialogue: 0,0:10:30.20,0:10:37.18,English,,0,0,0,,Okay so we pre increment it so we increment the rear pointer and then take the mod of that n
Dialogue: 0,0:10:30.20,0:10:37.18,Chinese,,0,0,0,,所以我们预先增加它，所以我们增加后指针，对 n 进行取模
Dialogue: 0,0:10:37.80,0:10:43.86,English,,0,0,0,,To compute the index that we're going to insert the item
Dialogue: 0,0:10:37.80,0:10:43.86,Chinese,,0,0,0,,来计算出我们放入元素的位置
Dialogue: 0,0:10:44.80,0:10:47.74,English,,0,0,0,,Okay then we do a V on the mutex
Dialogue: 0,0:10:44.80,0:10:47.74,Chinese,,0,0,0,,然后我们使用 V 操作释放互斥锁
Dialogue: 0,0:10:48.20,0:10:54.54,English,,0,0,0,,Okay so that other threads can update that shared data structure
Dialogue: 0,0:10:48.20,0:10:54.54,Chinese,,0,0,0,,以便其他线程可以更新该共享数据结构
Dialogue: 0,0:10:55.52,0:11:00.56,English,,0,0,0,,And then we do a V on the number of items to notify any consumers
Dialogue: 0,0:10:55.52,0:11:00.56,Chinese,,0,0,0,,然后我们对 items 进行 V 操作来通知其他消费者
Dialogue: 0,0:11:00.56,0:11:02.86,English,,0,0,0,,That there's now an item in the buffer
Dialogue: 0,0:11:00.56,0:11:02.86,Chinese,,0,0,0,,现在缓冲区中有一个元素了
Dialogue: 0,0:11:04.68,0:11:08.36,English,,0,0,0,,So this V is kind of interesting you think it was kind of like a signal right
Dialogue: 0,0:11:04.68,0:11:08.36,Chinese,,0,0,0,,所以 V 操作很有意思，它有点像信号
Dialogue: 0,0:11:08.36,0:11:14.86,English,,0,0,0,,So you're sort of signaling consumers that now some event has occurred in the system
Dialogue: 0,0:11:08.36,0:11:14.86,Chinese,,0,0,0,,你可以认为通过信号告诉消费则系统中发生了某些事件
Dialogue: 0,0:11:18.08,0:11:20.92,English,,0,0,0,,Now to remove an item it's symmetric
Dialogue: 0,0:11:18.08,0:11:20.92,Chinese,,0,0,0,,删除元素则是一个对称操作
Dialogue: 0,0:11:21.04,0:11:26.48,English,,0,0,0,,But instead of operating on the slots that before it operates on the items semaphore
Dialogue: 0,0:11:21.04,0:11:26.48,Chinese,,0,0,0,,这里先操作 items 信号量代替了之前的操作 slots 信号量
Dialogue: 0,0:11:27.30,0:11:33.88,English,,0,0,0,,So to remove an item a consumer first does a P on the items semaphore
Dialogue: 0,0:11:27.30,0:11:33.88,Chinese,,0,0,0,,因此，要删除元素，消费者首先要对 items 信号量进行 P 操作
Dialogue: 0,0:11:33.94,0:11:38.78,English,,0,0,0,,So this now is waiting for an available item it's waiting for the semaphore to be greater than equal to one
Dialogue: 0,0:11:33.94,0:11:38.78,Chinese,,0,0,0,,所以它会等待一个可用的元素，等待信号量大于等于 1
Dialogue: 0,0:11:39.96,0:11:43.80,English,,0,0,0,,When that happens then the P returns
Dialogue: 0,0:11:39.96,0:11:43.80,Chinese,,0,0,0,,当发生这种情况时， P 返回
Dialogue: 0,0:11:44.44,0:11:49.00,English,,0,0,0,,And then we do the update protected by a mutex
Dialogue: 0,0:11:44.44,0:11:49.00,Chinese,,0,0,0,,然后我们要获取互斥锁保护
Dialogue: 0,0:11:49.62,0:11:54.40,English,,0,0,0,,By pre-incrementing front taking the mod n
Dialogue: 0,0:11:49.62,0:11:54.40,Chinese,,0,0,0,,然后增加 front 的值然后对 n 取模
Dialogue: 0,0:11:54.86,0:12:03.70,English,,0,0,0,,And then reading that value and returning it and placing it into this local local variable item
Dialogue: 0,0:11:54.86,0:12:03.70,Chinese,,0,0,0,,然后读取并返回，放到本地变量 local 当中
Dialogue: 0,0:12:04.50,0:12:06.22,English,,0,0,0,,Then we release the mutex
Dialogue: 0,0:12:04.50,0:12:06.22,Chinese,,0,0,0,,然后我们释放互斥锁
Dialogue: 0,0:12:07.82,0:12:10.04,English,,0,0,0,,And then we do a V on the number of slots which
Dialogue: 0,0:12:07.82,0:12:10.04,Chinese,,0,0,0,,然后我们对 slots 进行 V 操作
Dialogue: 0,0:12:10.48,0:12:15.50,English,,0,0,0,,Which is an announcement to any producers that there's now a new available slot
Dialogue: 0,0:12:10.48,0:12:15.50,Chinese,,0,0,0,,告诉生产者现在有一个空位了
Dialogue: 0,0:12:19.54,0:12:20.70,English,,0,0,0,,So any questions about that
Dialogue: 0,0:12:19.54,0:12:20.70,Chinese,,0,0,0,,对此大家有什么问题吗
Dialogue: 0,0:12:24.72,0:12:26.32,English,,0,0,0,,So it's a little more subtle
Dialogue: 0,0:12:24.72,0:12:26.32,Chinese,,0,0,0,,它有点微妙
Dialogue: 0,0:12:26.56,0:12:31.28,English,,0,0,0,,This looks really simple but like all concurrency problems it's actually very subtle
Dialogue: 0,0:12:26.56,0:12:31.28,Chinese,,0,0,0,,这看起来非常简单，但像所有并发问题一样，它实际上非常微妙
Dialogue: 0,0:12:33.26,0:12:39.64,English,,0,0,0,,So you can have potential,you can have many producers and many many consumers all operating on the same
Dialogue: 0,0:12:33.26,0:12:39.64,Chinese,,0,0,0,,你可能会想如果让多个生产者和多个消费者同时进行
Dialogue: 0,0:12:40.36,0:12:42.26,English,,0,0,0,,You know the same shared buffer
Dialogue: 0,0:12:40.36,0:12:42.26,Chinese,,0,0,0,,同时操作相同的缓冲区
Dialogue: 0,0:12:44.32,0:12:47.70,English,,0,0,0,,So this...so what would happen
Dialogue: 0,0:12:44.32,0:12:47.70,Chinese,,0,0,0,,所以这 ...... 所以会发生什么
Dialogue: 0,0:12:48.84,0:12:55.42,English,,0,0,0,,If we had two consumers did a P on this item semaphore at the exact same time
Dialogue: 0,0:12:48.84,0:12:55.42,Chinese,,0,0,0,,如果我们有两个消费者同时对 items 信号量做 P 操作
Dialogue: 0,0:12:55.50,0:12:59.14,English,,0,0,0,,There we're running on two cores and and we have two threads
Dialogue: 0,0:12:55.50,0:12:59.14,Chinese,,0,0,0,,比如我们有两个线程运行在两个核上
Dialogue: 0,0:12:59.14,0:13:07.84,English,,0,0,0,,And they each execute that P at the same time on that that same item semaphore
Dialogue: 0,0:12:59.14,0:13:07.84,Chinese,,0,0,0,,它们同时对 items 信号量进行 P 操作
Dialogue: 0,0:13:08.72,0:13:14.30,English,,0,0,0,,Okay so even though they access it at the same time the kernel will make sure that one of them will execute first
Dialogue: 0,0:13:08.72,0:13:14.30,Chinese,,0,0,0,,这样即使他们同时访问它，内核也会确保其中一个先执行
Dialogue: 0,0:13:14.58,0:13:18.40,English,,0,0,0,,Okay so the kernel will serialize those P operations
Dialogue: 0,0:13:14.58,0:13:18.40,Chinese,,0,0,0,,所以内核将把这些 P 操作序列化
Dialogue: 0,0:13:20.40,0:13:22.94,English,,0,0,0,,And it there's no telling which one gets it first
Dialogue: 0,0:13:20.40,0:13:22.94,Chinese,,0,0,0,,并且没有人知道哪一个先得到
Dialogue: 0,0:13:22.94,0:13:31.48,English,,0,0,0,,But whoever runs there P first will decrement this item semaphore
Dialogue: 0,0:13:22.94,0:13:31.48,Chinese,,0,0,0,,但无论谁先运行 P 操作都会减少 items 信号量的值
Dialogue: 0,0:13:33.44,0:13:37.72,English,,0,0,0,,And then when the next when the next thread executes its P
Dialogue: 0,0:13:33.44,0:13:37.72,Chinese,,0,0,0,,然后下一个线程执行 P 操作时
Dialogue: 0,0:13:38.72,0:13:40.78,English,,0,0,0,,Items will either be zero or nonzero
Dialogue: 0,0:13:38.72,0:13:40.78,Chinese,,0,0,0,, items 信号量要么是 0 要么是非
Dialogue: 0,0:13:41.34,0:13:45.28,English,,0,0,0,,Okay as a result so somebody wins there's kind of a ton of like a controlled race
Dialogue: 0,0:13:41.34,0:13:45.28,Chinese,,0,0,0,,好的结果是有人赢了，有点像控制了赛点
Dialogue: 0,0:13:45.72,0:13:48.04,English,,0,0,0,,And somebody wins the race always wins the race
Dialogue: 0,0:13:45.72,0:13:48.04,Chinese,,0,0,0,,有人赢得了比赛，总是赢得了比赛
Dialogue: 0,0:13:48.04,0:13:54.94,English,,0,0,0,,Because the kernel is serializing these P operations and it's executing them atomically okay
Dialogue: 0,0:13:48.04,0:13:54.94,Chinese,,0,0,0,,因为内核正在将这些P操作序列化，而且它是以原子方式执行这些操作
Dialogue: 0,0:13:58.46,0:14:06.68,English,,0,0,0,,Okay now the there's a generalization of the mutual exclusion problem called the reader writer problem
Dialogue: 0,0:13:58.46,0:14:06.68,Chinese,,0,0,0,,还有一类互斥性问题，叫做「读写问题」
Dialogue: 0,0:14:07.30,0:14:10.22,English,,0,0,0,,So with the mutual exclusion problem
Dialogue: 0,0:14:07.30,0:14:10.22,Chinese,,0,0,0,,因此存在互斥问题
Dialogue: 0,0:14:10.86,0:14:19.50,English,,0,0,0,,We were guaranteeing each thread mutually exclusive access to its critical section
Dialogue: 0,0:14:10.86,0:14:19.50,Chinese,,0,0,0,,我们保证每个线程要互斥地访问临界值
Dialogue: 0,0:14:19.50,0:14:23.82,English,,0,0,0,,That's updating a particular resource or accessing a particular resource
Dialogue: 0,0:14:19.50,0:14:23.82,Chinese,,0,0,0,,互斥读取和更新特定资源
Dialogue: 0,0:14:23.82,0:14:27.64,English,,0,0,0,,And we did this the exact same way whether that access was a read or write
Dialogue: 0,0:14:23.82,0:14:27.64,Chinese,,0,0,0,,无论访问是读还是写，我们都要进行同样的操作
Dialogue: 0,0:14:29.34,0:14:31.94,English,,0,0,0,,Okay but that's overly conservative in this case
Dialogue: 0,0:14:29.34,0:14:31.94,Chinese,,0,0,0,,但在这种情况下，还是过于保守
Dialogue: 0,0:14:33.72,0:14:39.48,English,,0,0,0,,Because we could if all we were doing if we had multiple threads that were just reading the resource
Dialogue: 0,0:14:33.72,0:14:39.48,Chinese,,0,0,0,,如果我们准备好了一切，如果我们有多个线程，只是读取资源
Dialogue: 0,0:14:40.30,0:14:44.42,English,,0,0,0,,There would be no reason to do P(s) and V(s) on that resource or if we're not changing
Dialogue: 0,0:14:40.30,0:14:44.42,Chinese,,0,0,0,,没有理由对该资源进行 P(s) 和 V(s) 处理
Dialogue: 0,0:14:45.50,0:14:50.24,English,,0,0,0,,If we're not changing the resource for just reading it and there's nobody else writing it
Dialogue: 0,0:14:45.50,0:14:50.24,Chinese,,0,0,0,,如果我们只读取而不改其内容，也没有其他人改写内容
Dialogue: 0,0:14:51.12,0:14:53.76,English,,0,0,0,,Then there's no need to protect right so it
Dialogue: 0,0:14:51.12,0:14:53.76,Chinese,,0,0,0,,就没有必要保护了
Dialogue: 0,0:14:54.42,0:15:03.04,English,,0,0,0,,For readers we can have as many readers as we want all at the same time reading the resource the variable or set of variables
Dialogue: 0,0:14:54.42,0:15:03.04,Chinese,,0,0,0,,对于读者来说，我们可以拥有很多读者同时读取资源或变量
Dialogue: 0,0:15:04.74,0:15:07.20,English,,0,0,0,,And there's no need for any kind of synchronization at all
Dialogue: 0,0:15:04.74,0:15:07.20,Chinese,,0,0,0,,并且根本不需要任何类型的同步
Dialogue: 0,0:15:08.08,0:15:14.40,English,,0,0,0,,Okay so the producer consumer is sort of a generalization of that mutual exclusion problem
Dialogue: 0,0:15:08.08,0:15:14.40,Chinese,,0,0,0,,「生产者-消费者」是类互斥性问题的代表
Dialogue: 0,0:15:14.70,0:15:17.84,English,,0,0,0,,Which enforces mutual exclusion only when it's absolutely necessary
Dialogue: 0,0:15:14.70,0:15:17.84,Chinese,,0,0,0,,这类问题只有在绝对必要的情况下，才会相互排斥
Dialogue: 0,0:15:18.46,0:15:23.66,English,,0,0,0,,Okay so there can be is there can be as many readers reading the resource
Dialogue: 0,0:15:18.46,0:15:23.66,Chinese,,0,0,0,,还有可能有很多读者阅读资源
Dialogue: 0,0:15:23.68,0:15:28.74,English,,0,0,0,,But when a writer wants to write then it has to have mutual exclusive access to the resource
Dialogue: 0,0:15:23.68,0:15:28.74,Chinese,,0,0,0,,但是写者要进行写操作时，它必须具有对资源的互斥访问权
Dialogue: 0,0:15:34.62,0:15:38.18,English,,0,0,0,,Okay so this is a kind of thing...this is also a very useful pattern
Dialogue: 0,0:15:34.62,0:15:38.18,Chinese,,0,0,0,, 这也是一种非常有用的模式
Dialogue: 0,0:15:38.78,0:15:44.54,English,,0,0,0,,You have in an online airline reservation system you have multiple clients accessing a shared database
Dialogue: 0,0:15:38.78,0:15:44.54,Chinese,,0,0,0,,在在线航空预订系统中允许有多个客户端访问共享数据库
Dialogue: 0,0:15:45.60,0:15:49.42,English,,0,0,0,,Okay so as long as those clients are reading the database you can have
Dialogue: 0,0:15:45.60,0:15:49.42,Chinese,,0,0,0,,只要这些客户端正在读取数据库
Dialogue: 0,0:15:50.00,0:15:51.72,English,,0,0,0,,They can all be reading at the same time
Dialogue: 0,0:15:50.00,0:15:51.72,Chinese,,0,0,0,,他们能同时读取数据
Dialogue: 0,0:15:51.72,0:15:54.90,English,,0,0,0,,But as soon as somebody wants to make a reservation and update the database
Dialogue: 0,0:15:51.72,0:15:54.90,Chinese,,0,0,0,,但只要有人想要预订并更新数据库
Dialogue: 0,0:15:55.52,0:15:59.16,English,,0,0,0,,Then that update has to happen a mutually exclusive way
Dialogue: 0,0:15:55.52,0:15:59.16,Chinese,,0,0,0,,该更新必须以互斥的方式进行
Dialogue: 0,0:16:00.90,0:16:05.40,English,,0,0,0,,You know if you had also if you had like any kind of shared data structure like a cache
Dialogue: 0,0:16:00.90,0:16:05.40,Chinese,,0,0,0,,或许你们了解缓存这种共享数据的方式
Dialogue: 0,0:16:06.54,0:16:11.14,English,,0,0,0,,In a concurrent proxy like that you're going to be writing soon
Dialogue: 0,0:16:06.54,0:16:11.14,Chinese,,0,0,0,,在像你那样的并发代理中，你很快就要写了
Dialogue: 0,0:16:11.66,0:16:13.72,English,,0,0,0,,Or if you haven't already started
Dialogue: 0,0:16:11.66,0:16:13.72,Chinese,,0,0,0,,或者如果你还没有开始
Dialogue: 0,0:16:15.04,0:16:17.52,English,,0,0,0,,That cache is being shared by multiple threads
Dialogue: 0,0:16:15.04,0:16:17.52,Chinese,,0,0,0,,缓存由多个线程共享
Dialogue: 0,0:16:18.24,0:16:20.84,English,,0,0,0,,And multiple threads may be reading that cache
Dialogue: 0,0:16:18.24,0:16:20.84,Chinese,,0,0,0,,并且多个线程可能正在读取该缓存
Dialogue: 0,0:16:21.38,0:16:26.08,English,,0,0,0,,But when some...when you get a new page and you want to cache it
Dialogue: 0,0:16:21.38,0:16:26.08,Chinese,,0,0,0,,但是当某些 ... 当你得到一个新页面并且你想要缓存它时
Dialogue: 0,0:16:26.86,0:16:32.14,English,,0,0,0,,Then that constitutes a write and that write needs to happen in our mutually exclusive way
Dialogue: 0,0:16:26.86,0:16:32.14,Chinese,,0,0,0,,而这种写操作需要以我们相互排斥的方式进行
Dialogue: 0,0:16:33.72,0:16:37.12,English,,0,0,0,,Now the initial research the researchers that
Dialogue: 0,0:16:33.72,0:16:37.12,Chinese,,0,0,0,,现在研究人员最初的研究表明
Dialogue: 0,0:16:40.12,0:16:42.60,English,,0,0,0,,That pose this readers writers problems
Dialogue: 0,0:16:40.12,0:16:42.60,Chinese,,0,0,0,,构成「读写问题」......
Dialogue: 0,0:16:43.88,0:16:48.78,English,,0,0,0,,In define sort of several classes of reader writer problems
Dialogue: 0,0:16:43.88,0:16:48.78,Chinese,,0,0,0,,在几类「读写问题」当中
Dialogue: 0,0:16:49.30,0:16:56.74,English,,0,0,0,,The first reader writer, readers writers problems is an implementation that favors readers right
Dialogue: 0,0:16:49.30,0:16:56.74,Chinese,,0,0,0,,第一类「读写问题」是一种有利于「读操作」的实施
Dialogue: 0,0:16:57.72,0:17:01.10,English,,0,0,0,,So the idea is that no reader should be kept waiting
Dialogue: 0,0:16:57.72,0:17:01.10,Chinese,,0,0,0,,核心思想是不应该让「读操作」来等待
Dialogue: 0,0:17:02.98,0:17:13.42,English,,0,0,0,,Unless an a writer already has a P as has sort of acquired the lock on that or the mutex on that resource
Dialogue: 0,0:17:02.98,0:17:13.42,Chinese,,0,0,0,,除非「写操作」已经获得了对资源操作的互斥锁
Dialogue: 0,0:17:14.70,0:17:16.46,English,,0,0,0,,So it in this case
Dialogue: 0,0:17:14.70,0:17:16.46,Chinese,,0,0,0,,所以在这种情况下
Dialogue: 0,0:17:17.24,0:17:21.76,English,,0,0,0,,You know say there's a writer waiting to get to acquire the mutex
Dialogue: 0,0:17:17.24,0:17:21.76,Chinese,,0,0,0,,加入有一个「写操作」在等着获得互斥锁
Dialogue: 0,0:17:22.06,0:17:23.70,English,,0,0,0,,And another reader comes in
Dialogue: 0,0:17:22.06,0:17:23.70,Chinese,,0,0,0,,另一个「读操作」进来了
Dialogue: 0,0:17:24.34,0:17:27.54,English,,0,0,0,,Then in this implementation that reader would give priority over the writer
Dialogue: 0,0:17:24.34,0:17:27.54,Chinese,,0,0,0,,在本实施例中，「读操作」将优先于「写操作」
Dialogue: 0,0:17:28.30,0:17:34.02,English,,0,0,0,,And it would be able to read the to add to do its read
Dialogue: 0,0:17:28.30,0:17:34.02,Chinese,,0,0,0,,所以「读操作」可以进行
Dialogue: 0,0:17:34.38,0:17:35.66,English,,0,0,0,,And the writer would have to wait
Dialogue: 0,0:17:34.38,0:17:35.66,Chinese,,0,0,0,,但是「写操作」还需等待
Dialogue: 0,0:17:36.68,0:17:43.05,English,,0,0,0,,And so of court now if multiple readers keep coming in then this could starve out the writer right that
Dialogue: 0,0:17:36.68,0:17:43.05,Chinese,,0,0,0,, 如果多个「读操作」不断涌入，那么可能让「写操作」处于饥饿状态
Dialogue: 0,0:17:43.58,0:17:48.14,English,,0,0,0,,So a writer could be starved sort of indefinitely waiting for all these readers to finish
Dialogue: 0,0:17:43.58,0:17:48.14,Chinese,,0,0,0,,因此，「写操作」会一直处于饥饿并无限等待所有的「读操作」完成
Dialogue: 0,0:17:49.88,0:17:53.68,English,,0,0,0,,And it's just based on you know based based on
Dialogue: 0,0:17:49.88,0:17:53.68,Chinese,,0,0,0,,它只是基于......
Dialogue: 0,0:17:54.82,0:17:59.36,English,,0,0,0,,How the operating system decides to schedule these various reader threads
Dialogue: 0,0:17:54.82,0:17:59.36,Chinese,,0,0,0,,操作系统如何调度这些不同「读操作」的线程
Dialogue: 0,0:18:00.94,0:18:06.57,English,,0,0,0,,The writer could be starved out so that's what we mean by when we say that it favors readers
Dialogue: 0,0:18:00.94,0:18:06.57,Chinese,,0,0,0,,「写操作」可能会挨饿，这就是所谓的对「读操作」有利的情况
Dialogue: 0,0:18:07.22,0:18:14.68,English,,0,0,0,,Now the second reader writer problem is the sort of the opposite of that so it favors writers right
Dialogue: 0,0:18:07.22,0:18:14.68,Chinese,,0,0,0,,第二类「读写问题」恰恰相反，这种情况有利于「写操作」
Dialogue: 0,0:18:14.90,0:18:18.52,English,,0,0,0,,So any once a writer is ready to write
Dialogue: 0,0:18:14.90,0:18:18.52,Chinese,,0,0,0,,所以「写操作」准备好了
Dialogue: 0,0:18:18.54,0:18:21.22,English,,0,0,0,,Then it gets priority over any waiting readers
Dialogue: 0,0:18:18.54,0:18:21.22,Chinese,,0,0,0,,然后它优先于任何等待中的「读操作」
Dialogue: 0,0:18:21.58,0:18:28.92,English,,0,0,0,,So in this case if we have multiple writers that want to write they could starve out readers
Dialogue: 0,0:18:21.58,0:18:28.92,Chinese,,0,0,0,,所以在这种情况下，如果我们有多个「写操作」要进行写，他们会造成「读操作」饥饿
Dialogue: 0,0:18:32.76,0:18:39.52,English,,0,0,0,,And now there's other variants that sort of deal with this starvation issue potential starvation issue
Dialogue: 0,0:18:32.76,0:18:39.52,Chinese,,0,0,0,,现在有其他变种（读写问题）可以解决饥饿问题，或者潜在饥饿问题
Dialogue: 0,0:18:39.52,0:18:41.88,English,,0,0,0,,But we won't look at them here
Dialogue: 0,0:18:39.52,0:18:41.88,Chinese,,0,0,0,,但我们不会在这里看讲到
Dialogue: 0,0:18:43.38,0:18:47.58,English,,0,0,0,,So the let's look at the solution to the first readers writers problem
Dialogue: 0,0:18:43.38,0:18:47.58,Chinese,,0,0,0,,让我们来看看第一类「读写问题」的解决方案
Dialogue: 0,0:18:50.62,0:18:56.84,English,,0,0,0,,So initially a thread is either a reader in this sort of simplification or it's a writer
Dialogue: 0,0:18:50.62,0:18:56.84,Chinese,,0,0,0,,这是简化的「读操作」，这是「写操作」
Dialogue: 0,0:18:59.44,0:19:01.76,English,,0,0,0,,If we look at the writers this is pretty simple
Dialogue: 0,0:18:59.44,0:19:01.76,Chinese,,0,0,0,,看一下「写操作」，很简单
Dialogue: 0,0:19:01.76,0:19:09.20,English,,0,0,0,,It's just the writers are just doing a P on this semaphore
Dialogue: 0,0:19:01.76,0:19:09.20,Chinese,,0,0,0,,这里「写操作」只对信号量进行 P 操作
Dialogue: 0,0:19:09.40,0:19:17.66,English,,0,0,0,,So this the semaphore w is the sort of serves as like a mutex that protects the resource for writer
Dialogue: 0,0:19:09.40,0:19:17.66,Chinese,,0,0,0,,因此，信号量 w 就像一个 mutex 一样，保护写资源
Dialogue: 0,0:19:17.72,0:19:25.74,English,,0,0,0,,So it ensures that there's at most one writer at any time executing its critical section
Dialogue: 0,0:19:17.72,0:19:25.74,Chinese,,0,0,0,,因此，它确保在任何时候最多只有一个「写操作」对临界值进行操作
Dialogue: 0,0:19:26.54,0:19:34.00,English,,0,0,0,,And it does that by just this this very from this familiar P followed followed by a V
Dialogue: 0,0:19:26.54,0:19:34.00,Chinese,,0,0,0,,按照惯例 P 操作后面会跟着一个 V 操作
Dialogue: 0,0:19:35.60,0:19:37.42,English,,0,0,0,,In the readers are a little more interesting
Dialogue: 0,0:19:35.60,0:19:37.42,Chinese,,0,0,0,,「读操作」会更有趣一点
Dialogue: 0,0:19:38.88,0:19:40.30,English,,0,0,0,,So with the reader
Dialogue: 0,0:19:38.88,0:19:40.30,Chinese,,0,0,0,,对于「读操作」来说
Dialogue: 0,0:19:40.92,0:19:46.16,English,,0,0,0,,We have the shared this global variable called readcnt which is going to keep track of the number of readers
Dialogue: 0,0:19:40.92,0:19:46.16,Chinese,,0,0,0,,我们共享了这个名为 readcnt 的全局变量，它将跟踪「读操作」的数量
Dialogue: 0,0:19:46.50,0:19:51.58,English,,0,0,0,,That are waiting to read the resource
Dialogue: 0,0:19:46.50,0:19:51.58,Chinese,,0,0,0,,它们正在等待读取资源
Dialogue: 0,0:19:52.34,0:19:57.94,English,,0,0,0,,And there's a mutex semaphore mutex that protects the accesses the updates to readcnt
Dialogue: 0,0:19:52.34,0:19:57.94,Chinese,,0,0,0,,并且有一个互斥信号量 mutex 用户保护 readcnt 的读取和更新
Dialogue: 0,0:19:58.66,0:20:01.80,English,,0,0,0,,Okay the reads and the rights to up to read count
Dialogue: 0,0:19:58.66,0:20:01.80,Chinese,,0,0,0,,「读操作」有权操作 readcnt
Dialogue: 0,0:20:02.74,0:20:04.64,English,,0,0,0,,And then there's this w semaphore
Dialogue: 0,0:20:02.74,0:20:04.64,Chinese,,0,0,0,,然后是 w 信号量
Dialogue: 0,0:20:05.12,0:20:10.68,English,,0,0,0,,Which as we saw here is used to protect the critical section in the writer
Dialogue: 0,0:20:05.12,0:20:10.68,Chinese,,0,0,0,,我们在这里看到的用于保护「写操作」中的临界值
Dialogue: 0,0:20:11.60,0:20:13.90,English,,0,0,0,,And initially both of these are set to one
Dialogue: 0,0:20:11.60,0:20:13.90,Chinese,,0,0,0,,这两个信号量初始值都是 1
Dialogue: 0,0:20:16.70,0:20:18.38,English,,0,0,0,,So the reader in this infinite loop
Dialogue: 0,0:20:16.70,0:20:18.38,Chinese,,0,0,0,,「读操作」在这个死循环当中
Dialogue: 0,0:20:18.38,0:20:23.76,English,,0,0,0,,In each iteration of this infinite loop,it is going to increment readcnt
Dialogue: 0,0:20:18.38,0:20:23.76,Chinese,,0,0,0,,这个死循环中的每次迭代都会增加 readcnt 的值
Dialogue: 0,0:20:23.76,0:20:30.64,English,,0,0,0,,So it protects that that access by doing a P(&mutex) which is associated with readcnt
Dialogue: 0,0:20:23.76,0:20:30.64,Chinese,,0,0,0,,这会通过 P(&fmutex) 来保护对 readcnt 的更新
Dialogue: 0,0:20:33.04,0:20:36.80,English,,0,0,0,,So only one reader can be
Dialogue: 0,0:20:33.04,0:20:36.80,Chinese,,0,0,0,,所以只有一个「读操作」可以（操作 readcnt）
Dialogue: 0,0:20:36.96,0:20:44.36,English,,0,0,0,,So this region between the P and the V constitutes the critical section corresponding to read count
Dialogue: 0,0:20:36.96,0:20:44.36,Chinese,,0,0,0,,因此， P 和 V 之间的这个区域相当于 readcnt 的临界区
Dialogue: 0,0:20:45.66,0:20:50.54,English,,0,0,0,,So after the P completes then it
Dialogue: 0,0:20:45.66,0:20:50.54,Chinese,,0,0,0,,所以在 P 操作完成之后
Dialogue: 0,0:20:51.30,0:20:55.40,English,,0,0,0,,Then we increment the readcnt so now there's an additional reader
Dialogue: 0,0:20:51.30,0:20:55.40,Chinese,,0,0,0,,增加了 readcnt 的值，现在有另外一个「读操作」
Dialogue: 0,0:20:56.20,0:20:58.80,English,,0,0,0,,Alright so we can have potentially arbitrary number of these reader threads
Dialogue: 0,0:20:56.20,0:20:58.80,Chinese,,0,0,0,,好吧，我们可以有任意数量的「读操作」线程
Dialogue: 0,0:20:58.80,0:21:03.18,English,,0,0,0,,Right so this we're indicating that there's a new reader now
Dialogue: 0,0:20:58.80,0:21:03.18,Chinese,,0,0,0,,所以我们用这种方式来表明这是一个新的「读操作」
Dialogue: 0,0:21:04.54,0:21:07.90,English,,0,0,0,,And if readcnt is one that means we're the first reader
Dialogue: 0,0:21:04.54,0:21:07.90,Chinese,,0,0,0,,如果 readcnt 是 1 就表示是第一个「读操作」
Dialogue: 0,0:21:08.46,0:21:14.82,English,,0,0,0,,Okay so this is sort of the first reader into this implicit queue of waiting readers
Dialogue: 0,0:21:08.46,0:21:14.82,Chinese,,0,0,0,,所以这是第一个进入这个等待「读操作」的隐式队列的「读操作」
Dialogue: 0,0:21:17.00,0:21:20.04,English,,0,0,0,,So if read count is one if we're the first reader
Dialogue: 0,0:21:17.00,0:21:20.04,Chinese,,0,0,0,,因此，如果我们是第一个「读操作」（readcnt == 1）
Dialogue: 0,0:21:21.46,0:21:23.36,English,,0,0,0,,Then we do a P(&w)
Dialogue: 0,0:21:21.46,0:21:23.36,Chinese,,0,0,0,,然后我们做 P(&w)
Dialogue: 0,0:21:25.26,0:21:29.26,English,,0,0,0,,Okay which now will lock out any future writers
Dialogue: 0,0:21:25.26,0:21:29.26,Chinese,,0,0,0,,现在我们锁住了「写操作」
Dialogue: 0,0:21:30.58,0:21:36.90,English,,0,0,0,,Now if there's already a writer that's done it's P(&w) then this will block waiting for that writer to finish
Dialogue: 0,0:21:30.58,0:21:36.90,Chinese,,0,0,0,,现在如果有一个「写操作」已经完成了 P(&w)，那么这里将会阻塞，等待「写操作」完成
Dialogue: 0,0:21:38.74,0:21:43.58,English,,0,0,0,,Okay but if there's no writer in inside of its critical section
Dialogue: 0,0:21:38.74,0:21:43.58,Chinese,,0,0,0,,但是「写操作」的临界区没有任何操作
Dialogue: 0,0:21:44.36,0:21:50.16,English,,0,0,0,,Then this p will just decrement the semaphore w from 1 to 0
Dialogue: 0,0:21:44.36,0:21:50.16,Chinese,,0,0,0,,然后这个 P 操作将信号量 w 从 1 减为 0
Dialogue: 0,0:21:50.64,0:21:52.76,English,,0,0,0,,And then lock out any subsequent writers
Dialogue: 0,0:21:50.64,0:21:52.76,Chinese,,0,0,0,,然后阻塞后续的「写操作」
Dialogue: 0,0:21:54.76,0:22:01.54,English,,0,0,0,,Okay after so now after it's done this increment and read of the recount variable then it releases the mutex
Dialogue: 0,0:21:54.76,0:22:01.54,Chinese,,0,0,0,,这里在完成对 readcnt 变量的增加之后会释放 mutex
Dialogue: 0,0:22:02.40,0:22:06.00,English,,0,0,0,,So that other readers can access readcnt
Dialogue: 0,0:22:02.40,0:22:06.00,Chinese,,0,0,0,,这样其他「读操作」可以访问 readcnt
Dialogue: 0,0:22:09.92,0:22:11.36,English,,0,0,0,,Okay now but it's still holding
Dialogue: 0,0:22:09.92,0:22:11.36,Chinese,,0,0,0,,但是锁会持续一段时间
Dialogue: 0,0:22:15.30,0:22:22.76,English,,0,0,0,,It's holding,so this is kind of interesting right, it's holding the semaphore that locks out the writers
Dialogue: 0,0:22:15.30,0:22:22.76,Chinese,,0,0,0,,这很有趣，维持信号量，一直锁住「写操作」
Dialogue: 0,0:22:24.20,0:22:33.10,English,,0,0,0,,But it's not holding the any mutex right so the reader now can just read,it can do its read
Dialogue: 0,0:22:24.20,0:22:33.10,Chinese,,0,0,0,,但是不会保存 mutex，所有「读操作」可以读取它（readcnt）
Dialogue: 0,0:22:34.32,0:22:41.12,English,,0,0,0,,And other readers that are in the same section of the code can also do their reads right so
Dialogue: 0,0:22:34.32,0:22:41.12,Chinese,,0,0,0,,而在代码的同一部分中的其他「读操作」可以正确地进行读取
Dialogue: 0,0:22:42.04,0:22:42.60,English,,0,0,0,,So we're not...
Dialogue: 0,0:22:42.04,0:22:42.60,Chinese,,0,0,0,,所以我们不是 ......
Dialogue: 0,0:22:45.60,0:22:49.15,English,,0,0,0,,So we're allowing multiple readers now inside this critical section
Dialogue: 0,0:22:45.60,0:22:49.15,Chinese,,0,0,0,,所以我们现在允许多个「读操作」进入这个关键部分
Dialogue: 0,0:22:49.62,0:22:51.16,English,,0,0,0,,But but no writers
Dialogue: 0,0:22:49.62,0:22:51.16,Chinese,,0,0,0,,但是没有「写操作」
Dialogue: 0,0:22:52.64,0:22:57.54,English,,0,0,0,,Okay so everything works looks like it works good,now after after we read
Dialogue: 0,0:22:52.64,0:22:57.54,Chinese,,0,0,0,,所以一切正常，看起来效果很好，现在我们读完之后
Dialogue: 0,0:22:58.24,0:23:02.30,English,,0,0,0,,Now the number of readers now is going to be we want to decrement the number of readers
Dialogue: 0,0:22:58.24,0:23:02.30,Chinese,,0,0,0,,现在我们想要减少读者的数量
Dialogue: 0,0:23:03.18,0:23:05.92,English,,0,0,0,,So we acquire the mutex on readcnt
Dialogue: 0,0:23:03.18,0:23:05.92,Chinese,,0,0,0,,所以我们在 readcnt 上获取了 mutex
Dialogue: 0,0:23:06.54,0:23:07.86,English,,0,0,0,,We decrement readcnt
Dialogue: 0,0:23:06.54,0:23:07.86,Chinese,,0,0,0,,我们减少了 readcnt
Dialogue: 0,0:23:09.50,0:23:11.80,English,,0,0,0,,And then we check to see if we're the last reader
Dialogue: 0,0:23:09.50,0:23:11.80,Chinese,,0,0,0,,然后检查一下是不是最后一个「读操作」
Dialogue: 0,0:23:12.52,0:23:13.76,English,,0,0,0,,Okay so if there's no more readers
Dialogue: 0,0:23:12.52,0:23:13.76,Chinese,,0,0,0,,如果没有「读操作」了
Dialogue: 0,0:23:14.51,0:23:16.32,English,,0,0,0,,In other words if read count is zero
Dialogue: 0,0:23:14.51,0:23:16.32,Chinese,,0,0,0,,换句话说，如果 readcnt 等于 0
Dialogue: 0,0:23:18.14,0:23:20.96,English,,0,0,0,,Then now we can release the mutex for the writer
Dialogue: 0,0:23:18.14,0:23:20.96,Chinese,,0,0,0,,然后现在我们可以为「写操作」释放互斥锁
Dialogue: 0,0:23:21.34,0:23:24.24,English,,0,0,0,,So that any now writers can access that resource
Dialogue: 0,0:23:21.34,0:23:24.24,Chinese,,0,0,0,,这样任何「写操作」都可以访问该资源
Dialogue: 0,0:23:25.98,0:23:33.52,English,,0,0,0,,And after we release that the writers mutex then we release the mutex for recount
Dialogue: 0,0:23:25.98,0:23:33.52,Chinese,,0,0,0,,在我们释放「写操作」互斥锁之后，我们释放 readcnt 的互斥锁
Dialogue: 0,0:23:37.20,0:23:39.16,English,,0,0,0,,So any questions about about this
Dialogue: 0,0:23:37.20,0:23:39.16,Chinese,,0,0,0,,所以大家有什么问题么？
Dialogue: 0,0:23:43.20,0:23:45.36,English,,0,0,0,,So an interesting for you to think about just...
Dialogue: 0,0:23:43.20,0:23:45.36,Chinese,,0,0,0,,所以有趣的是你只想 ......
Dialogue: 0,0:23:46.18,0:23:47.36,English,,0,0,0,,If you have any spare time
Dialogue: 0,0:23:46.18,0:23:47.36,Chinese,,0,0,0,,如果你有空余时间
Dialogue: 0,0:23:47.80,0:23:56.16,English,,0,0,0,,How you might write a version of this readers writers problem or that favors writers instead of readers
Dialogue: 0,0:23:47.80,0:23:56.16,Chinese,,0,0,0,,你可以写一个有利于「写操作」的「读写问题」的版本，看看会发生什么
Dialogue: 0,0:23:59.80,0:24:00.18,English,,0,0,0,,Yes
Dialogue: 0,0:23:59.80,0:24:00.18,Chinese,,0,0,0,,请讲
Dialogue: 0,0:24:00.30,0:24:05.96,English,,0,0,0,,[student speaking]
Dialogue: 0,0:24:00.30,0:24:05.96,Chinese,,0,0,0,,【同学提问】
Dialogue: 0,0:24:05.96,0:24:09.44,English,,0,0,0,,Oh no okay so the question is a mutex allows for multiple readers
Dialogue: 0,0:24:05.96,0:24:09.44,Chinese,,0,0,0,,他问的问题是互斥量允许多个「读操作」
Dialogue: 0,0:24:11.08,0:24:15.36,English,,0,0,0,,The fact that we...No,the fact that we're releasing this mutex here
Dialogue: 0,0:24:11.08,0:24:15.36,Chinese,,0,0,0,,事实上，我们 ...... 不，我们在这里释放这个互斥锁
Dialogue: 0,0:24:15.42,0:24:19.40,English,,0,0,0,,That this mutex is only protecting access to readcnt
Dialogue: 0,0:24:15.42,0:24:19.40,Chinese,,0,0,0,,这个互斥锁只是保护对 readcnt 的访问
Dialogue: 0,0:24:19.74,0:24:21.84,English,,0,0,0,,So we acquire it here and we release it here
Dialogue: 0,0:24:19.74,0:24:21.84,Chinese,,0,0,0,,所以我们在这里获得它，我们在这里释放它
Dialogue: 0,0:24:22.30,0:24:25.48,English,,0,0,0,,After we've...after we've accessed read count
Dialogue: 0,0:24:22.30,0:24:25.48,Chinese,,0,0,0,,在我们 ... 之后我们访问了 readcnt
Dialogue: 0,0:24:27.22,0:24:31.72,English,,0,0,0,,Okay but we're not protecting the critical section of the reader with any mutex
Dialogue: 0,0:24:27.22,0:24:31.72,Chinese,,0,0,0,,但我们没有用任何互斥锁来保护「读操作」的临界区
Dialogue: 0,0:24:33.42,0:24:39.18,English,,0,0,0,,Except for we're keeping writers out by...if we're the first one in
Dialogue: 0,0:24:33.42,0:24:39.18,Chinese,,0,0,0,,除了我们要把「写操作」挡在外面 ...... 如果我们是第一个「读操作」进来
Dialogue: 0,0:24:39.84,0:24:40.98,English,,0,0,0,,If we're the first reader
Dialogue: 0,0:24:39.84,0:24:40.98,Chinese,,0,0,0,,如果是第一个「读操作」
Dialogue: 0,0:24:42.84,0:24:47.38,English,,0,0,0,,You commanders like this implicit queue of readers that we're keeping track of with readcnt
Dialogue: 0,0:24:42.84,0:24:47.38,Chinese,,0,0,0,,想象你是一个「读操作」队列的指挥官，用 readcnt 跟踪它们
Dialogue: 0,0:24:48.40,0:24:52.96,English,,0,0,0,,Okay so if we're the first ones in meaning
Dialogue: 0,0:24:48.40,0:24:52.96,Chinese,,0,0,0,,所以第一个「读操作」意味着
Dialogue: 0,0:24:53.54,0:24:59.04,English,,0,0,0,,We're the first reader then we we acquire this the p on the writers mutex
Dialogue: 0,0:24:53.54,0:24:59.04,Chinese,,0,0,0,,第一个「读操作」要通过 P 操作来获取写的互斥锁
Dialogue: 0,0:24:59.24,0:25:04.24,English,,0,0,0,,Now if there's of course if there's a writer inside this critical section then
Dialogue: 0,0:24:59.24,0:25:04.24,Chinese,,0,0,0,,但是现在如果「写操作」已经进入临界区了
Dialogue: 0,0:25:04.88,0:25:07.86,English,,0,0,0,,This P will wait until the writer releases
Dialogue: 0,0:25:04.88,0:25:07.86,Chinese,,0,0,0,,那么这里的 P 操作将等待「写操作」释放互斥锁
Dialogue: 0,0:25:09.88,0:25:14.72,English,,0,0,0,,Okay but once we've acquired this mutex w
Dialogue: 0,0:25:09.88,0:25:14.72,Chinese,,0,0,0,,不过「读操作」一旦获得互斥锁 w
Dialogue: 0,0:25:16.30,0:25:18.54,English,,0,0,0,,Then we're block...we're locking out any writers
Dialogue: 0,0:25:16.30,0:25:18.54,Chinese,,0,0,0,,就会阻塞所有的「写操作」
Dialogue: 0,0:25:19.24,0:25:28.12,English,,0,0,0,,Okay because they'll any writer that arrives we'll do a P and it will block right here on waiting for that w to be nonzero
Dialogue: 0,0:25:19.24,0:25:28.12,Chinese,,0,0,0,,因为任何「写操作」到这里都会进行 P 操作，就会被阻塞等待信号量 w 变成非零
Dialogue: 0,0:25:29.54,0:25:36.98,English,,0,0,0,,Okay so we're just blocking out any writers but then we're allowing any readers to just to access the resource
Dialogue: 0,0:25:29.54,0:25:36.98,Chinese,,0,0,0,,所以我们阻塞了所有「写操作」，但我们允许任何「读操作」可以访问资源
Dialogue: 0,0:25:40.08,0:25:40.52,English,,0,0,0,,Okay
Dialogue: 0,0:25:40.08,0:25:40.52,Chinese,,0,0,0,,好的
Dialogue: 0,0:25:41.84,0:25:42.50,English,,0,0,0,,Okay good
Dialogue: 0,0:25:41.84,0:25:42.50,Chinese,,0,0,0,,好的
Dialogue: 0,0:25:45.14,0:25:45.72,English,,0,0,0,,Yes question
Dialogue: 0,0:25:45.14,0:25:45.72,Chinese,,0,0,0,,请讲
Dialogue: 0,0:25:45.72,0:25:49.64,English,,0,0,0,,[student speaking]
Dialogue: 0,0:25:45.72,0:25:49.64,Chinese,,0,0,0,,【同学提问】
Dialogue: 0,0:25:49.64,0:25:51.02,English,,0,0,0,,Question is blocking slow
Dialogue: 0,0:25:49.64,0:25:51.02,Chinese,,0,0,0,,问题阻塞很慢
Dialogue: 0,0:25:51.50,0:25:56.00,English,,0,0,0,,It can be depends well first of all you're making a call into the kernel so it's a system call
Dialogue: 0,0:25:51.50,0:25:56.00,Chinese,,0,0,0,,可能会。这取决于你是否正在调用内核，因此它是一个系统调用
Dialogue: 0,0:25:56.56,0:26:00.10,English,,0,0,0,,So you're crossing that boundary and there's always overhead associated with that
Dialogue: 0,0:25:56.56,0:26:00.10,Chinese,,0,0,0,,所以你越过那个边界，总是有与之相关的开销
Dialogue: 0,0:26:01.00,0:26:07.08,English,,0,0,0,,And then blocking you're blocked until you know it can be sort of an arbitrary amount of time right
Dialogue: 0,0:26:01.00,0:26:07.08,Chinese,,0,0,0,,你知道的任何时刻你都有可能会被阻塞
Dialogue: 0,0:26:07.08,0:26:09.58,English,,0,0,0,,Until someone doesn't,some thread does a V
Dialogue: 0,0:26:07.08,0:26:09.58,Chinese,,0,0,0,,直到某个线程会做了 V 操作
Dialogue: 0,0:26:10.32,0:26:11.92,English,,0,0,0,,So yeah it can be slow
Dialogue: 0,0:26:10.32,0:26:11.92,Chinese,,0,0,0,,所以是的，可能很慢
Dialogue: 0,0:26:13.22,0:26:18.34,English,,0,0,0,,Right it just depends you can't,it's really hard to bound the time that you're going to be blocked
Dialogue: 0,0:26:13.22,0:26:18.34,Chinese,,0,0,0,,很难判定阻塞的时间
Dialogue: 0,0:26:19.22,0:26:22.44,English,,0,0,0,,Now if you write the program correctly eventually you'll be unblocked
Dialogue: 0,0:26:19.22,0:26:22.44,Chinese,,0,0,0,,现在如果你正确编写程序，你就不会阻塞
Dialogue: 0,0:26:23.10,0:26:25.48,English,,0,0,0,,You know eventually some thread will execute a V
Dialogue: 0,0:26:23.10,0:26:25.48,Chinese,,0,0,0,,你知道最终某些线程将执行 V
Dialogue: 0,0:26:27.88,0:26:35.50,English,,0,0,0,,But when we're sort of assuming that the kernel does some kind of when it implements its V it does some kind of fair scheduling that
Dialogue: 0,0:26:27.88,0:26:35.50,Chinese,,0,0,0,,但是，当我们假设内核在实现其 V 时执行某种操作时，它会执行某种公平调度
Dialogue: 0,0:26:36.26,0:26:44.42,English,,0,0,0,,So a blocked P want be in its queue for forever right that the kernel does some kind of something that's fair
Dialogue: 0,0:26:36.26,0:26:44.42,Chinese,,0,0,0,,所以内核会做某种公平的事情让一个被阻塞的 P 操作会在其队列中
Dialogue: 0,0:26:44.78,0:26:48.70,English,,0,0,0,,So it guarantees that a P won't remain blocked indefinitely
Dialogue: 0,0:26:44.78,0:26:48.70,Chinese,,0,0,0,,因此，它保证 P 不会无限期地阻塞下去
Dialogue: 0,0:26:54.80,0:26:55.60,English,,0,0,0,,Other questions
Dialogue: 0,0:26:54.80,0:26:55.60,Chinese,,0,0,0,,还有其他问题吗
Dialogue: 0,0:27:00.86,0:27:02.86,English,,0,0,0,,Okay so we can kind of put all of this together
Dialogue: 0,0:27:00.86,0:27:02.86,Chinese,,0,0,0,,现在我们将这些放在一起
Dialogue: 0,0:27:04.42,0:27:08.46,English,,0,0,0,,And and use our producer-consumer model
Dialogue: 0,0:27:04.42,0:27:08.46,Chinese,,0,0,0,,并使用「生产者-消费者」模型
Dialogue: 0,0:27:09.30,0:27:13.26,English,,0,0,0,,To implement a prethreaded concurrent echo server
Dialogue: 0,0:27:09.30,0:27:13.26,Chinese,,0,0,0,,实现一个预线程并发的 echo 服务器
Dialogue: 0,0:27:13.78,0:27:16.44,English,,0,0,0,,Now so far when we've used threads to
Dialogue: 0,0:27:13.78,0:27:16.44,Chinese,,0,0,0,,到目前为止，当我们使用线程时
Dialogue: 0,0:27:16.78,0:27:20.12,English,,0,0,0,,In all our examples of using threads and processes for servers
Dialogue: 0,0:27:16.78,0:27:20.12,Chinese,,0,0,0,,在我们为服务器使用线程和进程的所有示例中
Dialogue: 0,0:27:20.70,0:27:24.54,English,,0,0,0,,We created a new thread or process whenever a new connection requests arrived
Dialogue: 0,0:27:20.70,0:27:24.54,Chinese,,0,0,0,,每当有新的连接请求到达时，我们都会创建一个新线程或进程
Dialogue: 0,0:27:25.92,0:27:27.06,English,,0,0,0,,And then when
Dialogue: 0,0:27:25.92,0:27:27.06,Chinese,,0,0,0,,然后
Dialogue: 0,0:27:28.04,0:27:30.66,English,,0,0,0,,And then that thread interacted with the client
Dialogue: 0,0:27:28.04,0:27:30.66,Chinese,,0,0,0,,然后该线程与客户端进行了交互
Dialogue: 0,0:27:31.66,0:27:36.36,English,,0,0,0,,And then whenever that interaction was finished it closed the connection and exited
Dialogue: 0,0:27:31.66,0:27:36.36,Chinese,,0,0,0,,然后，无论何时完成该交互，它都会关闭连接并退出
Dialogue: 0,0:27:36.66,0:27:38.58,English,,0,0,0,,And killed the thread or process
Dialogue: 0,0:27:36.66,0:27:38.58,Chinese,,0,0,0,,并杀死了线程或进程
Dialogue: 0,0:27:39.34,0:27:42.64,English,,0,0,0,,Now that's okay but it's inefficient
Dialogue: 0,0:27:39.34,0:27:42.64,Chinese,,0,0,0,,现在没关系，但效率低下
Dialogue: 0,0:27:43.50,0:27:49.14,English,,0,0,0,,Because we're this creating and killing threads introduces overhead
Dialogue: 0,0:27:43.50,0:27:49.14,Chinese,,0,0,0,,因为线程的创建和销毁开销都很大
Dialogue: 0,0:27:50.28,0:27:59.02,English,,0,0,0,,So another way to do this is to create the treads or processes ahead of time create a pool of threads
Dialogue: 0,0:27:50.28,0:27:59.02,Chinese,,0,0,0,,因此，另一种方法是提前创建好线程或进程，创建一个线程池
Dialogue: 0,0:27:59.34,0:28:04.20,English,,0,0,0,,Where each thread so we create a pool of these worker threads
Dialogue: 0,0:27:59.34,0:28:04.20,Chinese,,0,0,0,,每一个线程池中的工作线程
Dialogue: 0,0:28:04.20,0:28:08.88,English,,0,0,0,,Where each of these worker threads interacts with can interact with a client
Dialogue: 0,0:28:04.20,0:28:08.88,Chinese,,0,0,0,,这些工作线程中的每一个都与客户端进行交互
Dialogue: 0,0:28:11.10,0:28:14.84,English,,0,0,0,,Okay so instead of sort of creating processes and threads on on-demand
Dialogue: 0,0:28:11.10,0:28:14.84,Chinese,,0,0,0,,而不是按需创建进程和线程
Dialogue: 0,0:28:14.86,0:28:24.52,English,,0,0,0,,We create a,what we call a set of pre threaded or pre threaded threads or pre forked processes That do the work
Dialogue: 0,0:28:14.86,0:28:24.52,Chinese,,0,0,0,,我们称之为预线程或者预先生成进程来做工作
Dialogue: 0,0:28:25.48,0:28:30.44,English,,0,0,0,,So the idea is that we have this master thread in our server
Dialogue: 0,0:28:25.48,0:28:30.44,Chinese,,0,0,0,,所以我们的想法是在服务器中有这个主线程
Dialogue: 0,0:28:30.96,0:28:36.82,English,,0,0,0,,That's waiting for connection requests from clients by repeated calls to accept
Dialogue: 0,0:28:30.96,0:28:36.82,Chinese,,0,0,0,,用来循环等待接收来自客户端的请求
Dialogue: 0,0:28:38.40,0:28:43.42,English,,0,0,0,,And then when this thread receives the connection request from the client
Dialogue: 0,0:28:38.40,0:28:43.42,Chinese,,0,0,0,,当这个线程收到来自客户端的连接请求
Dialogue: 0,0:28:43.42,0:28:48.52,English,,0,0,0,,The accept call the accept function returns a connected file descriptor
Dialogue: 0,0:28:43.42,0:28:48.52,Chinese,,0,0,0,,调用 accept 函数返回一个连接的文件描述符
Dialogue: 0,0:28:49.32,0:28:52.62,English,,0,0,0,,Ok associated with the connection to the client
Dialogue: 0,0:28:49.32,0:28:52.62,Chinese,,0,0,0,,确保与客户端的连接相关联
Dialogue: 0,0:28:53.82,0:28:58.38,English,,0,0,0,,And then it inserts that descriptor into a into a buffer
Dialogue: 0,0:28:53.82,0:28:58.38,Chinese,,0,0,0,,然后它将该描述符插入到缓冲区中
Dialogue: 0,0:28:58.76,0:29:01.74,English,,0,0,0,,Ok now remember descriptors are just small integers
Dialogue: 0,0:28:58.76,0:29:01.74,Chinese,,0,0,0,,好的，现在记住描述符只是小整数
Dialogue: 0,0:29:02.48,0:29:04.74,English,,0,0,0,,That index the descriptor table
Dialogue: 0,0:29:02.48,0:29:04.74,Chinese,,0,0,0,,是描述符表的索引
Dialogue: 0,0:29:05.28,0:29:09.10,English,,0,0,0,,Right so they can be passed around from thread to thread
Dialogue: 0,0:29:05.28,0:29:09.10,Chinese,,0,0,0,,因此它们可以在线程之间相互传递
Dialogue: 0,0:29:09.22,0:29:15.50,English,,0,0,0,,Because all the threads are sharing the same The same set that same descriptor table right
Dialogue: 0,0:29:09.22,0:29:15.50,Chinese,,0,0,0,,因为所有线程共享相同...相同的描述符表设置
Dialogue: 0,0:29:17.76,0:29:19.48,English,,0,0,0,,So the master thread puts
Dialogue: 0,0:29:17.76,0:29:19.48,Chinese,,0,0,0,,所以主线程
Dialogue: 0,0:29:21.32,0:29:28.90,English,,0,0,0,,The repeatedly accepts connection requests and inserts the corresponding connected file descriptor into the buffer
Dialogue: 0,0:29:21.32,0:29:28.90,Chinese,,0,0,0,,重复接受连接请求并将相应的连接文件描述符插入缓冲区
Dialogue: 0,0:29:30.32,0:29:37.00,English,,0,0,0,,Now each worker thread waits for the...so in this case the items are descriptors
Dialogue: 0,0:29:30.32,0:29:37.00,Chinese,,0,0,0,,现在每个工作线程都等待 ... 所以在这种情况下，元素是描述符
Dialogue: 0,0:29:37.88,0:29:43.25,English,,0,0,0,,So the worker threads they're all waiting on this for items to appear in this buffer
Dialogue: 0,0:29:37.88,0:29:43.25,Chinese,,0,0,0,,所以工作线程都在等待这个元素出现在缓冲区中
Dialogue: 0,0:29:44.80,0:29:48.14,English,,0,0,0,,Okay and when an item appears one of the threads will remove that item
Dialogue: 0,0:29:44.80,0:29:48.14,Chinese,,0,0,0,,当一个元素出现时，其中一个工作线程会将其删除
Dialogue: 0,0:29:51.56,0:29:55.86,English,,0,0,0,,And then use that descriptor to interact with the client
Dialogue: 0,0:29:51.56,0:29:55.86,Chinese,,0,0,0,,然后使用该描述符与客户端进行交互
Dialogue: 0,0:29:55.86,0:30:02.76,English,,0,0,0,,Over the connected file descriptor associated with the connection that exists between the client and the server
Dialogue: 0,0:29:55.86,0:30:02.76,Chinese,,0,0,0,,通过与客户端和服务器之间存在的连接关联的连接文件描述符
Dialogue: 0,0:30:04.46,0:30:12.38,English,,0,0,0,,Okay so now we have the concurrency comes in the form of these multiple worker threads interacting with multiple clients
Dialogue: 0,0:30:04.46,0:30:12.38,Chinese,,0,0,0,,现在我们的并发性是以多个工作线程与多个客户端交互的形式出现的
Dialogue: 0,0:30:13.24,0:30:18.16,English,,0,0,0,,And then when a worker thread finishes servicing a particular client
Dialogue: 0,0:30:13.24,0:30:18.16,Chinese,,0,0,0,,然后当工作线程完成为特定客户端提供服务时
Dialogue: 0,0:30:19.70,0:30:23.44,English,,0,0,0,,Then it just goes and it checks for the next file descriptor in the buffer
Dialogue: 0,0:30:19.70,0:30:23.44,Chinese,,0,0,0,,然后它就去检查缓冲区中的下一个文件描述符
Dialogue: 0,0:30:24.14,0:30:29.00,English,,0,0,0,,Okay so this is much more efficient than our previous model where
Dialogue: 0,0:30:24.14,0:30:29.00,Chinese,,0,0,0,,这比我们以前的模型更高效
Dialogue: 0,0:30:29.70,0:30:32.50,English,,0,0,0,,For each new client we had to create a thread or a process
Dialogue: 0,0:30:29.70,0:30:32.50,Chinese,,0,0,0,,之前对于每个新客户端，我们必须创建一个线程或进程
Dialogue: 0,0:30:32.90,0:30:35.64,English,,0,0,0,,And then destroy that thread or process once we were finished
Dialogue: 0,0:30:32.90,0:30:35.64,Chinese,,0,0,0,,然后在完成后要销毁该线程或进程
Dialogue: 0,0:30:35.98,0:30:39.20,English,,0,0,0,,Okay so we're sort of re amortize all the that
Dialogue: 0,0:30:35.98,0:30:39.20,Chinese,,0,0,0,,所以我们有点重新摊销
Dialogue: 0,0:30:40.40,0:30:44.50,English,,0,0,0,,That we had to go through to create these worker threads by leaving them running
Dialogue: 0,0:30:40.40,0:30:44.50,Chinese,,0,0,0,,我们必须创建这些工作线程并保持它们运行
Dialogue: 0,0:30:45.02,0:30:51.28,English,,0,0,0,,And then replacing the destruction or the killing of that thread with replacing it
Dialogue: 0,0:30:45.02,0:30:51.28,Chinese,,0,0,0,,用来代替销毁活杀掉线程的方式
Dialogue: 0,0:30:51.28,0:30:59.98,English,,0,0,0,,With just a simple a simple and very fast operation of removing an item from the buffer
Dialogue: 0,0:30:51.28,0:30:59.98,Chinese,,0,0,0,,也能更简单高效地从缓冲区中获取元素
Dialogue: 0,0:31:02.80,0:31:05.60,English,,0,0,0,,Okay so let's see how we would implement this
Dialogue: 0,0:31:02.80,0:31:05.60,Chinese,,0,0,0,,让我们看看我们将如何实现这一点
Dialogue: 0,0:31:07.16,0:31:10.24,English,,0,0,0,,And like all of these server examples it's surprisingly simple right
Dialogue: 0,0:31:07.16,0:31:10.24,Chinese,,0,0,0,,和所有这些服务器示例一样，它非常简单
Dialogue: 0,0:31:10.44,0:31:18.64,English,,0,0,0,,This is a fully functioning a real server but we can do it in one page of code
Dialogue: 0,0:31:10.44,0:31:18.64,Chinese,,0,0,0,,这是一个功能齐全的真实服务器，但我们可以在一页代码中完成
Dialogue: 0,0:31:20.44,0:31:24.18,English,,0,0,0,,So for this prethread... we're going to use threads for our concurrent server
Dialogue: 0,0:31:20.44,0:31:24.18,Chinese,,0,0,0,,所以对于这个与线程 ... 我们将使用线程搭建并发服务器
Dialogue: 0,0:31:25.14,0:31:26.88,English,,0,0,0,,And we're going to use the sbuf package
Dialogue: 0,0:31:25.14,0:31:26.88,Chinese,,0,0,0,,我们将使用 sbuf 包
Dialogue: 0,0:31:27.04,0:31:33.04,English,,0,0,0,,So we're going to create this shared buffer global variable called sbuf
Dialogue: 0,0:31:27.04,0:31:33.04,Chinese,,0,0,0,,所以我们将创建全局变量名为 sbuf 的共享缓冲区
Dialogue: 0,0:31:36.28,0:31:41.02,English,,0,0,0,,And we have listening descriptor and connected descriptor
Dialogue: 0,0:31:36.28,0:31:41.02,Chinese,,0,0,0,,我们有监听描述符和连接描述符
Dialogue: 0,0:31:41.24,0:31:45.90,English,,0,0,0,,And we have the clientlen and clientaddr that that will be used in the accept call
Dialogue: 0,0:31:41.24,0:31:45.90,Chinese,,0,0,0,,我们有 clientlen 和 clientaddr 将在 accept 调用中使用
Dialogue: 0,0:31:46.32,0:31:52.44,English,,0,0,0,,And we have the thread id(t_id) that will be used in the when we create that this thread
Dialogue: 0,0:31:46.32,0:31:52.44,Chinese,,0,0,0,,我们有线程 id （ t_id ）将在我们创建这个线程时使用
Dialogue: 0,0:31:53.80,0:31:59.32,English,,0,0,0,,So now that we start by...we're going to in this program,we're going to pass in the port number
Dialogue: 0,0:31:53.80,0:31:59.32,Chinese,,0,0,0,,所以现在我们开始 ... 我们将在这个程序中，我们将传递端口号
Dialogue: 0,0:31:59.34,0:32:02.00,English,,0,0,0,,So the server is going to be listening on some port
Dialogue: 0,0:31:59.34,0:32:02.00,Chinese,,0,0,0,,所以服务器将在某个端口上侦听
Dialogue: 0,0:32:02.66,0:32:06.60,English,,0,0,0,,So we passed that port number in as the first argument
Dialogue: 0,0:32:02.66,0:32:06.60,Chinese,,0,0,0,,所以我们将该端口号作为第一个参数传递
Dialogue: 0,0:32:09.42,0:32:12.30,English,,0,0,0,,So we call Open_listenfd(argv[1])
Dialogue: 0,0:32:09.42,0:32:12.30,Chinese,,0,0,0,,所以我们调用 Open_listenfd(argv[1])
Dialogue: 0,0:32:13.92,0:32:17.38,English,,0,0,0,,An open_listenfd creates a listening descriptor and returns it
Dialogue: 0,0:32:13.92,0:32:17.38,Chinese,,0,0,0,, open_listenfd 创建一个监听描述符并返回它
Dialogue: 0,0:32:18.04,0:32:20.78,English,,0,0,0,,Returns the value of that descriptor and listenfd
Dialogue: 0,0:32:18.04,0:32:20.78,Chinese,,0,0,0,,返回该描述符和 listenfd 的值
Dialogue: 0,0:32:22.06,0:32:26.50,English,,0,0,0,,And then we call sbuf_init to initialize a shared buffer
Dialogue: 0,0:32:22.06,0:32:26.50,Chinese,,0,0,0,,然后我们调用 sbuf_init 来初始化共享缓冲区
Dialogue: 0,0:32:28.36,0:32:31.58,English,,0,0,0,,With SBUFSIZE file descriptors
Dialogue: 0,0:32:28.36,0:32:31.58,Chinese,,0,0,0,,使用 SBUFSIZE 文件描述符
Dialogue: 0,0:32:33.92,0:32:37.36,English,,0,0,0,,And then we create a collection of n threads worker threads
Dialogue: 0,0:32:33.92,0:32:37.36,Chinese,,0,0,0,,然后我们创建一个由 n 个工作线程组合而成的集合
Dialogue: 0,0:32:38.34,0:32:44.24,English,,0,0,0,,Each of which will execute the thread routine which we've called thread  and no argument
Dialogue: 0,0:32:38.34,0:32:44.24,Chinese,,0,0,0,,每个都将执行线程例程没有参数
Dialogue: 0,0:32:46.78,0:32:50.42,English,,0,0,0,,So once we create these all of these threads then we go in this infinite loop
Dialogue: 0,0:32:46.78,0:32:50.42,Chinese,,0,0,0,,因此，一旦我们创建了这些线程，我们就会进入这个无限循环
Dialogue: 0,0:32:52.26,0:32:56.66,English,,0,0,0,,Where we call Accept
Dialogue: 0,0:32:52.26,0:32:56.66,Chinese,,0,0,0,,这里我们调用 Accept
Dialogue: 0,0:32:59.38,0:33:05.06,English,,0,0,0,,On this listening descriptor so in that except we'll block until a connection request arrives
Dialogue: 0,0:32:59.38,0:33:05.06,Chinese,,0,0,0,,在这个监听描述符上，除了我们将阻止直到连接请求到达
Dialogue: 0,0:33:05.62,0:33:11.72,English,,0,0,0,,And when it does the accept returns with a connected file descriptor that can be used to interact with the client
Dialogue: 0,0:33:05.62,0:33:11.72,Chinese,,0,0,0,,当它执行时， accept 返回一个连接的文件描述符，可用于与客户端进行交互
Dialogue: 0,0:33:14.22,0:33:18.56,English,,0,0,0,,And once we get that connected file descriptor then we just simply insert it
Dialogue: 0,0:33:14.22,0:33:18.56,Chinese,,0,0,0,,一旦我们获得了连接文件描述符，我们就可以简单地将它添加到
Dialogue: 0,0:33:19.48,0:33:24.02,English,,0,0,0,,We insert that that connected file descriptor into a shared buffer
Dialogue: 0,0:33:19.48,0:33:24.02,Chinese,,0,0,0,,我们将连接的文件描述符添加到共享缓冲区
Dialogue: 0,0:33:24.76,0:33:28.26,English,,0,0,0,,And then wait for the connection request the next connection request
Dialogue: 0,0:33:24.76,0:33:28.26,Chinese,,0,0,0,,然后等待连接请求下一个连接请求
Dialogue: 0,0:33:28.26,0:33:34.98,English,,0,0,0,,So our servers very efficient right we're just doing an accept and then a very fast insert into the buffer
Dialogue: 0,0:33:28.26,0:33:34.98,Chinese,,0,0,0,,所以我们的服务器非常高效，我们只是接受，然后非常快速地插入缓冲区
Dialogue: 0,0:33:35.72,0:33:44.60,English,,0,0,0,,Okay and then we're going to let the worker threads do all the work associated with that queue of descriptors
Dialogue: 0,0:33:35.72,0:33:44.60,Chinese,,0,0,0,,然后我们将让工作线程完成与该描述符队列相关的所有工作
Dialogue: 0,0:33:47.44,0:33:51.50,English,,0,0,0,,Now the thread routine first detaches
Dialogue: 0,0:33:47.44,0:33:51.50,Chinese,,0,0,0,,现在线程例程首先分离
Dialogue: 0,0:33:51.86,0:33:53.98,English,,0,0,0,,Okay so this is a case where we don't want to run joinable
Dialogue: 0,0:33:51.86,0:33:53.98,Chinese,,0,0,0,,这种情况我们不能进行连接
Dialogue: 0,0:33:54.88,0:33:57.64,English,,0,0,0,,Because we're never going to to join
Dialogue: 0,0:33:54.88,0:33:57.64,Chinese,,0,0,0,,因为我们永远不会连接
Dialogue: 0,0:33:58.10,0:34:05.56,English,,0,0,0,,We're never going to wait for these threads or have any reason to I kill them from the main thread
Dialogue: 0,0:33:58.10,0:34:05.56,Chinese,,0,0,0,,我们永远不会等待这些线程，或者有任何理由让我从主线程中杀死它们
Dialogue: 0,0:34:06.64,0:34:13.94,English,,0,0,0,,So this so now this this worker thread and in this infinite loop each iteration it removes an item from the buffer
Dialogue: 0,0:34:06.64,0:34:13.94,Chinese,,0,0,0,,这个无限循环的每次迭代的过程中工作线程都会删除缓冲区的元素
Dialogue: 0,0:34:13.94,0:34:18.70,English,,0,0,0,,So it blocks until there's an item that it can remove from the buffer
Dialogue: 0,0:34:13.94,0:34:18.70,Chinese,,0,0,0,,因此它会阻塞，直到有一个项目可以从缓冲区中删除
Dialogue: 0,0:34:19.60,0:34:25.36,English,,0,0,0,,And it sets it to this local variable connfd
Dialogue: 0,0:34:19.60,0:34:25.36,Chinese,,0,0,0,,并将其删除的值保存在 connfd 中
Dialogue: 0,0:34:26.22,0:34:30.58,English,,0,0,0,,And then it calls a helper sort of this is like the the helper function
Dialogue: 0,0:34:26.22,0:34:30.58,Chinese,,0,0,0,,然后它调用辅助类，这就像辅助函数一样
Dialogue: 0,0:34:31.42,0:34:36.90,English,,0,0,0,,That implements the logic for this this particular server and in this case it's an echo server
Dialogue: 0,0:34:31.42,0:34:36.90,Chinese,,0,0,0,,这实现了这个特定服务器的逻辑，在这种情况下它是一个 echo 服务器
Dialogue: 0,0:34:38.20,0:34:42.54,English,,0,0,0,,So this echo_cnt routine will interact with the client
Dialogue: 0,0:34:38.20,0:34:42.54,Chinese,,0,0,0,,因此，echo_cnt 例程将与客户端进行交互
Dialogue: 0,0:34:42.56,0:34:46.54,English,,0,0,0,,Echoing whatever the client sends us until the client closes the connection
Dialogue: 0,0:34:42.56,0:34:46.54,Chinese,,0,0,0,,回应客户端发送给服务器的任何信息，直到客户端关闭连接
Dialogue: 0,0:34:48.26,0:34:50.60,English,,0,0,0,,And then when it so whenever the client is finished then
Dialogue: 0,0:34:48.26,0:34:50.60,Chinese,,0,0,0,,然后当客户端完成时
Dialogue: 0,0:34:52.26,0:35:00.66,English,,0,0,0,,Then we close the an end of the connection and go back and get the next item out of the buffer
Dialogue: 0,0:34:52.26,0:35:00.66,Chinese,,0,0,0,,然后我们关闭连接的一端并返回，然后继续从缓冲区中获取下一个元素
Dialogue: 0,0:35:02.38,0:35:06.70,English,,0,0,0,,And as you point out that echo_cnt is just a placeholder this could be anything
Dialogue: 0,0:35:02.38,0:35:06.70,Chinese,,0,0,0,,当你指出 echo_cnt 只是一个占位符时，这可能是任何东西
Dialogue: 0,0:35:06.70,0:35:11.72,English,,0,0,0,,This could be the logic for a web server for any kind of web service or any kind of service
Dialogue: 0,0:35:06.70,0:35:11.72,Chinese,,0,0,0,,这里可能是任何类型的 Web 服务器的逻辑
Dialogue: 0,0:35:15.66,0:35:16.42,English,,0,0,0,,Now
Dialogue: 0,0:35:15.66,0:35:16.42,Chinese,,0,0,0,,现在
Dialogue: 0,0:35:18.38,0:35:22.44,English,,0,0,0,,The to initialize this echo count(init_echo_cnt) function
Dialogue: 0,0:35:18.38,0:35:22.44,Chinese,,0,0,0,,初始化函数 init_echo_cnt
Dialogue: 0,0:35:24.38,0:35:28.90,English,,0,0,0,,We need to initialize the mutex
Dialogue: 0,0:35:24.38,0:35:28.90,Chinese,,0,0,0,,我们需要初始化互斥锁
Dialogue: 0,0:35:30.78,0:35:38.54,English,,0,0,0,,So we're...so this echo_cnt function is going to have it has it defines a global variable called byte_cnt
Dialogue: 0,0:35:30.78,0:35:38.54,Chinese,,0,0,0,,所以我们 ...... 所以这个 echo_cnt 函数定义一个名为 byte_cnt 的全局变量
Dialogue: 0,0:35:39.34,0:35:43.12,English,,0,0,0,,So this in this echo server we're going to keep track of the number of bytes
Dialogue: 0,0:35:39.34,0:35:43.12,Chinese,,0,0,0,,用来记录 echo 服务器中的所有客户端收到的字节数
Dialogue: 0,0:35:43.14,0:35:46.74,English,,0,0,0,,That we've received from all the clients that we're interacting with
Dialogue: 0,0:35:43.14,0:35:46.74,Chinese,,0,0,0,,所有和我们互动客户端的字节数
Dialogue: 0,0:35:47.48,0:35:52.00,English,,0,0,0,,Okay so there's a global variable called byte_cnt which is shared by all the threads
Dialogue: 0,0:35:47.48,0:35:52.00,Chinese,,0,0,0,,好的，所以这个名为 byte_cnt 的全局变量，被所有线程共享
Dialogue: 0,0:35:52.56,0:35:58.38,English,,0,0,0,,And we're going to update this byte_cnt variable every time we receive something
Dialogue: 0,0:35:52.56,0:35:58.38,Chinese,,0,0,0,,我们每次收到信息时都会更新 byte_cnt 这个变量
Dialogue: 0,0:35:58.38,0:36:01.34,English,,0,0,0,,Every time we receive data from the client
Dialogue: 0,0:35:58.40,0:36:01.34,Chinese,,0,0,0,,每次我们从客户端收到数据
Dialogue: 0,0:36:01.96,0:36:06.24,English,,0,0,0,,And we're going to use mutex to protect the accesses to byte_cnt
Dialogue: 0,0:36:01.96,0:36:06.24,Chinese,,0,0,0,,我们将使用互斥锁来保护对 byte_cnt 的访问
Dialogue: 0,0:36:07.98,0:36:11.80,English,,0,0,0,,Okay so we're going to initially have to initialize
Dialogue: 0,0:36:07.98,0:36:11.80,Chinese,,0,0,0,,所以我们一开始要进行初始化
Dialogue: 0,0:36:13.02,0:36:15.78,English,,0,0,0,,We have to call a function that initializes
Dialogue: 0,0:36:13.02,0:36:15.78,Chinese,,0,0,0,,我们必须调用一个初始化的函数
Dialogue: 0,0:36:18.10,0:36:24.14,English,,0,0,0,,That initializes this by first initializing the mutex and then setting byte_cnt to zero
Dialogue: 0,0:36:18.10,0:36:24.14,Chinese,,0,0,0,,通过首先初始化互斥锁然后将 byte_cnt 设置为零
Dialogue: 0,0:36:27.06,0:36:28.76,English,,0,0,0,,And then within echo_cnt itself
Dialogue: 0,0:36:27.06,0:36:28.76,Chinese,,0,0,0,,然后看看 echo_cnt 函数内部
Dialogue: 0,0:36:35.98,0:36:39.10,English,,0,0,0,,There's...we've already seen...
Dialogue: 0,0:36:35.98,0:36:39.10,Chinese,,0,0,0,,我们已经看过 ......
Dialogue: 0,0:36:39.92,0:36:42.24,English,,0,0,0,,We've already seen a way to initialize a package
Dialogue: 0,0:36:39.92,0:36:42.24,Chinese,,0,0,0,,我们已经看到了初始化包的方法
Dialogue: 0,0:36:42.90,0:36:47.50,English,,0,0,0,,You know if we have some kind of package of library functions that are going to be used by multiple threads
Dialogue: 0,0:36:42.90,0:36:47.50,Chinese,,0,0,0,,你知道，如果我们有某种库函数包，将由多个线程使用
Dialogue: 0,0:36:48.24,0:36:51.72,English,,0,0,0,,There's several ways to actually initialize this package
Dialogue: 0,0:36:48.24,0:36:51.72,Chinese,,0,0,0,,实际初始化此包有几种方法
Dialogue: 0,0:36:52.40,0:36:59.88,English,,0,0,0,,So one way is to explicitly call have the main thread call this initialization function once
Dialogue: 0,0:36:52.40,0:36:59.88,Chinese,,0,0,0,,所以一种方法是显式调用主线程调用这个初始化函数一次
Dialogue: 0,0:37:00.72,0:37:05.92,English,,0,0,0,,Okay so we've seen that with like the sbuf package right the main thread has to call
Dialogue: 0,0:37:00.72,0:37:05.92,Chinese,,0,0,0,,所以我们已经看到，与 sbuf 包一样，主线程必须调用
Dialogue: 0,0:37:08.80,0:37:11.02,English,,0,0,0,,The main thread calls sbuf_init at once
Dialogue: 0,0:37:08.80,0:37:11.02,Chinese,,0,0,0,,主线程立即调用 sbuf_init
Dialogue: 0,0:37:12.40,0:37:16.68,English,,0,0,0,,Okay before any of the peer threads execute any of the worker threads executes
Dialogue: 0,0:37:12.40,0:37:16.68,Chinese,,0,0,0,,在任何对等线程执行任何工作线程执行之前
Dialogue: 0,0:37:18.64,0:37:20.42,English,,0,0,0,,But there's another way we can do this too
Dialogue: 0,0:37:18.64,0:37:20.42,Chinese,,0,0,0,,但是我们还有另一种方法可以做到这一点
Dialogue: 0,0:37:20.42,0:37:24.86,English,,0,0,0,,We can have that the worker threads actually call the initialization function
Dialogue: 0,0:37:20.42,0:37:24.86,Chinese,,0,0,0,,我们可以让工作线程实际调用初始化函数
Dialogue: 0,0:37:26.08,0:37:30.88,English,,0,0,0,,And we can use this technique provided by pthreads
Dialogue: 0,0:37:26.08,0:37:30.88,Chinese,,0,0,0,,我们可以使用 pthreads 提供的这种技术
Dialogue: 0,0:37:31.94,0:37:35.28,English,,0,0,0,,Where we define a static variable
Dialogue: 0,0:37:31.94,0:37:35.28,Chinese,,0,0,0,,我们在这里定义一个静态变量
Dialogue: 0,0:37:35.66,0:37:42.08,English,,0,0,0,,So this is a static local variable but you recall that, this is actually treated like a global variable
Dialogue: 0,0:37:35.66,0:37:42.08,Chinese,,0,0,0,,所以这是一个静态局部变量，但你还记得，这实际上被视为一个全局变量
Dialogue: 0,0:37:42.62,0:37:47.08,English,,0,0,0,,So it every thread has access to this variable
Dialogue: 0,0:37:42.62,0:37:47.08,Chinese,,0,0,0,,所以每个线程都可以访问这个变量
Dialogue: 0,0:37:48.00,0:37:53.94,English,,0,0,0,,Okay but its scope is limited to the echo_cnt function
Dialogue: 0,0:37:48.00,0:37:53.94,Chinese,,0,0,0,,但它的范围仅限于 echo_cnt 函数
Dialogue: 0,0:37:53.96,0:37:59.16,English,,0,0,0,,So no other function can access this variable
Dialogue: 0,0:37:53.96,0:37:59.16,Chinese,,0,0,0,,因此没有其他函数可以访问此变量
Dialogue: 0,0:37:59.50,0:38:05.48,English,,0,0,0,,But each thread that executes this thread routine has access to it
Dialogue: 0,0:37:59.50,0:38:05.48,Chinese,,0,0,0,,但是，执行此线程例程的每个线程都可以访问它
Dialogue: 0,0:38:05.96,0:38:09.64,English,,0,0,0,,And in this context it's treated like a global right
Dialogue: 0,0:38:05.96,0:38:09.64,Chinese,,0,0,0,,在这种情况下，它被视为「全局变量」
Dialogue: 0,0:38:09.72,0:38:15.34,English,,0,0,0,,So if one thread updates the value every other every thread sees that same value
Dialogue: 0,0:38:09.72,0:38:15.34,Chinese,,0,0,0,,因此，如果一个线程更新该值，则每个线程都会看到相同的值
Dialogue: 0,0:38:16.54,0:38:21.92,English,,0,0,0,,Okay so we can use this mechanism from pthreads
Dialogue: 0,0:38:16.54,0:38:21.92,Chinese,,0,0,0,,我们可以从 pthreads 使用这个机制
Dialogue: 0,0:38:22.76,0:38:31.42,English,,0,0,0,,But so we can create this variable of type pthread_once_t and initialize it to this special pthreads value
Dialogue: 0,0:38:22.76,0:38:31.42,Chinese,,0,0,0,,但是我们可以创建 pthread_once_t 类型的变量并将其初始化为这个特殊的 pthreads 值
Dialogue: 0,0:38:31.78,0:38:36.98,English,,0,0,0,,Which is sort of like the pthreads uninitialized value
Dialogue: 0,0:38:31.78,0:38:36.98,Chinese,,0,0,0,,这有点像 pthreads 未初始化的值
Dialogue: 0,0:38:37.04,0:38:41.04,English,,0,0,0,,So this is a value that pthreads knows about that indicates that
Dialogue: 0,0:38:37.04,0:38:41.04,Chinese,,0,0,0,,所以这是 pthreads 知道的
Dialogue: 0,0:38:41.90,0:38:45.88,English,,0,0,0,,That this variable wants hasn't been initialized
Dialogue: 0,0:38:41.90,0:38:45.88,Chinese,,0,0,0,,表明这个变量还没有被初始化
Dialogue: 0,0:38:48.20,0:38:51.98,English,,0,0,0,,And then we call the Pthread_once function
Dialogue: 0,0:38:48.20,0:38:51.98,Chinese,,0,0,0,,然后我们调用 Pthread_once 函数
Dialogue: 0,0:38:52.78,0:38:58.50,English,,0,0,0,,Passing at this variable that we the address of this variable created that we created
Dialogue: 0,0:38:52.78,0:38:58.50,Chinese,,0,0,0,,传递这个变量的地址过去
Dialogue: 0,0:38:59.12,0:39:02.84,English,,0,0,0,,And the address of the function to call to initialize
Dialogue: 0,0:38:59.12,0:39:02.84,Chinese,,0,0,0,,以及初始化函数的地址
Dialogue: 0,0:39:04.68,0:39:12.72,English,,0,0,0,,Whatever it is we want to initialize in this case the echo_cnt variable
Dialogue: 0,0:39:04.68,0:39:12.72,Chinese,,0,0,0,,无论初始化是什么结果，这里都是 echo_cnt 的变量
Dialogue: 0,0:39:14.16,0:39:18.66,English,,0,0,0,,And so what this does every thread will call Pthread_once
Dialogue: 0,0:39:14.16,0:39:18.66,Chinese,,0,0,0,,所以每个线程都会调用 Pthread_once
Dialogue: 0,0:39:18.86,0:39:26.24,English,,0,0,0,,But only one thread will actually call the initialization function
Dialogue: 0,0:39:18.86,0:39:26.24,Chinese,,0,0,0,,但实际上只有一个线程会调用初始化函数
Dialogue: 0,0:39:27.68,0:39:32.66,English,,0,0,0,,Only the very first thread that executes Pthread_once will we'll call it
Dialogue: 0,0:39:27.68,0:39:32.66,Chinese,,0,0,0,,只有第一个执行 Pthread_once 的线程才会调用它
Dialogue: 0,0:39:32.66,0:39:37.24,English,,0,0,0,,The other threads this Pthread_once call will be like a no op
Dialogue: 0,0:39:32.66,0:39:37.24,Chinese,,0,0,0,,其他线程调用 Pthread_once 不会执行初始化函数
Dialogue: 0,0:39:37.90,0:39:38.54,English,,0,0,0,,Yes question
Dialogue: 0,0:39:37.90,0:39:38.54,Chinese,,0,0,0,,是的请讲
Dialogue: 0,0:39:38.54,0:39:42.78,English,,0,0,0,,[student speaking]
Dialogue: 0,0:39:38.54,0:39:42.78,Chinese,,0,0,0,,【同学提问】
Dialogue: 0,0:39:42.80,0:39:43.88,English,,0,0,0,,Well that's the other option
Dialogue: 0,0:39:42.80,0:39:43.88,Chinese,,0,0,0,,那是另一种选择
Dialogue: 0,0:39:44.66,0:39:47.88,English,,0,0,0,,So the advantage of this is that
Dialogue: 0,0:39:44.66,0:39:47.88,Chinese,,0,0,0,,所以这样做的好处是
Dialogue: 0,0:39:50.46,0:39:57.06,English,,0,0,0,,You can...I guess the advantage is I don't know that it's just another way you can do it
Dialogue: 0,0:39:50.46,0:39:57.06,Chinese,,0,0,0,,你可以 ...... 我猜优点是......我不知道，这只是你能做到的另一种方式
Dialogue: 0,0:39:58.64,0:40:02.96,English,,0,0,0,,You...I guess it avoids having to do it in the master thread that
Dialogue: 0,0:39:58.64,0:40:02.96,Chinese,,0,0,0,,你 ... 我想它避免了必须在主线程中这样做
Dialogue: 0,0:40:03.20,0:40:08.24,English,,0,0,0,,You can make your...you can make this package sort of self-contained right that
Dialogue: 0,0:40:03.20,0:40:08.24,Chinese,,0,0,0,,你可以让你 ... 你可以使这个包装成为一种独立的权利
Dialogue: 0,0:40:08.50,0:40:11.20,English,,0,0,0,,You're not really counting on the master doing anything
Dialogue: 0,0:40:08.50,0:40:11.20,Chinese,,0,0,0,,你并不是指望主线程做任何事情
Dialogue: 0,0:40:12.54,0:40:17.94,English,,0,0,0,,But yeah that's the other way we could have done it so I just wanted to show you this other technique
Dialogue: 0,0:40:12.54,0:40:17.94,Chinese,,0,0,0,,但是，这是我们可以做到的另一种方式所以我只想向你展示这种其他技术
Dialogue: 0,0:40:19.62,0:40:26.14,English,,0,0,0,,Okay so once we initialize...once we once some thread calls the init_echo_cnt
Dialogue: 0,0:40:19.62,0:40:26.14,Chinese,,0,0,0,,好的，一旦我们初始化 ......  某个线程调用 init_echo_cnt
Dialogue: 0,0:40:28.46,0:40:30.26,English,,0,0,0,,Then we initialize the Rio package
Dialogue: 0,0:40:28.46,0:40:30.26,Chinese,,0,0,0,,然后我们初始化 Rio 包
Dialogue: 0,0:40:32.00,0:40:34.98,English,,0,0,0,,For all of our accesses on this connected descriptor
Dialogue: 0,0:40:32.00,0:40:34.98,Chinese,,0,0,0,,对于此连接描述符的所有访问
Dialogue: 0,0:40:36.42,0:40:40.48,English,,0,0,0,,And then we repeatedly read a line of text from the client
Dialogue: 0,0:40:36.42,0:40:40.48,Chinese,,0,0,0,,然后我们反复读取客户端的一行文本
Dialogue: 0,0:40:42.26,0:40:44.22,English,,0,0,0,,Okay and then
Dialogue: 0,0:40:42.26,0:40:44.22,Chinese,,0,0,0,,好的，然后
Dialogue: 0,0:40:45.78,0:40:50.48,English,,0,0,0,,In a protected way we increment byte_cnt with the number of bytes that
Dialogue: 0,0:40:45.78,0:40:50.48,Chinese,,0,0,0,,我们使用互斥访问的方式保护 byte_count 的增长
Dialogue: 0,0:40:50.54,0:40:56.28,English,,0,0,0,,We received  from the client which is returned by this Rio_readlineb function
Dialogue: 0,0:40:50.54,0:40:56.28,Chinese,,0,0,0,,我们从函数 Rio_readlineb 的返回中获取客户端的内容
Dialogue: 0,0:40:57.68,0:41:00.90,English,,0,0,0,,And then we print a little message just to sort of keep track
Dialogue: 0,0:40:57.68,0:41:00.90,Chinese,,0,0,0,,然后我们打印一条消息，只是为了跟踪
Dialogue: 0,0:41:01.04,0:41:04.40,English,,0,0,0,,So we can see keep track of our running total
Dialogue: 0,0:41:01.04,0:41:04.40,Chinese,,0,0,0,,所以我们可以跟踪我们的运行总量
Dialogue: 0,0:41:04.98,0:41:09.42,English,,0,0,0,,And then we release the mutex on this on the byte_cnt the global byte_cnt variable
Dialogue: 0,0:41:04.98,0:41:09.42,Chinese,,0,0,0,,然后我们释放全局变量 byte_cnt 上的互斥锁
Dialogue: 0,0:41:09.74,0:41:12.46,English,,0,0,0,,And then we echo that line back to the client
Dialogue: 0,0:41:09.74,0:41:12.46,Chinese,,0,0,0,,然后我们将该行回传给客户端
Dialogue: 0,0:41:15.54,0:41:16.62,English,,0,0,0,,Okay so any questions about that
Dialogue: 0,0:41:15.54,0:41:16.62,Chinese,,0,0,0,,大家对此有什么问题吗
Dialogue: 0,0:41:18.00,0:41:18.62,English,,0,0,0,,Yes question
Dialogue: 0,0:41:18.00,0:41:18.62,Chinese,,0,0,0,,是的请讲
Dialogue: 0,0:41:18.62,0:41:28.26,English,,0,0,0,,[student speaking]
Dialogue: 0,0:41:18.62,0:41:28.26,Chinese,,0,0,0,,【同学提问】
Dialogue: 0,0:41:28.28,0:41:34.58,English,,0,0,0,,Okay the question is the line that declares the static variable once
Dialogue: 0,0:41:28.28,0:41:34.58,Chinese,,0,0,0,,问题是声明静态变量 once
Dialogue: 0,0:41:34.88,0:41:41.44,English,,0,0,0,,It only be executed the first time a thread executes that statement
Dialogue: 0,0:41:34.88,0:41:41.44,Chinese,,0,0,0,,它只会被第一个执行到这里的线程执行一次
Dialogue: 0,0:41:41.84,0:41:46.62,English,,0,0,0,,No it's so the answer is no every thread will define this variable
Dialogue: 0,0:41:41.84,0:41:46.62,Chinese,,0,0,0,,不，所以答案是不，每个线程都会定义这个变量
Dialogue: 0,0:41:47.00,0:41:53.28,English,,0,0,0,,And assign it this to this pthread once value
Dialogue: 0,0:41:47.00,0:41:53.28,Chinese,,0,0,0,,并将其分配给此 pthread 一次值
Dialogue: 0,0:41:53.94,0:41:58.66,English,,0,0,0,,Okay what will only happen once is the call to a init_echo_cnt
Dialogue: 0,0:41:53.94,0:41:58.66,Chinese,,0,0,0,,只有一次调用 init_echo_cnt 才会发生
Dialogue: 0,0:41:59.42,0:42:05.36,English,,0,0,0,,Okay so the first thread that executes this Pthread_once call
Dialogue: 0,0:41:59.42,0:42:05.36,Chinese,,0,0,0,,这是第一个线程调用 Pthread_once
Dialogue: 0,0:42:05.92,0:42:08.20,English,,0,0,0,,Will actually call an init_echo_cnt
Dialogue: 0,0:42:05.92,0:42:08.20,Chinese,,0,0,0,,实际上会调用 init_echo_cnt
Dialogue: 0,0:42:09.44,0:42:13.58,English,,0,0,0,,Every other thread every subsequent thread will not call it it'll be like a no op
Dialogue: 0,0:42:09.44,0:42:13.58,Chinese,,0,0,0,,每个后续线程的每个其他线程都不会调用它，它像是透明的一样
Dialogue: 0,0:42:14.84,0:42:18.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:42:14.84,0:42:18.54,Chinese,,0,0,0,,【同学提问】
Dialogue: 0,0:42:18.54,0:42:20.80,English,,0,0,0,,Yeah uses the ones it's just an opaque
Dialogue: 0,0:42:18.54,0:42:20.80,Chinese,,0,0,0,,是啊，只是用一次，就是不透明的
Dialogue: 0,0:42:20.86,0:42:33.44,English,,0,0,0,,[student speaking]
Dialogue: 0,0:42:20.86,0:42:33.44,Chinese,,0,0,0,,【同学提问】
Dialogue: 0,0:42:33.46,0:42:39.54,English,,0,0,0,,Yeah somehow it will but somehow the pthread wants is keeping track that it's executed
Dialogue: 0,0:42:33.46,0:42:39.54,Chinese,,0,0,0,,是的，它会以某种方式，但 pthread 想要的是跟踪它的执行情况
Dialogue: 0,0:42:41.60,0:42:44.58,English,,0,0,0,,Okay so I I'm really not sure how its implemented
Dialogue: 0,0:42:41.60,0:42:44.58,Chinese,,0,0,0,,所以我真的不确定它是如何实现的
Dialogue: 0,0:42:45.18,0:42:48.54,English,,0,0,0,,Okay so somehow Pthread_once
Dialogue: 0,0:42:45.18,0:42:48.54,Chinese,,0,0,0,,好吧，不知怎的， Pthread_once
Dialogue: 0,0:42:49.64,0:42:51.12,English,,0,0,0,,Yeah I guess every you know this
Dialogue: 0,0:42:49.64,0:42:51.12,Chinese,,0,0,0,,我认为......
Dialogue: 0,0:42:52.02,0:42:54.70,English,,0,0,0,,I mean this is just the C declaration right so there's no
Dialogue: 0,0:42:52.02,0:42:54.70,Chinese,,0,0,0,,我的意思是这只是 C 声明，所以没有
Dialogue: 0,0:42:55.14,0:42:59.00,English,,0,0,0,,The pthreads has no control over declarations right
Dialogue: 0,0:42:55.14,0:42:59.00,Chinese,,0,0,0,, pthreads 无法控制声明
Dialogue: 0,0:42:59.54,0:43:06.92,English,,0,0,0,,So every thread will get...every thread will sort of update this static variable
Dialogue: 0,0:42:59.54,0:43:06.92,Chinese,,0,0,0,,所以每个线程都会得到 ...... 每个线程都会更新这个静态变量
Dialogue: 0,0:43:08.72,0:43:10.76,English,,0,0,0,,And you're wright if the first thread
Dialogue: 0,0:43:08.72,0:43:10.76,Chinese,,0,0,0,,你是对的，如果第一个线程
Dialogue: 0,0:43:14.68,0:43:18.18,English,,0,0,0,,The second thread would overwrite this value again
Dialogue: 0,0:43:14.68,0:43:18.18,Chinese,,0,0,0,,第二个线程将再次覆盖此值
Dialogue: 0,0:43:19.02,0:43:23.50,English,,0,0,0,,But somehow Pthread_once can keeps track of that
Dialogue: 0,0:43:19.02,0:43:23.50,Chinese,,0,0,0,,但不知何故， Pthread_once 可以跟踪它
Dialogue: 0,0:43:23.74,0:43:27.10,English,,0,0,0,,Okay in some way that I'm not sure about how that works
Dialogue: 0,0:43:23.74,0:43:27.10,Chinese,,0,0,0,,在某种程度上，我不确定它是如何工作的
Dialogue: 0,0:43:28.56,0:43:31.62,English,,0,0,0,,But this is the way you get that behavior
Dialogue: 0,0:43:28.56,0:43:31.62,Chinese,,0,0,0,,但这就是你获得这种行为的方式
Dialogue: 0,0:43:36.84,0:43:43.44,English,,0,0,0,,Can others there's some other issues around synchronizing threads sort of correctness issues that we have to be aware of
Dialogue: 0,0:43:36.84,0:43:43.44,Chinese,,0,0,0,,其他人可以围绕同步线程来解决我们必须注意的正确性问题
Dialogue: 0,0:43:45.66,0:43:51.56,English,,0,0,0,,And so I hope you're sort of getting the sense that this threaded programming is kind of a tricky business right
Dialogue: 0,0:43:45.66,0:43:51.56,Chinese,,0,0,0,,因此，我希望你能够理解这种线程编程是一项棘手的业务
Dialogue: 0,0:43:52.36,0:43:57.50,English,,0,0,0,,And so one issue that we always have to be aware of is this idea called thread safety
Dialogue: 0,0:43:52.36,0:43:57.50,Chinese,,0,0,0,,因此，我们始终需要注意的一个问题就是「线程安全」
Dialogue: 0,0:43:58.68,0:44:06.30,English,,0,0,0,,So in general a thread routine should only call functions that are thread safe
Dialogue: 0,0:43:58.68,0:44:06.30,Chinese,,0,0,0,,所以通常一个线程例程应该只调用线程安全的函数
Dialogue: 0,0:44:06.76,0:44:08.66,English,,0,0,0,,That have this property called thread safety
Dialogue: 0,0:44:06.76,0:44:08.66,Chinese,,0,0,0,,这个属性叫做线程安全
Dialogue: 0,0:44:09.74,0:44:11.90,English,,0,0,0,,Okay and a function is thread safe
Dialogue: 0,0:44:09.74,0:44:11.90,Chinese,,0,0,0,,函数是线程安全的是指
Dialogue: 0,0:44:13.00,0:44:18.76,English,,0,0,0,,If and only if that function can be invoked by multiple threads at the same time
Dialogue: 0,0:44:13.00,0:44:18.76,Chinese,,0,0,0,,当且仅当该函数可以被多个线程可以同时调用
Dialogue: 0,0:44:19.76,0:44:22.20,English,,0,0,0,,Okay so if we have a function f
Dialogue: 0,0:44:19.76,0:44:22.20,Chinese,,0,0,0,,如果我们有一个函数 f
Dialogue: 0,0:44:24.42,0:44:29.10,English,,0,0,0,,Its thread safe if and only if its execution can be interleaved by multiple threads
Dialogue: 0,0:44:24.42,0:44:29.10,Chinese,,0,0,0,,当且仅当这个线程可以被多个线程交错执行，就是线程安全
Dialogue: 0,0:44:34.70,0:44:38.96,English,,0,0,0,,And so we can identify a four different classes of thread-unsafe functions
Dialogue: 0,0:44:34.70,0:44:38.96,Chinese,,0,0,0,,因此我们可以识别出四种不同类型的线程不安全函数
Dialogue: 0,0:44:39.86,0:44:46.06,English,,0,0,0,,So one classes is the functions that fail to protect shared variables with mutexes
Dialogue: 0,0:44:39.86,0:44:46.06,Chinese,,0,0,0,,一个类是无法使用互斥锁保护共享变量的函数
Dialogue: 0,0:44:48.22,0:44:50.06,English,,0,0,0,,Okay so we've already seen that with bad count
Dialogue: 0,0:44:48.22,0:44:50.06,Chinese,,0,0,0,,我们已经看到了数字不对的情况
Dialogue: 0,0:44:50.66,0:44:56.06,English,,0,0,0,,That was an example of a thread-unsafe that main routine was an example of an unsafe thread function
Dialogue: 0,0:44:50.66,0:44:56.06,Chinese,,0,0,0,,这是一个线程不安全的例子，主例程是一个不安全的线程函数的例子
Dialogue: 0,0:44:58.66,0:45:02.14,English,,0,0,0,,Or no the thread function was an example of an unsafe thread function
Dialogue: 0,0:44:58.66,0:45:02.14,Chinese,,0,0,0,,或者没有线程函数是不安全线程函数的示例
Dialogue: 0,0:45:02.40,0:45:06.24,English,,0,0,0,,Because it didn't protect the act the update of the count variable
Dialogue: 0,0:45:02.40,0:45:06.24,Chinese,,0,0,0,,因为它没有保护计数变量的更新
Dialogue: 0,0:45:09.04,0:45:16.90,English,,0,0,0,,Another class of functions that a thread-unsafe is are those functions that keep track of state across multiple invocations
Dialogue: 0,0:45:09.04,0:45:16.90,Chinese,,0,0,0,,另一类线程不安全的函数是 那些在多次调用中跟踪状态的函数
Dialogue: 0,0:45:17.74,0:45:26.14,English,,0,0,0,,So if they're storing state in some global variable,private or public global variable, that's thread unsafe
Dialogue: 0,0:45:17.74,0:45:26.14,Chinese,,0,0,0,,因此，如果他们将状态存储在某个全局变量，私有或公共全局变量中，则该线程不安全
Dialogue: 0,0:45:26.80,0:45:30.94,English,,0,0,0,,Because multiple threads will be accessing that state
Dialogue: 0,0:45:26.80,0:45:30.94,Chinese,,0,0,0,,因为多个线程将访问该状态
Dialogue: 0,0:45:33.44,0:45:38.74,English,,0,0,0,,Another way,another kind of thread-unsafe function or functions that return a pointer to a static variable
Dialogue: 0,0:45:33.44,0:45:38.74,Chinese,,0,0,0,,另一类线程不安全的函数是返回指向静态变量的指针的函数
Dialogue: 0,0:45:40.22,0:45:43.34,English,,0,0,0,,So there's a number of functions in the standard C library
Dialogue: 0,0:45:40.22,0:45:43.34,Chinese,,0,0,0,,因此标准 C 库中有许多函数
Dialogue: 0,0:45:44.04,0:45:47.52,English,,0,0,0,,That were written before threads or even on anybody's radar
Dialogue: 0,0:45:44.04,0:45:47.52,Chinese,,0,0,0,,这是在线程之前写的，没有引起任何人的注意
Dialogue: 0,0:45:48.86,0:45:53.06,English,,0,0,0,,And so an example is the C time function
Dialogue: 0,0:45:48.86,0:45:53.06,Chinese,,0,0,0,,举一个 C 语言时间函数的例子
Dialogue: 0,0:45:53.82,0:45:57.94,English,,0,0,0,,Which takes as an argument a time struct,a binary time struct
Dialogue: 0,0:45:53.82,0:45:57.94,Chinese,,0,0,0,,它接收二进制时间结构作为参数
Dialogue: 0,0:45:58.92,0:46:02.52,English,,0,0,0,,And returns a pointer to a string date and time string
Dialogue: 0,0:45:58.92,0:46:02.52,Chinese,,0,0,0,,并返回指向字符串日期和时间字符串的指针
Dialogue: 0,0:46:04.18,0:46:07.46,English,,0,0,0,,But the address in that pointer is always the same
Dialogue: 0,0:46:04.18,0:46:07.46,Chinese,,0,0,0,,但该指针中的地址始终相同
Dialogue: 0,0:46:07.62,0:46:11.52,English,,0,0,0,,Right so the this function is defining some kind of static variable
Dialogue: 0,0:46:07.62,0:46:11.52,Chinese,,0,0,0,,所以这个函数定义了某种静态变量
Dialogue: 0,0:46:12.48,0:46:20.20,English,,0,0,0,,And it's always returned and then it's converting that the binary time struct into a string
Dialogue: 0,0:46:12.48,0:46:20.20,Chinese,,0,0,0,,它总是被返回，然后它将二进制时间结构转换成一个字符串
Dialogue: 0,0:46:20.20,0:46:24.22,English,,0,0,0,,That's always at the same location and it's returning the address of that string
Dialogue: 0,0:46:20.20,0:46:24.22,Chinese,,0,0,0,,始终在同一个位置，并返回该字符串的地址
Dialogue: 0,0:46:24.86,0:46:27.64,English,,0,0,0,,So every invocation returns the exact same address
Dialogue: 0,0:46:24.86,0:46:27.64,Chinese,,0,0,0,,所以每次调用都会返回完全相同的地址
Dialogue: 0,0:46:28.52,0:46:30.74,English,,0,0,0,,But with different content at that address
Dialogue: 0,0:46:28.52,0:46:30.74,Chinese,,0,0,0,,但是在该地址有不同的内容
Dialogue: 0,0:46:31.78,0:46:34.00,English,,0,0,0,,Okay and this...you know they just...
Dialogue: 0,0:46:31.78,0:46:34.00,Chinese,,0,0,0,,这 ...... 你知道他们只是 ......
Dialogue: 0,0:46:34.34,0:46:37.92,English,,0,0,0,,They didn't realize that this was a bad thing to do for threaded programs
Dialogue: 0,0:46:34.34,0:46:37.92,Chinese,,0,0,0,, 他们没有意识到这对线程编程来说是灾难级的
Dialogue: 0,0:46:37.92,0:46:40.66,English,,0,0,0,,Because nobody was writing threaded programs at the time
Dialogue: 0,0:46:37.92,0:46:40.66,Chinese,,0,0,0,,因为当时没有人编写线程程序
Dialogue: 0,0:46:42.26,0:46:46.82,English,,0,0,0,,And then obviously any function that calls and thread-unsafe function is thread unsafe
Dialogue: 0,0:46:42.26,0:46:46.82,Chinese,,0,0,0,,然后显然任何调用线程不安全的函数都是线程不安全的
Dialogue: 0,0:46:47.94,0:46:51.50,English,,0,0,0,,Okay so let's look at these different classes of functions
Dialogue: 0,0:46:47.94,0:46:51.50,Chinese,,0,0,0,,让我们来看看这些不同类别的函数
Dialogue: 0,0:46:52.14,0:46:56.32,English,,0,0,0,,Okay so the class one functions fail to protect shared variables
Dialogue: 0,0:46:52.14,0:46:56.32,Chinese,,0,0,0,,第一类函数无法保护共享变量
Dialogue: 0,0:46:57.18,0:47:04.90,English,,0,0,0,,And so the fix as we've seen is to use P and V to guarantee mutually exclusive access and thereby protect the accesses to the variable
Dialogue: 0,0:46:57.18,0:47:04.90,Chinese,,0,0,0,,因此，如我们所见修复这类问题是使用 P 和 V 来保证互斥访问，从而保护对变量的访问
Dialogue: 0,0:47:05.02,0:47:07.56,English,,0,0,0,,So we saw this with that good count program
Dialogue: 0,0:47:05.02,0:47:07.56,Chinese,,0,0,0,,我们能在 goodcnt.c 中看到这种做法
Dialogue: 0,0:47:08.50,0:47:14.18,English,,0,0,0,,And then the problem is it also as we saw with goodcnt is that the synchronization operations can be slow
Dialogue: 0,0:47:08.50,0:47:14.18,Chinese,,0,0,0,,然后问题是，正如我们在 goodcnt 中看到的那样，同步操作可能很慢
Dialogue: 0,0:47:14.20,0:47:15.75,English,,0,0,0,,So if they're in a tight inner loop
Dialogue: 0,0:47:14.20,0:47:15.75,Chinese,,0,0,0,,所以，如果他们处于紧密的内循环中
Dialogue: 0,0:47:16.38,0:47:18.68,English,,0,0,0,,It can really slow your program down
Dialogue: 0,0:47:16.38,0:47:18.68,Chinese,,0,0,0,,它可以真正减慢你的程序
Dialogue: 0,0:47:21.42,0:47:25.32,English,,0,0,0,,Okay the class 2 thread-unsafe functions rely on
Dialogue: 0,0:47:21.42,0:47:25.32,Chinese,,0,0,0,,第二类线程不安全的函数是
Dialogue: 0,0:47:25.66,0:47:29.56,English,,0,0,0,,Some kind of persistent state across invocations of that function
Dialogue: 0,0:47:25.66,0:47:29.56,Chinese,,0,0,0,,依赖调用函数维持某种状态
Dialogue: 0,0:47:30.32,0:47:35.28,English,,0,0,0,,Okay so the classic example is the lib.c rand function
Dialogue: 0,0:47:30.32,0:47:35.28,Chinese,,0,0,0,,经典的例子是 lib.c rand 函数
Dialogue: 0,0:47:36.54,0:47:43.68,English,,0,0,0,,Whose in an implementation of which is I took from the k in our book
Dialogue: 0,0:47:36.54,0:47:43.68,Chinese,,0,0,0,,课本中有它的具体实现
Dialogue: 0,0:47:45.82,0:47:52.36,English,,0,0,0,,So this rand,this is a pseudo-random number generator
Dialogue: 0,0:47:45.82,0:47:52.36,Chinese,,0,0,0,,这个 rand 函数是一个伪随机数生成器
Dialogue: 0,0:47:53.22,0:47:55.32,English,,0,0,0,,A pseudo random in the sense that
Dialogue: 0,0:47:53.22,0:47:55.32,Chinese,,0,0,0,,在某种意义上的伪随机
Dialogue: 0,0:47:56.08,0:48:00.84,English,,0,0,0,,If you give it the same key it'll return the same sequence of values okay
Dialogue: 0,0:47:56.08,0:48:00.84,Chinese,,0,0,0,,如果你给它相同的键，它将返回相同的值序列
Dialogue: 0,0:48:01.60,0:48:06.60,English,,0,0,0,,So this is kind of nice because it allows when you're testing it allows repeatability
Dialogue: 0,0:48:01.60,0:48:06.60,Chinese,,0,0,0,,所以这很好，因为它允许在你测试它时允许重复
Dialogue: 0,0:48:07.38,0:48:12.22,English,,0,0,0,,So every time you call it,if you call it with the same seed you're guaranteed you'll get the same results
Dialogue: 0,0:48:07.38,0:48:12.22,Chinese,,0,0,0,,因此，每次你调用它，传递相同的参数，保证你将得到相同的结果
Dialogue: 0,0:48:13.48,0:48:14.86,English,,0,0,0,,And the way this is implemented
Dialogue: 0,0:48:13.48,0:48:14.86,Chinese,,0,0,0,,以及实施方式
Dialogue: 0,0:48:16.92,0:48:19.66,English,,0,0,0,,Is that there's at the seed
Dialogue: 0,0:48:16.92,0:48:19.66,Chinese,,0,0,0,,这就是种子吗？
Dialogue: 0,0:48:22.40,0:48:24.90,English,,0,0,0,,There's a seed variable called next
Dialogue: 0,0:48:22.40,0:48:24.90,Chinese,,0,0,0,,有一个名为 next 的种子变量
Dialogue: 0,0:48:25.44,0:48:28.60,English,,0,0,0,,Which is used in each iteration of the random number generator
Dialogue: 0,0:48:25.44,0:48:28.60,Chinese,,0,0,0,,在随机数生成器的每次迭代中使用哪个
Dialogue: 0,0:48:28.68,0:48:33.82,English,,0,0,0,,And it's defined as a global private
Dialogue: 0,0:48:28.68,0:48:33.82,Chinese,,0,0,0,,它被定义为全局变量
Dialogue: 0,0:48:33.96,0:48:38.58,English,,0,0,0,,So static makes it private,so it's not accessible to programs that are calling
Dialogue: 0,0:48:33.96,0:48:38.58,Chinese,,0,0,0,,因此静态使其成为私有的，因此调用的程序无法访问它
Dialogue: 0,0:48:39.22,0:48:42.92,English,,0,0,0,,The rand function but it's used by the rand function
Dialogue: 0,0:48:39.22,0:48:42.92,Chinese,,0,0,0,, rand 函数但它由 rand 函数使用
Dialogue: 0,0:48:43.70,0:48:45.94,English,,0,0,0,,And so this variable is initialized to 1
Dialogue: 0,0:48:43.70,0:48:45.94,Chinese,,0,0,0,,所以这个变量初始化为 1
Dialogue: 0,0:48:48.20,0:48:52.76,English,,0,0,0,,There's a function called srand which allows the user to set the seed value
Dialogue: 0,0:48:48.20,0:48:52.76,Chinese,,0,0,0,,有一个名为 srand 的函数允许用户设置种子值
Dialogue: 0,0:48:52.82,0:48:55.64,English,,0,0,0,,So the default seed value is 1
Dialogue: 0,0:48:52.82,0:48:55.64,Chinese,,0,0,0,,因此默认种子值为 1
Dialogue: 0,0:48:56.48,0:48:59.48,English,,0,0,0,,But if the user calls srand they can pass in a seed
Dialogue: 0,0:48:56.48,0:48:59.48,Chinese,,0,0,0,,但是如果用户调用 srand ，他们可以传入种子
Dialogue: 0,0:48:59.86,0:49:05.34,English,,0,0,0,,Which will be then...which will be...which is just would assign to this next variable
Dialogue: 0,0:48:59.86,0:49:05.34,Chinese,,0,0,0,,那将是 ... 将是 ...... 这将分配给下一个变量
Dialogue: 0,0:49:06.78,0:49:08.58,English,,0,0,0,,And then each iteration of rand
Dialogue: 0,0:49:06.78,0:49:08.58,Chinese,,0,0,0,,然后是 rand 的每次迭代
Dialogue: 0,0:49:10.48,0:49:12.52,English,,0,0,0,,And does an operation on the seed
Dialogue: 0,0:49:10.48,0:49:12.52,Chinese,,0,0,0,,并对种子进行操作
Dialogue: 0,0:49:13.50,0:49:21.54,English,,0,0,0,,So it takes that the next value that's going to be used is a property of the previous value,the function of the previous value
Dialogue: 0,0:49:13.50,0:49:21.54,Chinese,,0,0,0,,因此，next 的值是根据前一个值的函数的值来计算的
Dialogue: 0,0:49:22.58,0:49:24.74,English,,0,0,0,,And then it returns a pseudo-random number
Dialogue: 0,0:49:22.58,0:49:24.74,Chinese,,0,0,0,,然后它返回一个伪随机数
Dialogue: 0,0:49:25.08,0:49:26.88,English,,0,0,0,,That's a function of that next value
Dialogue: 0,0:49:25.08,0:49:26.88,Chinese,,0,0,0,,这是这个函数中的 next 值
Dialogue: 0,0:49:28.60,0:49:32.74,English,,0,0,0,,Okay so it's relying on this each iteration each time you call rand
Dialogue: 0,0:49:28.60,0:49:32.74,Chinese,,0,0,0,,所以 next 的值和 rand 的调用有关
Dialogue: 0,0:49:33.16,0:49:39.48,English,,0,0,0,,You're relying on the this next value that was computed by the previous time that you called rand
Dialogue: 0,0:49:33.16,0:49:39.48,Chinese,,0,0,0,, next 的值是上一次调用 rand 得到的（next）值计算而来
Dialogue: 0,0:49:41.28,0:49:47.46,English,,0,0,0,,Okay now this is perfectly fine and there's no problem with this In a non-threaded situation
Dialogue: 0,0:49:41.28,0:49:47.46,Chinese,,0,0,0,,这在非多线程的情况下没问题
Dialogue: 0,0:49:48.26,0:49:50.56,English,,0,0,0,,But what happens if multiple threads now
Dialogue: 0,0:49:48.26,0:49:50.56,Chinese,,0,0,0,,但是如果多线程会发生什么
Dialogue: 0,0:49:51.44,0:49:53.06,English,,0,0,0,,So suppose you have multiple threads
Dialogue: 0,0:49:51.44,0:49:53.06,Chinese,,0,0,0,,假设你有多个线程
Dialogue: 0,0:49:54.06,0:50:01.08,English,,0,0,0,,And they're each calling this rand function sort of interleaving calls to rand
Dialogue: 0,0:49:54.06,0:50:01.08,Chinese,,0,0,0,,并且每个线程都调用这个 rand 函数，对 rand 进行交错调用
Dialogue: 0,0:50:02.52,0:50:07.94,English,,0,0,0,,Okay the fact that rand is relying on the this previous state
Dialogue: 0,0:50:02.52,0:50:07.94,Chinese,,0,0,0,,现实是 rand 依赖之前的状态
Dialogue: 0,0:50:10.40,0:50:14.26,English,,0,0,0,,If multiple threads are calling rand it's going to break the pseudo-random property
Dialogue: 0,0:50:10.40,0:50:14.26,Chinese,,0,0,0,,如果多个线程调用 rand ，那么伪随机属性将会被破坏
Dialogue: 0,0:50:14.58,0:50:19.78,English,,0,0,0,,So each thread that the random numbers that each thread gets back
Dialogue: 0,0:50:14.58,0:50:19.78,Chinese,,0,0,0,,所以每个线程得到的随机数
Dialogue: 0,0:50:19.78,0:50:26.04,English,,0,0,0,,Are not only a function of the previous the seed from the previous time that thread called the function
Dialogue: 0,0:50:19.78,0:50:26.04,Chinese,,0,0,0,,不仅和该线程上一次调用函数生成的种子有关
Dialogue: 0,0:50:26.04,0:50:31.98,English,,0,0,0,,But also a function of the other threads that are calling it right
Dialogue: 0,0:50:26.04,0:50:31.98,Chinese,,0,0,0,,也和别的线程也调用该函数（rand）有关
Dialogue: 0,0:50:32.90,0:50:38.40,English,,0,0,0,,So if a particular thread calls this random number generator multiple times
Dialogue: 0,0:50:32.90,0:50:38.40,Chinese,,0,0,0,,因此，如果特定线程多次调用此随机数生成器
Dialogue: 0,0:50:39.28,0:50:44.72,English,,0,0,0,,It potentially won't see the same sequence of pseudo-random numbers because other threads will be jumping in
Dialogue: 0,0:50:39.28,0:50:44.72,Chinese,,0,0,0,,它可能不会看到相同的伪随机数序列，因为还有其他线程加入进来了
Dialogue: 0,0:50:45.42,0:50:46.78,English,,0,0,0,,Okay and
Dialogue: 0,0:50:45.42,0:50:46.78,Chinese,,0,0,0,,好的
Dialogue: 0,0:50:48.88,0:50:55.08,English,,0,0,0,,Okay so it's not incorrect and that the program will fail
Dialogue: 0,0:50:48.88,0:50:55.08,Chinese,,0,0,0,,虽然不会出错，但是程序还是问题
Dialogue: 0,0:50:55.34,0:51:01.22,English,,0,0,0,,But if the program is counting on the pseudo random property then it creates a problem okay
Dialogue: 0,0:50:55.34,0:51:01.22,Chinese,,0,0,0,,如果指望程序的伪随机属性，那么它就会产生问题
Dialogue: 0,0:51:02.66,0:51:07.66,English,,0,0,0,,So the solution to this is to rewrite rand
Dialogue: 0,0:51:02.66,0:51:07.66,Chinese,,0,0,0,,所以解决这个问题的方法是重写 rand
Dialogue: 0,0:51:08.80,0:51:15.16,English,,0,0,0,,And require it to require the caller to keep track of this next variable
Dialogue: 0,0:51:08.80,0:51:15.16,Chinese,,0,0,0,,并要求调用者跟踪 next 变量的值
Dialogue: 0,0:51:15.70,0:51:21.68,English,,0,0,0,,Okay so each caller will keep its own local copy of next and it will pass in a pointer to rand
Dialogue: 0,0:51:15.70,0:51:21.68,Chinese,,0,0,0,,所以每个调用者都会保留自己的 next 的本地副本，并将指针传递给 rand
Dialogue: 0,0:51:22.84,0:51:28.28,English,,0,0,0,,rand we'll compute that value so now this will be updating state in the calling thread
Dialogue: 0,0:51:22.84,0:51:28.28,Chinese,,0,0,0,, rand 会计算这个值，并保存在调用线程中
Dialogue: 0,0:51:28.30,0:51:32.66,English,,0,0,0,,But this is local state on the thread stack okay
Dialogue: 0,0:51:28.30,0:51:32.66,Chinese,,0,0,0,,这是线程堆栈上的状态
Dialogue: 0,0:51:32.82,0:51:37.16,English,,0,0,0,,So every thread will have its own copy of next
Dialogue: 0,0:51:32.82,0:51:37.16,Chinese,,0,0,0,,所以每个线程都有自己的 next
Dialogue: 0,0:51:40.14,0:51:44.32,English,,0,0,0,,So we...but we have to create a new function and what we'll call it underscore r
Dialogue: 0,0:51:40.14,0:51:44.32,Chinese,,0,0,0,,所以我们创建一个新函数，rand_r
Dialogue: 0,0:51:44.76,0:51:48.54,English,,0,0,0,,The stands for reentrant which is a property we'll look at in just a second
Dialogue: 0,0:51:44.76,0:51:48.54,Chinese,,0,0,0,,_r 表示「可重入」，一会我们会讲到它的属性
Dialogue: 0,0:51:50.56,0:51:52.08,English,,0,0,0,,But it's more work for the programmer
Dialogue: 0,0:51:50.56,0:51:52.08,Chinese,,0,0,0,,但这会增加程序员的工作
Dialogue: 0,0:51:52.08,0:51:58.10,English,,0,0,0,,Because now the programmer has to maintain this sort of this next value okay
Dialogue: 0,0:51:52.08,0:51:58.10,Chinese,,0,0,0,,因为现在程序员必须维护 next 的值
Dialogue: 0,0:52:01.68,0:52:05.08,English,,0,0,0,,Okay another way that threads the functions are unsafe
Dialogue: 0,0:52:01.68,0:52:05.08,Chinese,,0,0,0,,下面来看另一种线程不安全的函数
Dialogue: 0,0:52:06.08,0:52:14.52,English,,0,0,0,,are these functions that always retain a return a pointer(to some global) to the same global variable
Dialogue: 0,0:52:06.08,0:52:14.52,Chinese,,0,0,0,,这类函数总是返回指向同一个全局变量的指针
Dialogue: 0,0:52:15.02,0:52:17.18,English,,0,0,0,,Typically it's a static variable
Dialogue: 0,0:52:15.02,0:52:17.18,Chinese,,0,0,0,,通常是一个静态变量
Dialogue: 0,0:52:17.60,0:52:22.36,English,,0,0,0,,But they always return the same value each time the same address
Dialogue: 0,0:52:17.60,0:52:22.36,Chinese,,0,0,0,,它们每次总是返回相同的值（相同的地址）
Dialogue: 0,0:52:24.36,0:52:27.90,English,,0,0,0,,Okay so you can see this is similar to that race that we encountered before
Dialogue: 0,0:52:24.36,0:52:27.90,Chinese,,0,0,0,,你会发现这和之前我们讲过的竞赛模型类似
Dialogue: 0,0:52:28.20,0:52:32.64,English,,0,0,0,,Where we were passing the address of a connected file descriptor to a worker thread
Dialogue: 0,0:52:28.20,0:52:32.64,Chinese,,0,0,0,,我们将连接文件描述符的地址传递给工作线程的时候
Dialogue: 0,0:52:34.50,0:52:36.90,English,,0,0,0,,Okay so now we're creating a race so let's say one thread
Dialogue: 0,0:52:34.50,0:52:36.90,Chinese,,0,0,0,,现在我们创造一场比赛
Dialogue: 0,0:52:37.42,0:52:40.68,English,,0,0,0,,Let's say one thread calls this function so for example
Dialogue: 0,0:52:37.42,0:52:40.68,Chinese,,0,0,0,,假设一个线程调用此函数，例如
Dialogue: 0,0:52:41.66,0:52:46.06,English,,0,0,0,,ctime takes this this time struct as an argument
Dialogue: 0,0:52:41.66,0:52:46.06,Chinese,,0,0,0,, ctime 接收 timep 作为参数
Dialogue: 0,0:52:46.74,0:52:50.22,English,,0,0,0,,Okay which can correspond to an arbitrary time it could be the current time
Dialogue: 0,0:52:46.74,0:52:50.22,Chinese,,0,0,0,,它可以是任意时间，也可以是当前时间
Dialogue: 0,0:52:50.22,0:52:53.20,English,,0,0,0,,Or just some arbitrary time that the caller constructed
Dialogue: 0,0:52:50.22,0:52:53.20,Chinese,,0,0,0,,或者只是调用者构建的任意时间
Dialogue: 0,0:52:54.26,0:52:58.28,English,,0,0,0,,And it returns a pointer to a char*
Dialogue: 0,0:52:54.26,0:52:58.28,Chinese,,0,0,0,,它返回一个 char* 指针
Dialogue: 0,0:52:58.30,0:53:02.66,English,,0,0,0,,So it just returns a pointer to a string that represents the date and the time
Dialogue: 0,0:52:58.30,0:53:02.66,Chinese,,0,0,0,,所以它只返回一个指向字符串的指针，用来表示日期和时间
Dialogue: 0,0:53:02.76,0:53:09.16,English,,0,0,0,,Its own ascii string that represents the date and time
Dialogue: 0,0:53:02.76,0:53:09.16,Chinese,,0,0,0,,ascii 字符串表示的日期和时间
Dialogue: 0,0:53:12.58,0:53:19.34,English,,0,0,0,,But it's always returning a pointer to the same location in memory
Dialogue: 0,0:53:12.58,0:53:19.34,Chinese,,0,0,0,,但它始终返回指向内存中相同位置的指针
Dialogue: 0,0:53:21.98,0:53:26.02,English,,0,0,0,,Okay so you can see the problem if thread a calls this ctime function
Dialogue: 0,0:53:21.98,0:53:26.02,Chinese,,0,0,0,,这样你就能发现问题，如果线程 a 调用 ctime 函数
Dialogue: 0,0:53:27.20,0:53:29.42,English,,0,0,0,,With one...with one time struct
Dialogue: 0,0:53:27.20,0:53:29.42,Chinese,,0,0,0,,传递了一个时间参数
Dialogue: 0,0:53:30.30,0:53:35.98,English,,0,0,0,,It gets back a pointer to the character string corresponding to that time struct
Dialogue: 0,0:53:30.30,0:53:35.98,Chinese,,0,0,0,,它返回一个指向与该时间结构对应的字符串的指针
Dialogue: 0,0:53:37.04,0:53:45.06,English,,0,0,0,,But now let's say before thread a can use that Read that string another thread calls ctime
Dialogue: 0,0:53:37.04,0:53:45.06,Chinese,,0,0,0,,现在我们可以看到在线程 a 使用（读取字符串）它之前，另一个线程调用 ctime
Dialogue: 0,0:53:46.84,0:53:55.40,English,,0,0,0,,And that instance of ctime will overwrite that copy of the time string for that that thread a computed
Dialogue: 0,0:53:46.84,0:53:55.40,Chinese,,0,0,0,,并且这次 ctime 的调用将覆盖线程 a 计算的时间字符串
Dialogue: 0,0:53:56.34,0:54:00.26,English,,0,0,0,,So when thread a finally gets a chance to access that time string
Dialogue: 0,0:53:56.34,0:54:00.26,Chinese,,0,0,0,,所以当线程 a 最终有机会访问时间字符串时
Dialogue: 0,0:54:00.26,0:54:04.70,English,,0,0,0,,It's accessing thread b time string and not threat a time string
Dialogue: 0,0:54:00.26,0:54:04.70,Chinese,,0,0,0,,它得到的是线程 b 的时间字符串而不是线程 a 的
Dialogue: 0,0:54:06.08,0:54:10.38,English,,0,0,0,,Okay and it just depends if thread a can get to that and read that variable
Dialogue: 0,0:54:06.08,0:54:10.38,Chinese,,0,0,0,,要想线程 a 正常执行
Dialogue: 0,0:54:10.38,0:54:13.96,English,,0,0,0,,Before thread b over writes it then everything's fine
Dialogue: 0,0:54:10.38,0:54:13.96,Chinese,,0,0,0,,只能在线程 b 重写之前读取这个值
Dialogue: 0,0:54:14.58,0:54:18.34,English,,0,0,0,,And otherwise thread a accessing the wrong time string
Dialogue: 0,0:54:14.58,0:54:18.34,Chinese,,0,0,0,,否则线程 a 就会得到一个错误的时间字符串
Dialogue: 0,0:54:19.06,0:54:22.48,English,,0,0,0,,Okay so there's there's a couple of ways to fix this like
Dialogue: 0,0:54:19.06,0:54:22.48,Chinese,,0,0,0,,有几种方法可以解决这个问题
Dialogue: 0,0:54:23.24,0:54:25.50,English,,0,0,0,,We could rewrite the the function
Dialogue: 0,0:54:23.24,0:54:25.50,Chinese,,0,0,0,,我们可以重写这个函数
Dialogue: 0,0:54:25.50,0:54:37.36,English,,0,0,0,,The ctime function to take another argument that passes in the location the address of the time string
Dialogue: 0,0:54:25.50,0:54:37.36,Chinese,,0,0,0,,在 ctime 函数中添加另外一个参数接收时间字符串的地址
Dialogue: 0,0:54:37.40,0:54:44.70,English,,0,0,0,,So we could require the caller to allocate space for the time string and passing the address to the ctime function
Dialogue: 0,0:54:37.40,0:54:44.70,Chinese,,0,0,0,,所以我们可以要求调用者为时间字符串分配空间并将地址传递给 ctime 函数
Dialogue: 0,0:54:45.88,0:54:53.54,English,,0,0,0,,Okay but this has...this would require us to change all the instances Where we call ctime
Dialogue: 0,0:54:45.88,0:54:53.54,Chinese,,0,0,0,,好的，但这有 ...... 这需要我们修改所有 ctime 函数调用实例
Dialogue: 0,0:54:55.18,0:55:01.12,English,,0,0,0,,But we'd also have to change the implementation of ctime in the lib.c in the library
Dialogue: 0,0:54:55.18,0:55:01.12,Chinese,,0,0,0,,但是我们还必须在  lib.c 库中更改 ctime 的实现
Dialogue: 0,0:55:03.02,0:55:08.80,English,,0,0,0,,Right and so we can't...we don't have access to lib.c source on our system
Dialogue: 0,0:55:03.02,0:55:08.80,Chinese,,0,0,0,,是的，所以我们不能 ...... 我们没有访问我们系统上的 lib.c 源代码
Dialogue: 0,0:55:08.82,0:55:14.88,English,,0,0,0,,Right so that's just not a feasible thing plus it would break every other program that called ctime
Dialogue: 0,0:55:08.82,0:55:14.88,Chinese,,0,0,0,,所以这不是一个可行的方案，加上它会破坏其他所有程序调用 ctime
Dialogue: 0,0:55:14.90,0:55:16.18,English,,0,0,0,,So we just can't do
Dialogue: 0,0:55:14.90,0:55:16.18,Chinese,,0,0,0,,所以我们不能这么做
Dialogue: 0,0:55:18.26,0:55:22.98,English,,0,0,0,,That the another option a better option is to create a new function of our own
Dialogue: 0,0:55:18.26,0:55:22.98,Chinese,,0,0,0,,另一种更好的方案是新建一个我们自己的函数
Dialogue: 0,0:55:24.18,0:55:28.32,English,,0,0,0,,Okay called ctime_ts for thread safe
Dialogue: 0,0:55:24.18,0:55:28.32,Chinese,,0,0,0,,叫做 ctime_ts，ctime 的线程安全版本
Dialogue: 0,0:55:28.44,0:55:33.26,English,,0,0,0,,So we'll create our own sort of wrapper function for it for the ctime
Dialogue: 0,0:55:28.44,0:55:33.26,Chinese,,0,0,0,,因此，我们新建的函数只是包装了一下 ctime
Dialogue: 0,0:55:35.08,0:55:43.48,English,,0,0,0,,And we'll use a technique called lock and copy to provide thread safe access to ctime
Dialogue: 0,0:55:35.08,0:55:43.48,Chinese,,0,0,0,,我们将使用「lock and copy 」的技术来提供对 ctime 的线程安全访问
Dialogue: 0,0:55:44.64,0:55:49.52,English,,0,0,0,,So the way it works is it will write this new function ctime_ts
Dialogue: 0,0:55:44.64,0:55:49.52,Chinese,,0,0,0,,所以它的工作方式是编写这个新函数 ctime_ts
Dialogue: 0,0:55:50.42,0:55:55.36,English,,0,0,0,,Which just like ctime takes this a pointer to this time struct
Dialogue: 0,0:55:50.42,0:55:55.36,Chinese,,0,0,0,,它和 ctime 一样，接收一个指向这个时间结构的指针
Dialogue: 0,0:55:55.98,0:55:57.66,English,,0,0,0,,But then it adds a second argument
Dialogue: 0,0:55:55.98,0:55:57.66,Chinese,,0,0,0,,但它新增了第二个参数
Dialogue: 0,0:55:59.16,0:56:04.92,English,,0,0,0,,Which is a pointer to the thread private copy of the time string
Dialogue: 0,0:55:59.16,0:56:04.92,Chinese,,0,0,0,,指向线程自己的时间字符串地址
Dialogue: 0,0:56:06.66,0:56:15.32,English,,0,0,0,,Okay so the caller allocates the space and passes the pointer to this to that to that string
Dialogue: 0,0:56:06.66,0:56:15.32,Chinese,,0,0,0,,所以调用者分配空间并将指针传递给函数
Dialogue: 0,0:56:17.52,0:56:22.58,English,,0,0,0,,And then within ctime we have a local variable called the shared pointer
Dialogue: 0,0:56:17.52,0:56:22.58,Chinese,,0,0,0,,然后在 ctime_ts 中我们有一个名为共享指针的局部变量
Dialogue: 0,0:56:23.32,0:56:29.76,English,,0,0,0,,Okay so this is going to point to that sharred global data structure that ctime is accessing
Dialogue: 0,0:56:23.32,0:56:29.76,Chinese,,0,0,0,,这对 ctime 来说是一个全局的共享数据
Dialogue: 0,0:56:31.72,0:56:36.72,English,,0,0,0,,And so first we do the lock that's the lock part of lock and copy by acquiring a mutex
Dialogue: 0,0:56:31.72,0:56:36.72,Chinese,,0,0,0,,因此，首先我们要获得互斥锁「lock and copy」中的锁
Dialogue: 0,0:56:38.78,0:56:40.46,English,,0,0,0,,And then we call ctime
Dialogue: 0,0:56:38.78,0:56:40.46,Chinese,,0,0,0,,然后我们调用 ctime
Dialogue: 0,0:56:42.42,0:56:44.80,English,,0,0,0,,So only one thread at a time we'll have this mutex
Dialogue: 0,0:56:42.42,0:56:44.80,Chinese,,0,0,0,,因此，一次只有一个线程能获得互斥锁
Dialogue: 0,0:56:44.94,0:56:48.16,English,,0,0,0,,So whatever thread...so once we return from p
Dialogue: 0,0:56:44.94,0:56:48.16,Chinese,,0,0,0,,无论如何 ...... 所以一旦 P 返回了
Dialogue: 0,0:56:48.54,0:56:52.80,English,,0,0,0,,We know that we're the only thread in this critical section
Dialogue: 0,0:56:48.54,0:56:52.80,Chinese,,0,0,0,,我们知道这里是临界区
Dialogue: 0,0:56:53.78,0:56:57.46,English,,0,0,0,,So we call ctime the normal lib.c ctime function
Dialogue: 0,0:56:53.78,0:56:57.46,Chinese,,0,0,0,,这里我们调用 ctime 也就是 lib.c 库中的 ctime 函数
Dialogue: 0,0:56:58.28,0:57:02.10,English,,0,0,0,,Which returns a pointer to this to the same location
Dialogue: 0,0:56:58.28,0:57:02.10,Chinese,,0,0,0,,这会将指向同一位置
Dialogue: 0,0:57:03.46,0:57:04.76,English,,0,0,0,,And then we do the copy part
Dialogue: 0,0:57:03.46,0:57:04.76,Chinese,,0,0,0,,然后我们执行复制部分（「lock and copy」）
Dialogue: 0,0:57:04.76,0:57:13.78,English,,0,0,0,,We copy that string to the private string that was passed in just into a function
Dialogue: 0,0:57:04.76,0:57:13.78,Chinese,,0,0,0,,我们复制该字符串到刚刚传入函数的私有字符串
Dialogue: 0,0:57:15.40,0:57:18.04,English,,0,0,0,,Once we've done the copy then we can release the mutex
Dialogue: 0,0:57:15.40,0:57:18.04,Chinese,,0,0,0,,一旦我们完成了复制，我们就可以释放互斥锁
Dialogue: 0,0:57:18.56,0:57:20.22,English,,0,0,0,,And then we return a pointer
Dialogue: 0,0:57:18.56,0:57:20.22,Chinese,,0,0,0,,然后我们返回一个指针
Dialogue: 0,0:57:21.68,0:57:27.86,English,,0,0,0,,We return privatep back to the caller right ok so
Dialogue: 0,0:57:21.68,0:57:27.86,Chinese,,0,0,0,,我们将 privatep 返回给调用者
Dialogue: 0,0:57:30.16,0:57:34.20,English,,0,0,0,,And we don't this is just more of a convenience to the caller
Dialogue: 0,0:57:30.16,0:57:34.20,Chinese,,0,0,0,,而且这对调用者来说更方便
Dialogue: 0,0:57:34.40,0:57:38.66,English,,0,0,0,,Because programs that are using ctime are expecting to get that pointer back
Dialogue: 0,0:57:34.40,0:57:38.66,Chinese,,0,0,0,,因为使用 ctime 的程序期望得到指针
Dialogue: 0,0:57:39.46,0:57:41.48,English,,0,0,0,,Ok so by using lock and copy
Dialogue: 0,0:57:39.46,0:57:41.48,Chinese,,0,0,0,,通过「lock and copy 」技术
Dialogue: 0,0:57:42.14,0:57:46.34,English,,0,0,0,,We have to make changes,we have to write this new function but it's fairly simple
Dialogue: 0,0:57:42.14,0:57:46.34,Chinese,,0,0,0,,我们做了必要的修改，写了新函数，而且非常简单
Dialogue: 0,0:57:47.60,0:57:52.76,English,,0,0,0,,And then we have to make changes every place in our program where we call ctime
Dialogue: 0,0:57:47.60,0:57:52.76,Chinese,,0,0,0,,然后修改我们程序当中所有调用了 ctime 的地方
Dialogue: 0,0:57:52.76,0:57:56.28,English,,0,0,0,,We have to update those to calls to ctime_ts
Dialogue: 0,0:57:52.76,0:57:56.28,Chinese,,0,0,0,,使用 ctime_ts 来替换
Dialogue: 0,0:57:56.92,0:58:02.72,English,,0,0,0,,And create this local string array
Dialogue: 0,0:57:56.92,0:58:02.72,Chinese,,0,0,0,,并创建此本地字符串
Dialogue: 0,0:58:03.46,0:58:04.26,English,,0,0,0,,Ok yes
Dialogue: 0,0:58:03.46,0:58:04.26,Chinese,,0,0,0,,请讲
Dialogue: 0,0:58:04.66,0:58:18.02,English,,0,0,0,,[student speaking]
Dialogue: 0,0:58:04.66,0:58:18.02,Chinese,,0,0,0,,【同学提问】
Dialogue: 0,0:58:21.04,0:58:24.56,English,,0,0,0,,Well typically these functions are returning pointers to some data structure
Dialogue: 0,0:58:21.04,0:58:24.56,Chinese,,0,0,0,,通常这些函数返回指向某些数据结构的指针
Dialogue: 0,0:58:25.00,0:58:30.22,English,,0,0,0,,And so they're sort of updating the data structure and then returning a pointer to it so
Dialogue: 0,0:58:25.00,0:58:30.22,Chinese,,0,0,0,,因此，他们更新数据，就会返回指向它的指针
Dialogue: 0,0:58:32.10,0:58:33.82,English,,0,0,0,,It wouldn't makes,I don't know how
Dialogue: 0,0:58:32.10,0:58:33.82,Chinese,,0,0,0,,它不会，我不知道如何
Dialogue: 0,0:58:34.58,0:58:37.64,English,,0,0,0,,I guess it could return a struct and it would always return
Dialogue: 0,0:58:34.58,0:58:37.64,Chinese,,0,0,0,,我想它可以返回一个结构，它总会返回
Dialogue: 0,0:58:38.60,0:58:39.28,English,,0,0,0,,Now now
Dialogue: 0,0:58:38.60,0:58:39.28,Chinese,,0,0,0,,现在
Dialogue: 0,0:58:43.52,0:58:48.16,English,,0,0,0,,I can't think of any...I can't think of any reason why they would turn anything but a pointer
Dialogue: 0,0:58:43.52,0:58:48.16,Chinese,,0,0,0,,我想不出任何 ...... 我想不出有什么理由说他们除了指针之外什么都不会转换
Dialogue: 0,0:58:48.62,0:58:52.72,English,,0,0,0,,Because they're typically updating some data structure
Dialogue: 0,0:58:48.62,0:58:52.72,Chinese,,0,0,0,,因为他们通常会更新一些数据结构
Dialogue: 0,0:58:53.30,0:58:54.76,English,,0,0,0,,And then returning a pointer to it
Dialogue: 0,0:58:53.30,0:58:54.76,Chinese,,0,0,0,,然后返回指向它的指针
Dialogue: 0,0:59:02.18,0:59:03.70,English,,0,0,0,,If they were returning
Dialogue: 0,0:59:02.18,0:59:03.70,Chinese,,0,0,0,,如果他们返回了
Dialogue: 0,0:59:06.18,0:59:07.70,English,,0,0,0,,If they were returning
Dialogue: 0,0:59:06.18,0:59:07.70,Chinese,,0,0,0,,如果他们返回了
Dialogue: 0,0:59:08.98,0:59:13.04,English,,0,0,0,,Those scalars would always be returned in %eax or %rax
Dialogue: 0,0:59:08.98,0:59:13.04,Chinese,,0,0,0,,这些变量最终会通过 ％eax 或 ％rax 返回
Dialogue: 0,0:59:13.84,0:59:16.32,English,,0,0,0,,All right so actually that would be okay right it would just be
Dialogue: 0,0:59:13.84,0:59:16.32,Chinese,,0,0,0,,所以实际上这样就可以了
Dialogue: 0,0:59:17.06,0:59:19.16,English,,0,0,0,,It's the pointer that causes a problem because
Dialogue: 0,0:59:17.06,0:59:19.16,Chinese,,0,0,0,,这是因为指针导致的问题，因为
Dialogue: 0,0:59:20.32,0:59:23.00,English,,0,0,0,,It's always returning that value in %eax
Dialogue: 0,0:59:20.32,0:59:23.00,Chinese,,0,0,0,,它总是返回在 ％eax 的值
Dialogue: 0,0:59:23.00,0:59:30.56,English,,0,0,0,,But it's always returning the same value in %eax always pointing to the same data structure okay good
Dialogue: 0,0:59:23.00,0:59:30.56,Chinese,,0,0,0,,但是它始终返回的 ％eax 的值是相同的，它总是指向相同的数据结构
Dialogue: 0,0:59:34.52,0:59:35.48,English,,0,0,0,,Okay now one...
Dialogue: 0,0:59:34.52,0:59:35.48,Chinese,,0,0,0,,好的......
Dialogue: 0,0:59:37.58,0:59:41.98,English,,0,0,0,,One potentially significant disadvantage of lock and copy is that
Dialogue: 0,0:59:37.58,0:59:41.98,Chinese,,0,0,0,,「lock and copy 」有一个明显的缺点
Dialogue: 0,0:59:43.24,0:59:49.06,English,,0,0,0,,This copy might not always be as simple as just doing like a strcpy,if
Dialogue: 0,0:59:43.24,0:59:49.06,Chinese,,0,0,0,,「copy」的部分可能并不总是像 strcpy 一样简单，如果
Dialogue: 0,0:59:50.02,0:59:56.62,English,,0,0,0,,If it's a complex diff...if the function that you're calling is computing some complex data structure like a nested
Dialogue: 0,0:59:50.02,0:59:56.62,Chinese,,0,0,0,,如果它很复杂......如果你正在调用的函数是计算一些复杂的数据结构，如嵌套
Dialogue: 0,0:59:57.26,1:00:00.40,English,,0,0,0,,You know a struct which contains structs and pointers to arrays
Dialogue: 0,0:59:57.26,1:00:00.40,Chinese,,0,0,0,,你知道一个包含结构和数组指针的结构
Dialogue: 0,1:00:01.28,1:00:04.66,English,,0,0,0,,Then this copy can get quite complicated right
Dialogue: 0,1:00:01.28,1:00:04.66,Chinese,,0,0,0,,然后这个「copy」可以变得非常复杂
Dialogue: 0,1:00:05.10,1:00:07.06,English,,0,0,0,,It would require what we call a deep copy
Dialogue: 0,1:00:05.10,1:00:07.06,Chinese,,0,0,0,,它需要「深拷贝」技术
Dialogue: 0,1:00:08.20,1:00:10.50,English,,0,0,0,,So that can be that can be very difficult to
Dialogue: 0,1:00:08.20,1:00:10.50,Chinese,,0,0,0,,所以这可能是非常难
Dialogue: 0,1:00:11.16,1:00:15.84,English,,0,0,0,,But in this case it's simple we're just copying one string to another
Dialogue: 0,1:00:11.16,1:00:15.84,Chinese,,0,0,0,,不过目前很简单，我们只是将一个字符串复制到另一个字符串
Dialogue: 0,1:00:17.44,1:00:25.06,English,,0,0,0,,Okay and then finally the 4 class of thread-unsafe functions are functions that call unsafe functions right
Dialogue: 0,1:00:17.44,1:00:25.06,Chinese,,0,0,0,,最后第四类线程不安全的函数是调用了线程不安全的函数
Dialogue: 0,1:00:25.08,1:00:26.20,English,,0,0,0,,So it's kind of obvious
Dialogue: 0,1:00:25.08,1:00:26.20,Chinese,,0,0,0,,这显而易见
Dialogue: 0,1:00:27.04,1:00:32.16,English,,0,0,0,,And then the obvious fix is to not call thread-unsafe functions from within your function
Dialogue: 0,1:00:27.04,1:00:32.16,Chinese,,0,0,0,,解决方法是不在函数内调用线程不安全的函数
Dialogue: 0,1:00:32.76,1:00:34.04,English,,0,0,0,,And then you can make it thread safe
Dialogue: 0,1:00:32.76,1:00:34.04,Chinese,,0,0,0,,这样就是线程安全的
Dialogue: 0,1:00:37.10,1:00:44.34,English,,0,0,0,,Now there's a very interesting an important subclass of thread-safe functions called reentrant functions
Dialogue: 0,1:00:37.10,1:00:44.34,Chinese,,0,0,0,,现在有一个非常有趣的而且重要的线程安全函数的子类，称为可重入函数
Dialogue: 0,1:00:45.76,1:00:49.20,English,,0,0,0,,So a reentrant a function is reentrant
Dialogue: 0,1:00:45.76,1:00:49.20,Chinese,,0,0,0,,因此，一个函数是可重入的
Dialogue: 0,1:00:50.22,1:00:53.82,English,,0,0,0,,If it contains no accesses to shared to shared variables
Dialogue: 0,1:00:50.22,1:00:53.82,Chinese,,0,0,0,,如果它不包含对共享变量的访问
Dialogue: 0,1:00:54.72,1:00:59.14,English,,0,0,0,,Okay so if all the...every variable that it accesses is
Dialogue: 0,1:00:54.72,1:00:59.14,Chinese,,0,0,0,,它能访问的每个变量都是
Dialogue: 0,1:00:59.56,1:01:06.94,English,,0,0,0,,Contained on the is declared as a local variable and stored on the stack for that function
Dialogue: 0,1:00:59.56,1:01:06.94,Chinese,,0,0,0,,声明为局部变量并存储在该函数的堆栈中
Dialogue: 0,1:01:07.68,1:01:09.30,English,,0,0,0,,Okay that's called a reentrant function
Dialogue: 0,1:01:07.68,1:01:09.30,Chinese,,0,0,0,,被称为可重入函数
Dialogue: 0,1:01:10.10,1:01:13.38,English,,0,0,0,,And because there's no accesses of any kind to shared variables
Dialogue: 0,1:01:10.10,1:01:13.38,Chinese,,0,0,0,,因为不能访问任何共享变量
Dialogue: 0,1:01:14.10,1:01:17.10,English,,0,0,0,,There's no synchronization required
Dialogue: 0,1:01:14.10,1:01:17.10,Chinese,,0,0,0,,不需要同步
Dialogue: 0,1:01:17.10,1:01:22.14,English,,0,0,0,,Because every function is operating accessing its own local copy of all the variables
Dialogue: 0,1:01:17.10,1:01:22.14,Chinese,,0,0,0,,因为每个函数都在操作访问它自己的所有变量的本地副本
Dialogue: 0,1:01:23.90,1:01:29.58,English,,0,0,0,,And if multiple threads execute two instances of a reentrant function
Dialogue: 0,1:01:23.90,1:01:29.58,Chinese,,0,0,0,,如果多个线程执行可重入函数的两个实例
Dialogue: 0,1:01:30.62,1:01:33.16,English,,0,0,0,,It's okay each thread has its own separate stack
Dialogue: 0,1:01:30.62,1:01:33.16,Chinese,,0,0,0,,不会有任何问题，每个线程都有自己独立的堆栈
Dialogue: 0,1:01:33.80,1:01:39.56,English,,0,0,0,,So you don't need to worry about any kind of synchronization they can run independently
Dialogue: 0,1:01:33.80,1:01:39.56,Chinese,,0,0,0,,因此，你无需担心任何同步问题，它们可以独立运行
Dialogue: 0,1:01:40.12,1:01:45.76,English,,0,0,0,,So the reason reentrant functions are so important is because it's expensive to do synchronization
Dialogue: 0,1:01:40.12,1:01:45.76,Chinese,,0,0,0,,重入函数如此重要的原因是因为同步操作开销很大
Dialogue: 0,1:01:47.10,1:01:51.46,English,,0,0,0,,And so what you can avoid it completely with these reentrant function reentrant functions
Dialogue: 0,1:01:47.10,1:01:51.46,Chinese,,0,0,0,,因此，你可以完全可以通过使用可重入函数来避免
Dialogue: 0,1:01:51.48,1:01:52.48,English,,0,0,0,,So they're efficient
Dialogue: 0,1:01:51.48,1:01:52.48,Chinese,,0,0,0,,这样更高效
Dialogue: 0,1:01:57.52,1:02:01.24,English,,0,0,0,,So as that as the diagram shows every reentrant function is thread safe
Dialogue: 0,1:01:57.52,1:02:01.24,Chinese,,0,0,0,,因此，如图所示，每个可重入函数都是线程安全的
Dialogue: 0,1:02:01.96,1:02:04.52,English,,0,0,0,,But not every thread safe function is reentrant
Dialogue: 0,1:02:01.96,1:02:04.52,Chinese,,0,0,0,,但并非每个线程安全的函数都是可重入的
Dialogue: 0,1:02:07.48,1:02:11.92,English,,0,0,0,,So we saw that before right when we have a function that accesses a shared variable
Dialogue: 0,1:02:07.48,1:02:11.92,Chinese,,0,0,0,,在之前的例子中，我们在函数中访问共享变量
Dialogue: 0,1:02:12.48,1:02:15.90,English,,0,0,0,,We can make it thread safe by protecting it with a mutex
Dialogue: 0,1:02:12.48,1:02:15.90,Chinese,,0,0,0,,我们可以通过使用互斥锁的方式实现了线程安全
Dialogue: 0,1:02:17.98,1:02:21.62,English,,0,0,0,,Okay but it's not reentrant,because it's accessing shared variables okay
Dialogue: 0,1:02:17.98,1:02:21.62,Chinese,,0,0,0,,但它不是可重入的，因为它正在访问共享变量
Dialogue: 0,1:02:28.30,1:02:34.74,English,,0,0,0,,Now on all the functions in the standard C library which are enumerated in the back of your K&R texture thread-safe
Dialogue: 0,1:02:28.30,1:02:34.74,Chinese,,0,0,0,,现在介绍标准 C 库中的函数，K&R 书中的函数都是线程安全的
Dialogue: 0,1:02:35.66,1:02:37.60,English,,0,0,0,,Okay but not necessarily reentrant
Dialogue: 0,1:02:35.66,1:02:37.60,Chinese,,0,0,0,,但不一定是可重入的
Dialogue: 0,1:02:39.36,1:02:44.20,English,,0,0,0,,And most most syscalls are thread safe with a few exceptions that I've listed here
Dialogue: 0,1:02:39.36,1:02:44.20,Chinese,,0,0,0,,大多数系统调用都是线程安全的，除了我在这里列出的一些例外
Dialogue: 0,1:02:44.98,1:02:47.74,English,,0,0,0,,I don't think I don't think this is complete
Dialogue: 0,1:02:44.98,1:02:47.74,Chinese,,0,0,0,,我不认为这就是全部
Dialogue: 0,1:02:47.76,1:02:50.44,English,,0,0,0,,But these are just some examples of some notable ones
Dialogue: 0,1:02:47.76,1:02:50.44,Chinese,,0,0,0,,这些只是一些值得注意的例子
Dialogue: 0,1:02:51.74,1:02:55.22,English,,0,0,0,,And so for each of these thread unsafe functions
Dialogue: 0,1:02:51.74,1:02:55.22,Chinese,,0,0,0,,因此对于每个线程不安全的函数
Dialogue: 0,1:02:57.30,1:02:59.92,English,,0,0,0,,Linux provides a reentrant version
Dialogue: 0,1:02:57.30,1:02:59.92,Chinese,,0,0,0,, Linux 都提供了一个可重入的版本
Dialogue: 0,1:03:00.66,1:03:02.88,English,,0,0,0,,Which is denoted by _r
Dialogue: 0,1:03:00.66,1:03:02.88,Chinese,,0,0,0,,用 _r 表示
Dialogue: 0,1:03:03.76,1:03:08.40,English,,0,0,0,,And then that reentrant version has a different set of parameters typically
Dialogue: 0,1:03:03.76,1:03:08.40,Chinese,,0,0,0,,不过可重入版本通常具有不同的参数
Dialogue: 0,1:03:10.08,1:03:19.90,English,,0,0,0,,The only exception that I know about is inet_ntoa which is an episode of an obsolete network protocol for converting
Dialogue: 0,1:03:10.08,1:03:19.90,Chinese,,0,0,0,,我所知道的唯一例外是 inet_ntoa ，它是用于转换的过时网络协议的
Dialogue: 0,1:03:20.86,1:03:25.14,English,,0,0,0,,Sort of binary network addresses to human readable ascii addresses
Dialogue: 0,1:03:20.86,1:03:25.14,Chinese,,0,0,0,,将二进制网络地址转成为人类可读的 ascii 地址
Dialogue: 0,1:03:25.66,1:03:30.48,English,,0,0,0,,But this is obsoleted by other calls
Dialogue: 0,1:03:25.66,1:03:30.48,Chinese,,0,0,0,,但这已经被其他函数所取代
Dialogue: 0,1:03:30.48,1:03:36.02,English,,0,0,0,,So it's I guess they just never bothered to create a reentrant version for it
Dialogue: 0,1:03:30.48,1:03:36.02,Chinese,,0,0,0,,所以我猜他们不打算为它创建一个可重入的版本
Dialogue: 0,1:03:36.38,1:03:38.96,English,,0,0,0,,Because there's other options alternatives to using that
Dialogue: 0,1:03:36.38,1:03:38.96,Chinese,,0,0,0,,因为还有其他选择可供选择
Dialogue: 0,1:03:41.28,1:03:45.10,English,,0,0,0,,Okay so another thing we have to worry about is we've seen is races
Dialogue: 0,1:03:41.28,1:03:45.10,Chinese,,0,0,0,,现在我们要来关系另一个事情「竞争」
Dialogue: 0,1:03:46.16,1:03:49.42,English,,0,0,0,,And this is the real bugaboo in threaded programs
Dialogue: 0,1:03:46.16,1:03:49.42,Chinese,,0,0,0,,这才是多线程程序的 bug 源泉
Dialogue: 0,1:03:50.58,1:03:53.82,English,,0,0,0,,And it typically involves some kind of unexpected sharing
Dialogue: 0,1:03:50.58,1:03:53.82,Chinese,,0,0,0,,它通常涉及某种意外的共享
Dialogue: 0,1:03:54.62,1:04:02.16,English,,0,0,0,,So in this case I'm going to revisit this incorrect threaded program
Dialogue: 0,1:03:54.62,1:04:02.16,Chinese,,0,0,0,,在这种情况下，我将重新审视这里的线程程序中的错误
Dialogue: 0,1:04:03.14,1:04:07.38,English,,0,0,0,,That where we introduce a race by passing when we create the thread
Dialogue: 0,1:04:03.14,1:04:07.38,Chinese,,0,0,0,,这里创建线程传递了这个值从而引入了竞争
Dialogue: 0,1:04:08.74,1:04:13.02,English,,0,0,0,,We pass the argument to the thread which is like the local thread id
Dialogue: 0,1:04:08.74,1:04:13.02,Chinese,,0,0,0,,我们将类似本地的线程 id 参数传递过去了
Dialogue: 0,1:04:14.30,1:04:19.18,English,,0,0,0,,We pass an address of a variable that we have stored on the stack
Dialogue: 0,1:04:14.30,1:04:19.18,Chinese,,0,0,0,,我们传递一个存储在堆栈中的变量的地址
Dialogue: 0,1:04:19.92,1:04:23.66,English,,0,0,0,,And int i that the loop iterator
Dialogue: 0,1:04:19.92,1:04:23.66,Chinese,,0,0,0,,用于循环迭代的参数 i
Dialogue: 0,1:04:26.00,1:04:26.68,English,,0,0,0,,And so
Dialogue: 0,1:04:26.00,1:04:26.68,Chinese,,0,0,0,,所以
Dialogue: 0,1:04:29.82,1:04:33.92,English,,0,0,0,,We've seen that this causes this causes a race so
Dialogue: 0,1:04:29.82,1:04:33.92,Chinese,,0,0,0,,我们已经见过这种「竞争」场面
Dialogue: 0,1:04:35.74,1:04:41.26,English,,0,0,0,,We incurred...we set initially i is 0, then we create a new thread which is peer thread 0
Dialogue: 0,1:04:35.74,1:04:41.26,Chinese,,0,0,0,,我们最初设置 i 为 0，然后我们创建一个新的线程，即对等线程 0
Dialogue: 0,1:04:42.14,1:04:51.08,English,,0,0,0,,And then this thread dereferences the pointer to get its local copy of the this sort of local thread id
Dialogue: 0,1:04:42.14,1:04:51.08,Chinese,,0,0,0,,然后这个线程取消引用指针以获取这种本地线程 id 的本地副本
Dialogue: 0,1:04:53.26,1:04:54.86,English,,0,0,0,,But now we've introduced the race
Dialogue: 0,1:04:53.26,1:04:54.86,Chinese,,0,0,0,,但现在我们已经引入了「竞争」
Dialogue: 0,1:04:56.88,1:04:58.52,English,,0,0,0,,Between the increment of i
Dialogue: 0,1:04:56.88,1:04:58.52,Chinese,,0,0,0,,在 i 的增长之间
Dialogue: 0,1:05:00.50,1:05:04.86,English,,0,0,0,,And the dereferencing of the incrementing of i and the main thread
Dialogue: 0,1:05:00.50,1:05:04.86,Chinese,,0,0,0,,主线程是来增加 i
Dialogue: 0,1:05:05.30,1:05:08.00,English,,0,0,0,,And the dereferencing of i in the peer thread
Dialogue: 0,1:05:05.30,1:05:08.00,Chinese,,0,0,0,,对等线程中取消引用 i
Dialogue: 0,1:05:09.12,1:05:13.42,English,,0,0,0,,So if this dereferencing happens before i is incremented then we're good
Dialogue: 0,1:05:09.12,1:05:13.42,Chinese,,0,0,0,,因此，如果在我增加之前发生这种解除引用，那么就是正确的
Dialogue: 0,1:05:14.68,1:05:17.26,English,,0,0,0,,But if this dereferencing happens after
Dialogue: 0,1:05:14.68,1:05:17.26,Chinese,,0,0,0,,但如果这种解除引用发生在之后
Dialogue: 0,1:05:18.08,1:05:20.96,English,,0,0,0,,We increment i so in other words at when i equal 1
Dialogue: 0,1:05:18.08,1:05:20.96,Chinese,,0,0,0,,i 增加了 1，换句话说，i 等于 1
Dialogue: 0,1:05:22.44,1:05:26.94,English,,0,0,0,,Then we get the wrong value in the peer thread for myid
Dialogue: 0,1:05:22.44,1:05:26.94,Chinese,,0,0,0,,然后我们会在对等线程中获得一个错误的值给 myid 
Dialogue: 0,1:05:30.46,1:05:32.96,English,,0,0,0,,So you might wonder I think there was a question before about
Dialogue: 0,1:05:30.46,1:05:32.96,Chinese,,0,0,0,,所以你可能想起了之前的一个问题
Dialogue: 0,1:05:33.98,1:05:39.24,English,,0,0,0,,You know this seems that the odds of this happening seems so low why why are you even worrying about it
Dialogue: 0,1:05:33.98,1:05:39.24,Chinese,,0,0,0,,你知道这似乎发生的可能性似乎很低，为什么你甚至担心它
Dialogue: 0,1:05:40.66,1:05:46.60,English,,0,0,0,,So we actually create just to sort of test this out we wrote a program to see if we could
Dialogue: 0,1:05:40.66,1:05:46.60,Chinese,,0,0,0,,所以我们实际创建只是为了测试这个，我们写了一个程序，看看我们是否可以
Dialogue: 0,1:05:47.78,1:05:52.60,English,,0,0,0,,See if we could actually see this race in practice
Dialogue: 0,1:05:47.78,1:05:52.60,Chinese,,0,0,0,,看看我们是否真的可以在实践中看到「竞争」
Dialogue: 0,1:05:53.68,1:05:58.22,English,,0,0,0,,And that's one of the great things about like 213 is that you we can just try stuff out right so
Dialogue: 0,1:05:53.68,1:05:58.22,Chinese,,0,0,0,,这就是 213 这门课的优势之一，我们可以尝试这样的东西
Dialogue: 0,1:05:58.94,1:05:59.94,English,,0,0,0,,So we just tried it out
Dialogue: 0,1:05:58.94,1:05:59.94,Chinese,,0,0,0,,所以我们试了一下
Dialogue: 0,1:06:01.94,1:06:07.90,English,,0,0,0,,So we wrote a simple main thread that creates a hundred different threads
Dialogue: 0,1:06:01.94,1:06:07.90,Chinese,,0,0,0,,所以我们编写了一个简单的主线程，创建了一百个不同的线程
Dialogue: 0,1:06:08.76,1:06:15.54,English,,0,0,0,,Each with then we passed the as the argument we passed the address of this local variable i okay
Dialogue: 0,1:06:08.76,1:06:15.54,Chinese,,0,0,0,,每一个都接收局部变量 i 的地址作为参数
Dialogue: 0,1:06:17.76,1:06:21.34,English,,0,0,0,,And then in each peer thread we detach the thread dereference
Dialogue: 0,1:06:17.76,1:06:21.34,Chinese,,0,0,0,,然后在每个对等线程中我们解除引用
Dialogue: 0,1:06:22.06,1:06:25.46,English,,0,0,0,,And then we have a function that saves the value so we're we're storing
Dialogue: 0,1:06:22.06,1:06:25.46,Chinese,,0,0,0,,然后我们调用 save_value
Dialogue: 0,1:06:27.14,1:06:31.86,English,,0,0,0,,We're storing that value of i for future reference
Dialogue: 0,1:06:27.14,1:06:31.86,Chinese,,0,0,0,,我们将 i 的值存储起来供将来使用
Dialogue: 0,1:06:33.90,1:06:35.36,English,,0,0,0,,Okay so now if there's no race
Dialogue: 0,1:06:33.90,1:06:35.36,Chinese,,0,0,0,,如果没有「竞争」的话
Dialogue: 0,1:06:36.52,1:06:40.74,English,,0,0,0,,Each of the 100 threads would get a separate distinct thread id
Dialogue: 0,1:06:36.52,1:06:40.74,Chinese,,0,0,0,, 100 个线程中的每一个都将获得不同线程 ID
Dialogue: 0,1:06:40.98,1:06:43.72,English,,0,0,0,,Right so each value 0 through 99
Dialogue: 0,1:06:40.98,1:06:43.72,Chinese,,0,0,0,,从 0 到 99
Dialogue: 0,1:06:44.16,1:06:45.60,English,,0,0,0,,If we made a histogram of it
Dialogue: 0,1:06:44.16,1:06:45.60,Chinese,,0,0,0,,如果我们做了直方图
Dialogue: 0,1:06:46.34,1:06:50.72,English,,0,0,0,,There would be exactly one instance of each value of i
Dialogue: 0,1:06:46.34,1:06:50.72,Chinese,,0,0,0,, i 的每个值都只有一个实例
Dialogue: 0,1:06:52.42,1:06:56.54,English,,0,0,0,,Okay but if there was a race there would be for some values of i
Dialogue: 0,1:06:52.42,1:06:56.54,Chinese,,0,0,0,,但是如果有「竞争」
Dialogue: 0,1:06:56.54,1:06:59.56,English,,0,0,0,,There would be multiple instances that were encountered in multiple threads
Dialogue: 0,1:06:56.54,1:06:59.56,Chinese,,0,0,0,,i 的值上可能会有多少线程实例
Dialogue: 0,1:07:00.76,1:07:02.64,English,,0,0,0,,Okay so you can see if we go back here
Dialogue: 0,1:07:00.76,1:07:02.64,Chinese,,0,0,0,,回到这里
Dialogue: 0,1:07:04.02,1:07:11.62,English,,0,0,0,,If we lose if the peer thread loses the race and I gets incremented before it can dereference
Dialogue: 0,1:07:04.02,1:07:11.62,Chinese,,0,0,0,,如果对等线程竞争失败，我会在它取消引用之前增加
Dialogue: 0,1:07:15.28,1:07:22.08,English,,0,0,0,,Now we've got peer thread 0 actually gets an id of one
Dialogue: 0,1:07:15.28,1:07:22.08,Chinese,,0,0,0,,现在对等线程 0 实际上得到线程 id 是 1
Dialogue: 0,1:07:25.70,1:07:27.52,English,,0,0,0,,Okay and then peer thread one
Dialogue: 0,1:07:25.70,1:07:27.52,Chinese,,0,0,0,,然而对等线程 1 
Dialogue: 0,1:07:28.32,1:07:34.24,English,,0,0,0,,If there's no race it'll get the correct value of one so now we've got two instances of one okay
Dialogue: 0,1:07:28.32,1:07:34.24,Chinese,,0,0,0,,如果没有「竞争」，它将得到一个正确的值，所以现在 1 上会有两个实例
Dialogue: 0,1:07:36.86,1:07:38.36,English,,0,0,0,,So let's look so this is the case
Dialogue: 0,1:07:36.86,1:07:38.36,Chinese,,0,0,0,,让我们看看这样的情况
Dialogue: 0,1:07:40.48,1:07:45.58,English,,0,0,0,,So we've plotted the results for a case where there's no race so along the x-axis sorry this is too small
Dialogue: 0,1:07:40.48,1:07:45.58,Chinese,,0,0,0,,我们绘制了一中案例的结果，其中没有竞争，所以沿着x轴，抱歉这太小了
Dialogue: 0,1:07:46.18,1:07:51.20,English,,0,0,0,,The x-axis gives us all the 100 values of i,0 through 99
Dialogue: 0,1:07:46.18,1:07:51.20,Chinese,,0,0,0,,x 轴给出了 i 的值，从 0 到 99 所有 100 个值
Dialogue: 0,1:07:51.72,1:08:00.12,English,,0,0,0,,And then the y-axis is the count so this is a hit we're doing a histogram for these all the values 0 through 99
Dialogue: 0,1:07:51.72,1:08:00.12,Chinese,,0,0,0,,y 轴是计数，表示落在这个直方图上 0 到 99 的数量
Dialogue: 0,1:08:01.22,1:08:05.46,English,,0,0,0,,So in this case every value has exactly one instance so no race
Dialogue: 0,1:08:01.22,1:08:05.46,Chinese,,0,0,0,,所以在这种情况下，每个值只有一个实例，所以没有竞争
Dialogue: 0,1:08:06.26,1:08:14.64,English,,0,0,0,,There was no races in involved in all 99 are all 100 instances
Dialogue: 0,1:08:06.26,1:08:14.64,Chinese,,0,0,0,,全部 100 个实例都没有产生竞争
Dialogue: 0,1:08:16.52,1:08:18.22,English,,0,0,0,,If we run it on a single core laptop
Dialogue: 0,1:08:16.52,1:08:18.22,Chinese,,0,0,0,,如果我们在单核笔记本电脑上运行它
Dialogue: 0,1:08:18.30,1:08:22.08,English,,0,0,0,,So now each thread is sort of taking its turn on a single core
Dialogue: 0,1:08:18.30,1:08:22.08,Chinese,,0,0,0,,每个线程只能运行在单个核心上
Dialogue: 0,1:08:24.06,1:08:27.40,English,,0,0,0,,It happens a few times right so there's a few times where
Dialogue: 0,1:08:24.06,1:08:27.40,Chinese,,0,0,0,,很少出现
Dialogue: 0,1:08:28.18,1:08:31.50,English,,0,0,0,,The one thread gets preempted and the other thread
Dialogue: 0,1:08:28.18,1:08:31.50,Chinese,,0,0,0,,一个线程被另一个线程抢占
Dialogue: 0,1:08:31.98,1:08:33.24,English,,0,0,0,,Begins to run
Dialogue: 0,1:08:31.98,1:08:33.24,Chinese,,0,0,0,,开始跑
Dialogue: 0,1:08:35.84,1:08:36.78,English,,0,0,0,,Before it can...
Dialogue: 0,1:08:35.84,1:08:36.78,Chinese,,0,0,0,,在它之前 ......
Dialogue: 0,1:08:36.92,1:08:41.74,English,,0,0,0,,So the peers when one thread gets preempted before I can dereference the variable
Dialogue: 0,1:08:36.92,1:08:41.74,Chinese,,0,0,0,,因此，在我可以取消引用变量之前，被另外的线程被抢占了
Dialogue: 0,1:08:41.74,1:08:44.10,English,,0,0,0,,So it gets the wrong the wrong value
Dialogue: 0,1:08:41.74,1:08:44.10,Chinese,,0,0,0,,因此得到了错误值
Dialogue: 0,1:08:44.40,1:08:50.38,English,,0,0,0,,But it's not very common it just it happened 1,2,3,4,5,6,7 times
Dialogue: 0,1:08:44.40,1:08:50.38,Chinese,,0,0,0,,但它并不常见，只发生了 1 , 2 , 3 , 4 , 5 , 6 , 7 次
Dialogue: 0,1:08:51.46,1:08:54.76,English,,0,0,0,,But now if we run this program on a multi-core server
Dialogue: 0,1:08:51.46,1:08:54.76,Chinese,,0,0,0,,但现在我们在多核服务器上运行这个程序
Dialogue: 0,1:08:55.48,1:08:58.30,English,,0,0,0,,You can see it happens a lot in fact it happens most of the time
Dialogue: 0,1:08:55.48,1:08:58.30,Chinese,,0,0,0,,你可以看到它发生了很多，事实上出现的频率很高
Dialogue: 0,1:08:58.68,1:09:04.60,English,,0,0,0,,So it almost never get the correct value for for myid
Dialogue: 0,1:08:58.68,1:09:04.60,Chinese,,0,0,0,,几乎不会得到正确的 myid
Dialogue: 0,1:09:06.80,1:09:11.38,English,,0,0,0,,Okay so this is just another example of some of the create the things that can just drive you crazy
Dialogue: 0,1:09:06.80,1:09:11.38,Chinese,,0,0,0,,这只是一个让你抓狂的例子
Dialogue: 0,1:09:12.04,1:09:15.78,English,,0,0,0,,If you're not careful when you program is and threads with threads
Dialogue: 0,1:09:12.04,1:09:15.78,Chinese,,0,0,0,,如果你编写多线程程序粗心大意很有可能会出现这种情况
Dialogue: 0,1:09:18.36,1:09:23.50,English,,0,0,0,,Okay and as so as we saw the the way to eliminate these kind of erases  
Dialogue: 0,1:09:18.36,1:09:23.50,Chinese,,0,0,0,,正如我们所看到的，消除这种「竞争」的方法是
Dialogue: 0,1:09:23.90,1:09:30.06,English,,0,0,0,,It's to avoid this the sharing of state and in this case by allocating
Dialogue: 0,1:09:23.90,1:09:30.06,Chinese,,0,0,0,,避免共享状态，可以通过分配来处理
Dialogue: 0,1:09:31.08,1:09:35.31,English,,0,0,0,,For each thread allocating a separate block in the heap
Dialogue: 0,1:09:31.08,1:09:35.31,Chinese,,0,0,0,,为每个线程的堆中分配一个单独的块
Dialogue: 0,1:09:35.68,1:09:40.44,English,,0,0,0,,That will hold the local id for that thread
Dialogue: 0,1:09:35.68,1:09:40.44,Chinese,,0,0,0,,让线程 id 保存在局部变量当中
Dialogue: 0,1:09:40.88,1:09:47.60,English,,0,0,0,,And then passing a pointer to that unique block of storage to the thread
Dialogue: 0,1:09:40.88,1:09:47.60,Chinese,,0,0,0,,然后将对应的指针传递进去
Dialogue: 0,1:09:51.16,1:09:54.14,English,,0,0,0,,Okay so if that if all of that isn't enough to worry about
Dialogue: 0,1:09:51.16,1:09:54.14,Chinese,,0,0,0,,如果这样的话，就不用担心了
Dialogue: 0,1:09:55.58,1:10:01.42,English,,0,0,0,,And by now you should be losing sleep at the very thought of writing a threaded program
Dialogue: 0,1:09:55.58,1:10:01.42,Chinese,,0,0,0,,到现在为止，你想到编写线程程序，可能会失眠
Dialogue: 0,1:10:02.02,1:10:04.10,English,,0,0,0,,Another thing to worry about is deadlock
Dialogue: 0,1:10:02.02,1:10:04.10,Chinese,,0,0,0,,另一件需要担心的事情是「死锁」
Dialogue: 0,1:10:06.70,1:10:13.56,English,,0,0,0,,Okay so here a program is deadlocked if it's waiting for some condition to occur that will never occur
Dialogue: 0,1:10:06.70,1:10:13.56,Chinese,,0,0,0,,如果程序等待某些条件永远不会发生就会陷入「死锁」
Dialogue: 0,1:10:18.16,1:10:21.28,English,,0,0,0,,Okay so let's see a typical scenario right 
Dialogue: 0,1:10:18.16,1:10:21.28,Chinese,,0,0,0,,让我们看一个典型的案例吧
Dialogue: 0,1:10:22.30,1:10:26.16,English,,0,0,0,,p is the potential the p operation is a potential problem because it blocks
Dialogue: 0,1:10:22.30,1:10:26.16,Chinese,,0,0,0,,P 操作存在潜在的问题，因为它会阻塞
Dialogue: 0,1:10:27.64,1:10:31.70,English,,0,0,0,,Right and it's waiting for that semaphore that it's blocking on to become nonzero
Dialogue: 0,1:10:27.64,1:10:31.70,Chinese,,0,0,0,,它正在等待那个被阻塞的信号量变为非零
Dialogue: 0,1:10:33.84,1:10:36.94,English,,0,0,0,,Well it's not too hard to imagine scenarios where
Dialogue: 0,1:10:33.84,1:10:36.94,Chinese,,0,0,0,,想象这种的场景并不难
Dialogue: 0,1:10:37.96,1:10:44.38,English,,0,0,0,,Some there's some combination of P(s), P operations that sort of block each other
Dialogue: 0,1:10:37.96,1:10:44.38,Chinese,,0,0,0,,有些情况会出现 P 操作的组合，它们会相互之间进行阻塞
Dialogue: 0,1:10:44.92,1:10:49.00,English,,0,0,0,,Okay and make it impossible for the condition they're waiting on to occur
Dialogue: 0,1:10:44.92,1:10:49.00,Chinese,,0,0,0,,让他们等待的情况不可能发生
Dialogue: 0,1:10:49.98,1:10:54.44,English,,0,0,0,,So for example let's see you've got two threads
Dialogue: 0,1:10:49.98,1:10:54.44,Chinese,,0,0,0,,例如，假设你有两个线程
Dialogue: 0,1:10:55.08,1:10:58.56,English,,0,0,0,,That need two threads one and two
Dialogue: 0,1:10:55.08,1:10:58.56,Chinese,,0,0,0,,线程 1 和线程 2
Dialogue: 0,1:10:59.22,1:11:03.18,English,,0,0,0,,That need two different resources A and B in order to proceed
Dialogue: 0,1:10:59.22,1:11:03.18,Chinese,,0,0,0,,它们需要两个不同的资源 A 和 B 才能继续
Dialogue: 0,1:11:03.18,1:11:06.88,English,,0,0,0,,So they have to acquire they have to do a P on the mutex
Dialogue: 0,1:11:03.18,1:11:06.88,Chinese,,0,0,0,,因此他们必须获得......他们必须通过 P 操作进行互斥操作
Dialogue: 0,1:11:07.00,1:11:10.76,English,,0,0,0,,That on the mutex that that's associated with
Dialogue: 0,1:11:07.00,1:11:10.76,Chinese,,0,0,0,,这些互斥量相互关联
Dialogue: 0,1:11:12.16,1:11:14.92,English,,0,0,0,,The mutexes that are associated with these two resources
Dialogue: 0,1:11:12.16,1:11:14.92,Chinese,,0,0,0,,关联这两个资源
Dialogue: 0,1:11:16.64,1:11:22.32,English,,0,0,0,,So let's see process one acquires A so it does a P on A mutex
Dialogue: 0,1:11:16.64,1:11:22.32,Chinese,,0,0,0,,假设进程 1 获取 A ，它通过对 A 进行 P 操作
Dialogue: 0,1:11:23.94,1:11:28.50,English,,0,0,0,,That's one ,it's okay,so it acquires that resource
Dialogue: 0,1:11:23.94,1:11:28.50,Chinese,,0,0,0,,这是 1，没问题，所以它获得了那个资源
Dialogue: 0,1:11:30.04,1:11:33.38,English,,0,0,0,,And then it gets preempted by thread 2
Dialogue: 0,1:11:30.04,1:11:33.38,Chinese,,0,0,0,,然后它被线程 2 抢占
Dialogue: 0,1:11:34.06,1:11:35.28,English,,0,0,0,,Which acquires B
Dialogue: 0,1:11:34.06,1:11:35.28,Chinese,,0,0,0,,而它获得 B
Dialogue: 0,1:11:36.74,1:11:41.14,English,,0,0,0,,First instead of acquiring A thread B for some reason acquires B
Dialogue: 0,1:11:36.74,1:11:41.14,Chinese,,0,0,0,,然后线程首先获取了 A， 由于某种原因现在要获得 B
Dialogue: 0,1:11:42.20,1:11:46.06,English,,0,0,0,,So now thread A holds the lock on resource A
Dialogue: 0,1:11:42.20,1:11:46.06,Chinese,,0,0,0,,现在线程 A （线程 1）锁定了资源 A 
Dialogue: 0,1:11:47.08,1:11:49.78,English,,0,0,0,,And thread 2 holds the lock on resource B
Dialogue: 0,1:11:47.08,1:11:49.78,Chinese,,0,0,0,,并且线程 2 保持对资源 B 的锁定
Dialogue: 0,1:11:52.08,1:11:56.06,English,,0,0,0,,And so now let's say process thread 2 gets preempted so now
Dialogue: 0,1:11:52.08,1:11:56.06,Chinese,,0,0,0,,现在假设线程 2 被抢占了
Dialogue: 0,1:11:56.88,1:11:59.18,English,,0,0,0,,And thread one runs and so now it's waiting
Dialogue: 0,1:11:56.88,1:11:59.18,Chinese,,0,0,0,,线程 1 运行，所以现在它开始等待
Dialogue: 0,1:12:00.60,1:12:05.36,English,,0,0,0,,It's trying to tries to acquire the lock on resource B
Dialogue: 0,1:12:00.60,1:12:05.36,Chinese,,0,0,0,,因为它想要获得对资源 B 的锁定
Dialogue: 0,1:12:07.08,1:12:09.08,English,,0,0,0,,But threat two holds that lock
Dialogue: 0,1:12:07.08,1:12:09.08,Chinese,,0,0,0,,但这被线程 2 锁定了
Dialogue: 0,1:12:10.54,1:12:15.02,English,,0,0,0,,And at the same time thread 2 tries to acquire the lock on resource A
Dialogue: 0,1:12:10.54,1:12:15.02,Chinese,,0,0,0,,同时线程 2 尝试获取资源 A 上的锁
Dialogue: 0,1:12:17.04,1:12:18.64,English,,0,0,0,,But process one is holding that right
Dialogue: 0,1:12:17.04,1:12:18.64,Chinese,,0,0,0,,但是线程 1 有这个锁
Dialogue: 0,1:12:18.78,1:12:19.64,English,,0,0,0,,So they're each...
Dialogue: 0,1:12:18.78,1:12:19.64,Chinese,,0,0,0,,它们相互......
Dialogue: 0,1:12:21.00,1:12:28.52,English,,0,0,0,,so here's the case where thread A is waiting for this semaphore associated with B to become nonzero
Dialogue: 0,1:12:21.00,1:12:28.52,Chinese,,0,0,0,,这里线程获得了 A，等待信号量 B 变成非零值
Dialogue: 0,1:12:29.36,1:12:31.46,English,,0,0,0,,So it's blocked in this p operation
Dialogue: 0,1:12:29.36,1:12:31.46,Chinese,,0,0,0,,但是这个 P 操作被阻塞了
Dialogue: 0,1:12:32.10,1:12:39.60,English,,0,0,0,,And at the same time thread 2 is blocked in the p operation for resource A
Dialogue: 0,1:12:32.10,1:12:39.60,Chinese,,0,0,0,,同时，线程 2 也被阻塞了，因为对资源 A 的 P 操作被阻塞
Dialogue: 0,1:12:40.76,1:12:44.22,English,,0,0,0,,Neither of those semaphores will ever be released
Dialogue: 0,1:12:40.76,1:12:44.22,Chinese,,0,0,0,,这些信号量都不会被释放
Dialogue: 0,1:12:44.70,1:12:46.86,English,,0,0,0,,So thread 1 and 2 are deadlocked
Dialogue: 0,1:12:44.70,1:12:46.86,Chinese,,0,0,0,,所以线程 1 和 2 都是死锁
Dialogue: 0,1:12:49.70,1:12:55.38,English,,0,0,0,,Okay and it happened because just there was this innocuous little bug in this case
Dialogue: 0,1:12:49.70,1:12:55.38,Chinese,,0,0,0,,好吧，它发生了，因为在这种情况下这只是一个小 bug
Dialogue: 0,1:12:55.92,1:12:59.04,English,,0,0,0,,Where one the threads acquired their resources in different orders
Dialogue: 0,1:12:55.92,1:12:59.04,Chinese,,0,0,0,,其中一个线程以不同的顺序获取其资源
Dialogue: 0,1:13:05.62,1:13:08.78,English,,0,0,0,,So here's an example of a program that deadlocks
Dialogue: 0,1:13:05.62,1:13:08.78,Chinese,,0,0,0,,所以这是一个死锁程序的例子
Dialogue: 0,1:13:08.98,1:13:14.78,English,,0,0,0,,And if you looked at this you know the fact that it's wrong and bug doesn't jump out at you right
Dialogue: 0,1:13:08.98,1:13:14.78,Chinese,,0,0,0,,如果你看着这个，你就会知道这是错误的，并且 bug 不会向你跳出来
Dialogue: 0,1:13:14.82,1:13:17.86,English,,0,0,0,,So this kind of stuff is very subtle
Dialogue: 0,1:13:14.82,1:13:17.86,Chinese,,0,0,0,,所以这种东西非常隐秘
Dialogue: 0,1:13:17.86,1:13:22.22,English,,0,0,0,,So here's a program we're going to create two threads
Dialogue: 0,1:13:17.86,1:13:22.22,Chinese,,0,0,0,,所以这是一个程创建两个线程
Dialogue: 0,1:13:24.52,1:13:29.12,English,,0,0,0,,We've got an array so and we have an array of mutexes
Dialogue: 0,1:13:24.52,1:13:29.12,Chinese,,0,0,0,,我们有一个数组，我们有一个互斥信号量数组
Dialogue: 0,1:13:31.64,1:13:33.28,English,,0,0,0,,An array of two mutexes
Dialogue: 0,1:13:31.64,1:13:33.28,Chinese,,0,0,0,,包含两个互斥信号量的数组
Dialogue: 0,1:13:34.58,1:13:42.86,English,,0,0,0,,So we create two threads and we pass each thread It's a local thread id so of 0 and 1
Dialogue: 0,1:13:34.58,1:13:42.86,Chinese,,0,0,0,,所以我们创建两个线程，然后给每个线程传递了局部变量的线程id，0 和 1 
Dialogue: 0,1:13:43.70,1:13:49.56,English,,0,0,0,,And so here we're avoiding the race we're just casting this thread id to a pointer okay
Dialogue: 0,1:13:43.70,1:13:49.56,Chinese,,0,0,0,,所以我们为了避免竞争，我们将这个线程 id 转换为了指针
Dialogue: 0,1:13:49.96,1:13:52.52,English,,0,0,0,,Which is a little strange but it's okay
Dialogue: 0,1:13:49.96,1:13:52.52,Chinese,,0,0,0,,这有点奇怪，但没关系
Dialogue: 0,1:13:53.38,1:13:55.26,English,,0,0,0,,And then we're waiting for those threads to finish
Dialogue: 0,1:13:53.38,1:13:55.26,Chinese,,0,0,0,,然后我们等待那些线程完成
Dialogue: 0,1:13:57.62,1:14:05.60,English,,0,0,0,,Ok each thread is going to acquire two these two semaphores
Dialogue: 0,1:13:57.62,1:14:05.60,Chinese,,0,0,0,,每个线程将获得两个这两个信号量
Dialogue: 0,1:14:06.18,1:14:07.60,English,,0,0,0,,These two mutexes
Dialogue: 0,1:14:06.18,1:14:07.60,Chinese,,0,0,0,,这两个互斥信号量
Dialogue: 0,1:14:08.78,1:14:10.78,English,,0,0,0,,But it's going to do it in a different order
Dialogue: 0,1:14:08.78,1:14:10.78,Chinese,,0,0,0,,但它会以不同的顺序进行
Dialogue: 0,1:14:14.94,1:14:18.44,English,,0,0,0,,Okay so it's going to do it as a function it's going to take the id
Dialogue: 0,1:14:14.94,1:14:18.44,Chinese,,0,0,0,,它会通过 id 来获取
Dialogue: 0,1:14:18.44,1:14:22.40,English,,0,0,0,,So it's going to...so thread 0 will first acquire a mutex 0
Dialogue: 0,1:14:18.44,1:14:22.40,Chinese,,0,0,0,,所以它将 ... 所以线程 0 将首先获得互斥锁 0
Dialogue: 0,1:14:23.82,1:14:27.68,English,,0,0,0,,And then acquire mutex 1-0
Dialogue: 0,1:14:23.82,1:14:27.68,Chinese,,0,0,0,,然后要获得互斥量 1（1-0）
Dialogue: 0,1:14:27.68,1:14:29.70,English,,0,0,0,,So then it will acquire mutex 1
Dialogue: 0,1:14:27.68,1:14:29.70,Chinese,,0,0,0,,那么它将获得互斥锁 1
Dialogue: 0,1:14:31.50,1:14:36.20,English,,0,0,0,,And thread 1 will first acquire mutex 1
Dialogue: 0,1:14:31.50,1:14:36.20,Chinese,,0,0,0,,并且线程 1 将首先获取互斥锁 1
Dialogue: 0,1:14:36.98,1:14:38.56,English,,0,0,0,,And then acquire mutex 0
Dialogue: 0,1:14:36.98,1:14:38.56,Chinese,,0,0,0,,然后获取互斥锁 0
Dialogue: 0,1:14:41.86,1:14:46.98,English,,0,0,0,,Ok so if we were to draw that Tid,and then it will attempt to then it will increment count
Dialogue: 0,1:14:41.86,1:14:46.98,Chinese,,0,0,0,,我们这种情况画在这里。这里它会增加计数
Dialogue: 0,1:14:47.36,1:14:48.50,English,,0,0,0,,So this is totally bogus
Dialogue: 0,1:14:47.36,1:14:48.50,Chinese,,0,0,0,,所以这完全是假的
Dialogue: 0,1:14:48.66,1:14:51.34,English,,0,0,0,,But it's just to illustrate the problem
Dialogue: 0,1:14:48.66,1:14:51.34,Chinese,,0,0,0,,但这只是为了说明问题
Dialogue: 0,1:14:52.74,1:14:58.08,English,,0,0,0,,So you can see thread 0 does a P semaphore 0 followed by a P semaphore 1
Dialogue: 0,1:14:52.74,1:14:58.08,Chinese,,0,0,0,,所以你可以看到线程 0 做了P(0) 接着又做了P(1)
Dialogue: 0,1:14:58.86,1:15:01.30,English,,0,0,0,,And thread 1 does a P semaphore 1
Dialogue: 0,1:14:58.86,1:15:01.30,Chinese,,0,0,0,,并且线程 1 执行 P(1)
Dialogue: 0,1:15:01.98,1:15:03.92,English,,0,0,0,,Followed by a P semaphore 0
Dialogue: 0,1:15:01.98,1:15:03.92,Chinese,,0,0,0,,接着又是 P(0)
Dialogue: 0,1:15:06.50,1:15:10.22,English,,0,0,0,,And so we can see this,that this is a problem very clearly
Dialogue: 0,1:15:06.50,1:15:10.22,Chinese,,0,0,0,,所以我们可以看到，这个问题很清晰了
Dialogue: 0,1:15:10.42,1:15:12.52,English,,0,0,0,,If we go back to a progress graphs
Dialogue: 0,1:15:10.42,1:15:12.52,Chinese,,0,0,0,,让我们来看看进度图
Dialogue: 0,1:15:17.08,1:15:19.40,English,,0,0,0,,So if you look at thread 0
Dialogue: 0,1:15:17.08,1:15:19.40,Chinese,,0,0,0,,看一下线程 0
Dialogue: 0,1:15:20.36,1:15:22.42,English,,0,0,0,,It's doing a P semaphore 1
Dialogue: 0,1:15:20.36,1:15:22.42,Chinese,,0,0,0,,它正在做 P(1)
Dialogue: 0,1:15:22.90,1:15:28.22,English,,0,0,0,,And of and it followed a P semaphore 1 followed by a V on semaphore 1
Dialogue: 0,1:15:22.90,1:15:28.22,Chinese,,0,0,0,,P(1) 后面是 V(1)
Dialogue: 0,1:15:30.82,1:15:35.94,English,,0,0,0,,And thread 1 is also is doing a P semaphore 1 followed by a V on semaphore 1
Dialogue: 0,1:15:30.82,1:15:35.94,Chinese,,0,0,0,,并且线程 1 也正在执行 P(1)，然后是V(1)
Dialogue: 0,1:15:36.64,1:15:44.20,English,,0,0,0,,So if you take the intersection of these two regions
Dialogue: 0,1:15:36.64,1:15:44.20,Chinese,,0,0,0,,如果你采取这两个区域的交集
Dialogue: 0,1:15:45.00,1:15:47.92,English,,0,0,0,,You get the forbidden region for semaphore 1
Dialogue: 0,1:15:45.00,1:15:47.92,Chinese,,0,0,0,,你得到了信号量 1 的禁区
Dialogue: 0,1:15:48.04,1:15:51.20,English,,0,0,0,,Okay so this is the region that enforces mutual exclusion
Dialogue: 0,1:15:48.04,1:15:51.20,Chinese,,0,0,0,,这是互斥的区域
Dialogue: 0,1:15:51.90,1:15:56.00,English,,0,0,0,,So on this the resource associated with semaphore 1
Dialogue: 0,1:15:51.90,1:15:56.00,Chinese,,0,0,0,,在这个与信号量 1 相关的资源上
Dialogue: 0,1:15:58.78,1:16:02.54,English,,0,0,0,,And if you do the same thing for semaphore 0 so here in thread 1
Dialogue: 0,1:15:58.78,1:16:02.54,Chinese,,0,0,0,,如果你对信号量 0 做同样的事情，那么在线程 1 中
Dialogue: 0,1:16:03.20,1:16:06.26,English,,0,0,0,,We're acquiring semaphore 0 here and releasing it here
Dialogue: 0,1:16:03.20,1:16:06.26,Chinese,,0,0,0,,我们在这里获取信号量 0 并在这里释放
Dialogue: 0,1:16:07.72,1:16:12.82,English,,0,0,0,,And in thread 0 we're acquiring it here and releasing it here
Dialogue: 0,1:16:07.72,1:16:12.82,Chinese,,0,0,0,,在线程 0 中，我们在这里获取并在释放
Dialogue: 0,1:16:13.96,1:16:16.02,English,,0,0,0,,So if you take the intersection of those two
Dialogue: 0,1:16:13.96,1:16:16.02,Chinese,,0,0,0,,所以如果你采取这两者的交集
Dialogue: 0,1:16:16.66,1:16:19.84,English,,0,0,0,,You get this forbidden region for S(0)
Dialogue: 0,1:16:16.66,1:16:19.84,Chinese,,0,0,0,,你得到 S(0) 的禁区
Dialogue: 0,1:16:21.66,1:16:22.84,English,,0,0,0,,Ok now the problem
Dialogue: 0,1:16:21.66,1:16:22.84,Chinese,,0,0,0,,现在问题是
Dialogue: 0,1:16:26.86,1:16:31.22,English,,0,0,0,,is right is this region here this so-called deadlock region
Dialogue: 0,1:16:26.86,1:16:31.22,Chinese,,0,0,0,,这里是死锁区域
Dialogue: 0,1:16:33.74,1:16:35.42,English,,0,0,0,,Because by the rules of
Dialogue: 0,1:16:33.74,1:16:35.42,Chinese,,0,0,0,,因为根据规则......
Dialogue: 0,1:16:36.58,1:16:37.98,English,,0,0,0,,You know time can't go backwards
Dialogue: 0,1:16:36.58,1:16:37.98,Chinese,,0,0,0,,你知道时间不能倒退
Dialogue: 0,1:16:40.82,1:16:44.16,English,,0,0,0,,Once the trajectory enters into the this deadlock region
Dialogue: 0,1:16:40.82,1:16:44.16,Chinese,,0,0,0,,一旦进入该死锁区域
Dialogue: 0,1:16:45.08,1:16:45.88,English,,0,0,0,,Then it's doomed
Dialogue: 0,1:16:45.08,1:16:45.88,Chinese,,0,0,0,,然后它就注定了
Dialogue: 0,1:16:46.48,1:16:49.68,English,,0,0,0,,Because there's no once it enters this
Dialogue: 0,1:16:46.48,1:16:49.68,Chinese,,0,0,0,,因为一旦进入
Dialogue: 0,1:16:50.64,1:16:54.54,English,,0,0,0,,Once it enters this deadlock region there's nowhere for it to go eventually
Dialogue: 0,1:16:50.64,1:16:54.54,Chinese,,0,0,0,,一旦它进入这个死锁区域，它最终无处可去
Dialogue: 0,1:16:55.60,1:16:57.26,English,,0,0,0,,No matter how it progresses
Dialogue: 0,1:16:55.60,1:16:57.26,Chinese,,0,0,0,,无论它如何进展
Dialogue: 0,1:16:57.82,1:17:04.66,English,,0,0,0,,Every trajectory will lead to this point here where It's boxed in and can no longer proceed
Dialogue: 0,1:16:57.82,1:17:04.66,Chinese,,0,0,0,,这里的每条轨迹上的点都被锁死了，不能继续下去了
Dialogue: 0,1:17:11.20,1:17:12.06,English,,0,0,0,,So
Dialogue: 0,1:17:11.20,1:17:12.06,Chinese,,0,0,0,,所以
Dialogue: 0,1:17:15.34,1:17:19.08,English,,0,0,0,,So interestingly this sort of this region back here
Dialogue: 0,1:17:15.34,1:17:19.08,Chinese,,0,0,0,,有趣的是，这个区域
Dialogue: 0,1:17:20.02,1:17:24.98,English,,0,0,0,,On the sort of the tail end of the of these two forbidden regions
Dialogue: 0,1:17:20.02,1:17:24.98,Chinese,,0,0,0,,这两个禁区的尾端
Dialogue: 0,1:17:25.66,1:17:27.98,English,,0,0,0,,This represents states that can never be reached
Dialogue: 0,1:17:25.66,1:17:27.98,Chinese,,0,0,0,,这表示永远无法出现的状态
Dialogue: 0,1:17:28.26,1:17:32.44,English,,0,0,0,,So these are on unreachable states which may or may not be interesting
Dialogue: 0,1:17:28.26,1:17:32.44,Chinese,,0,0,0,,这些是无法出现的状态，你们体会一下
Dialogue: 0,1:17:33.68,1:17:35.44,English,,0,0,0,,And then what makes this so nasty
Dialogue: 0,1:17:33.68,1:17:35.44,Chinese,,0,0,0,,麻烦的是
Dialogue: 0,1:17:36.96,1:17:37.76,English,,0,0,0,,Is that
Dialogue: 0,1:17:36.96,1:17:37.76,Chinese,,0,0,0,,就是它
Dialogue: 0,1:17:39.26,1:17:42.68,English,,0,0,0,,It's non-deterministic right some programs some trajectories
Dialogue: 0,1:17:39.26,1:17:42.68,Chinese,,0,0,0,,一些程序的某些轨迹是不确定的
Dialogue: 0,1:17:44.28,1:17:47.36,English,,0,0,0,,If they get lucky they'll skirt this deadlock region
Dialogue: 0,1:17:44.28,1:17:47.36,Chinese,,0,0,0,,如果他们幸运的话，他们会绕过这个死锁区
Dialogue: 0,1:17:48.44,1:17:50.66,English,,0,0,0,,And then the program will run fine right
Dialogue: 0,1:17:48.44,1:17:50.66,Chinese,,0,0,0,,然后程序运行正常
Dialogue: 0,1:17:52.94,1:17:55.58,English,,0,0,0,,There's okay so if it's trajectory maybe
Dialogue: 0,1:17:52.94,1:17:55.58,Chinese,,0,0,0,,如果它的轨迹可能
Dialogue: 0,1:17:57.50,1:18:01.56,English,,0,0,0,,Just by some you know just by some arbitrary scheduling decision
Dialogue: 0,1:17:57.50,1:18:01.56,Chinese,,0,0,0,,只是由一些人知道，只是通过一些特定的调度
Dialogue: 0,1:18:01.90,1:18:11.66,English,,0,0,0,,Made by the kernel the trajectory gets passed the deadlock region in this direction
Dialogue: 0,1:18:01.90,1:18:11.66,Chinese,,0,0,0,,由内核制作，轨迹在此方向上通过死锁区域
Dialogue: 0,1:18:13.00,1:18:16.98,English,,0,0,0,,And then it'll eventually run without any problem
Dialogue: 0,1:18:13.00,1:18:16.98,Chinese,,0,0,0,,然后它最终会毫无问题地运行
Dialogue: 0,1:18:17.84,1:18:25.46,English,,0,0,0,,So it's just it's only if the trajectory lands it within the deadlock region then there were that we're in trouble
Dialogue: 0,1:18:17.84,1:18:25.46,Chinese,,0,0,0,,因此，只有当轨迹落在死锁区域内时，才会发现我们遇到了麻烦
Dialogue: 0,1:18:26.76,1:18:34.78,English,,0,0,0,,So this is the really nasty, the really nasty part is that you may run your program for a million times and every trajectory
Dialogue: 0,1:18:26.76,1:18:34.78,Chinese,,0,0,0,,所以这是真正麻烦的部分，你可能运行你的程序一百万次只又一次这样的情况
Dialogue: 0,1:18:36.76,1:18:40.54,English,,0,0,0,,Every one of those million trajectories skirts the deadlock region
Dialogue: 0,1:18:36.76,1:18:40.54,Chinese,,0,0,0,,而这一百万次都绕过了死锁区域
Dialogue: 0,1:18:41.40,1:18:43.76,English,,0,0,0,,Okay but on the million and first time that you run it
Dialogue: 0,1:18:41.40,1:18:43.76,Chinese,,0,0,0,,但是这一百万次当中出现了一次
Dialogue: 0,1:18:44.50,1:18:47.50,English,,0,0,0,,It enters the deadlock region and then deadlocks
Dialogue: 0,1:18:44.50,1:18:47.50,Chinese,,0,0,0,,进入死锁区域然后死锁
Dialogue: 0,1:18:50.60,1:18:53.72,English,,0,0,0,,Okay so it's very it's a very tough problem to deal with
Dialogue: 0,1:18:50.60,1:18:53.72,Chinese,,0,0,0,,这是一个非常难以处理的问题
Dialogue: 0,1:18:55.06,1:18:57.80,English,,0,0,0,,Now fortunately you it's easy to avoid
Dialogue: 0,1:18:55.06,1:18:57.80,Chinese,,0,0,0,,幸运的是，这很容易避免
Dialogue: 0,1:18:58.94,1:19:07.32,English,,0,0,0,,If threads that are acquiring locks on resources acquire all those locks in the same order
Dialogue: 0,1:18:58.94,1:19:07.32,Chinese,,0,0,0,,如果获取资源锁的线程以相同的顺序释放所有这些锁
Dialogue: 0,1:19:07.66,1:19:11.78,English,,0,0,0,,Okay so in our example if we rewrite this program
Dialogue: 0,1:19:07.66,1:19:11.78,Chinese,,0,0,0,,在我们的例子中，如果我们重写这个程序
Dialogue: 0,1:19:11.86,1:19:17.42,English,,0,0,0,,So that each thread 0 and thread 1 acquire their locks in the same order
Dialogue: 0,1:19:11.86,1:19:17.42,Chinese,,0,0,0,,这样每个线程 0 和线程 1 以相同的顺序获取它们的锁
Dialogue: 0,1:19:18.36,1:19:22.08,English,,0,0,0,,Semaphore 0 first followed by semaphore 1
Dialogue: 0,1:19:18.36,1:19:22.08,Chinese,,0,0,0,,信号量 0 首先跟随信号量 1
Dialogue: 0,1:19:25.00,1:19:28.72,English,,0,0,0,,Then if that happens and we you can see
Dialogue: 0,1:19:25.00,1:19:28.72,Chinese,,0,0,0,,如果发生这种情况，我们就可以看到
Dialogue: 0,1:19:28.96,1:19:31.70,English,,0,0,0,,It eliminates the potential deadlock region
Dialogue: 0,1:19:28.96,1:19:31.70,Chinese,,0,0,0,,它消除了潜在的死锁区域
Dialogue: 0,1:19:35.76,1:19:39.40,English,,0,0,0,,Okay so now any trajectory that we take
Dialogue: 0,1:19:35.76,1:19:39.40,Chinese,,0,0,0,,现在我们的任何情况
Dialogue: 0,1:19:44.78,1:19:49.42,English,,0,0,0,,Will be fine because we've eliminated that that that deadlock region
Dialogue: 0,1:19:44.78,1:19:49.42,Chinese,,0,0,0,,都会没事的，因为我们已经消除了那个死锁区域
Dialogue: 0,1:19:50.12,1:19:53.44,English,,0,0,0,,And the order that we release the locks doesn't matter
Dialogue: 0,1:19:50.12,1:19:53.44,Chinese,,0,0,0,,我们释放锁的顺序无关紧要
Dialogue: 0,1:19:53.44,1:19:57.50,English,,0,0,0,,Because that sort of affects the
Dialogue: 0,1:19:53.44,1:19:57.50,Chinese,,0,0,0,,因为......
Dialogue: 0,1:20:00.38,1:20:06.10,English,,0,0,0,,It affects this or unreachable region you know the size and shape of this unreachable region
Dialogue: 0,1:20:00.38,1:20:06.10,Chinese,,0,0,0,,它会影响这个或无法到达的区域，你知道这个无法到达的区域的大小和形状
Dialogue: 0,1:20:08.02,1:20:13.68,English,,0,0,0,,But it there's never the order that we release the locks can never introduce a deadlock region
Dialogue: 0,1:20:08.02,1:20:13.68,Chinese,,0,0,0,,但是我们释放锁定的顺讯永远不会引入死锁区域
Dialogue: 0,1:20:17.66,1:20:19.20,English,,0,0,0,,Okay so that's it for today
Dialogue: 0,1:20:17.66,1:20:19.20,Chinese,,0,0,0,,好的，我们今天就讲到这里
Dialogue: 0,1:20:22.40,1:20:29.44,English,,0,0,0,,hope you all have a very nice Thanksgiving holiday and we'll see you on Tuesday
Dialogue: 0,1:20:22.40,1:20:29.44,Chinese,,0,0,0,,希望你们都有一个非常愉快的感恩节假期，周二再见！
